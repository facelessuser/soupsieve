{"config":{"lang":["en"],"separator":"[:\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quick Start","text":""},{"location":"#overview","title":"Overview","text":"<p>Soup Sieve is a CSS selector library designed to be used with Beautiful Soup 4. It aims to provide selecting, matching, and filtering using modern CSS selectors. Soup Sieve currently provides selectors from the CSS level 1 specifications up through the latest CSS level 4 drafts and beyond (though some are not yet implemented).</p> <p>Soup Sieve was written with the intent to replace Beautiful Soup's builtin select feature, and as of Beautiful Soup version 4.7.0, it now is . Soup Sieve can also be imported in order to use its API directly for more controlled, specialized parsing.</p> <p>Soup Sieve has implemented most of the CSS selectors up through the latest CSS draft specifications, though there are a number that don't make sense in a non-browser environment. Selectors that cannot provide meaningful functionality simply do not match anything. Some of the supported selectors are:</p> <ul> <li><code>.classes</code></li> <li><code>#ids</code></li> <li><code>[attributes=value]</code></li> <li><code>parent child</code></li> <li><code>parent &gt; child</code></li> <li><code>sibling ~ sibling</code></li> <li><code>sibling + sibling</code></li> <li><code>:not(element.class, element2.class)</code></li> <li><code>:is(element.class, element2.class)</code></li> <li><code>parent:has(&gt; child)</code></li> <li>and many more</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You must have Beautiful Soup already installed:</p> <pre><code>pip install beautifulsoup4\n</code></pre> <p>In most cases, assuming you've installed version 4.7.0, that should be all you need to do, but if you've installed via some alternative method, and Soup Sieve is not automatically installed, you can install it directly:</p> <pre><code>pip install soupsieve\n</code></pre> <p>If you want to manually install it from source, first ensure that <code>build</code> is installed:</p> <pre><code>pip install build\n</code></pre> <p>Then navigate to the root of the project and build the wheel and install (replacing <code>&lt;ver&gt;</code> with the current version):</p> <pre><code>python -m build -w\npip install dist/soupsive-&lt;ver&gt;-py3-none-any.whl\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>To use Soup Sieve, you must create a <code>BeautifulSoup</code> object:</p> <pre><code>&gt;&gt;&gt; import bs4\n\n&gt;&gt;&gt; text = \"\"\"\n... &lt;div&gt;\n... &lt;!-- These are animals --&gt;\n... &lt;p class=\"a\"&gt;Cat&lt;/p&gt;\n... &lt;p class=\"b\"&gt;Dog&lt;/p&gt;\n... &lt;p class=\"c\"&gt;Mouse&lt;/p&gt;\n... &lt;/div&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs4.BeautifulSoup(text, 'html5lib')\n</code></pre> <p>For most people, using the Beautiful Soup 4.7.0+ API may be more than sufficient. Beautiful Soup offers two methods that employ Soup Sieve: <code>select</code> and <code>select_one</code>. Beautiful Soup's select API is identical to Soup Sieve's, except that you don't have to hand it the tag object, the calling object passes itself to Soup Sieve:</p> <pre><code>&gt;&gt;&gt; soup = bs4.BeautifulSoup(text, 'html5lib')\n&gt;&gt;&gt; soup.select_one('p:is(.a, .b, .c)')\n&lt;p class=\"a\"&gt;Cat&lt;/p&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; soup = bs4.BeautifulSoup(text, 'html5lib')\n&gt;&gt;&gt; soup.select('p:is(.a, .b, .c)')\n[&lt;p class=\"a\"&gt;Cat&lt;/p&gt;, &lt;p class=\"b\"&gt;Dog&lt;/p&gt;, &lt;p class=\"c\"&gt;Mouse&lt;/p&gt;]\n</code></pre> <p>You can also use the Soup Sieve API directly to get access to the full range of possibilities that Soup Sieve offers. You can select a single tag:</p> <pre><code>&gt;&gt;&gt; import soupsieve as sv\n&gt;&gt;&gt; sv.select_one('p:is(.a, .b, .c)', soup)\n&lt;p class=\"a\"&gt;Cat&lt;/p&gt;\n</code></pre> <p>You can select all tags:</p> <pre><code>&gt;&gt;&gt; import soupsieve as sv\n&gt;&gt;&gt; sv.select('p:is(.a, .b, .c)', soup)\n[&lt;p class=\"a\"&gt;Cat&lt;/p&gt;, &lt;p class=\"b\"&gt;Dog&lt;/p&gt;, &lt;p class=\"c\"&gt;Mouse&lt;/p&gt;]\n</code></pre> <p>You can select the closest ancestor:</p> <pre><code>&gt;&gt;&gt; import soupsieve as sv\n&gt;&gt;&gt; el = sv.select_one('.c', soup)\n&gt;&gt;&gt; sv.closest('div', el)\n&lt;div&gt;\n&lt;!-- These are animals --&gt;\n&lt;p class=\"a\"&gt;Cat&lt;/p&gt;\n&lt;p class=\"b\"&gt;Dog&lt;/p&gt;\n&lt;p class=\"c\"&gt;Mouse&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>You can filter a tag's Children (or an iterable of tags):</p> <pre><code>&gt;&gt;&gt; sv.filter('p:not(.b)', soup.div)\n[&lt;p class=\"a\"&gt;Cat&lt;/p&gt;, &lt;p class=\"c\"&gt;Mouse&lt;/p&gt;]\n</code></pre> <p>You can match a single tag:</p> <pre><code>&gt;&gt;&gt; els = sv.select('p:is(.a, .b, .c)', soup)\n&gt;&gt;&gt; sv.match('p:not(.b)', els[0])\nTrue\n&gt;&gt;&gt; sv.match('p:not(.b)', els[1])\nFalse\n</code></pre> <p>Or even just extract comments:</p> <pre><code>&gt;&gt;&gt; sv.comments(soup)\n[' These are animals ']\n</code></pre> <p>Selectors do not have to be constrained to one line either. You can span selectors over multiple lines just like you would in a CSS file.</p> <pre><code>&gt;&gt;&gt; selector = \"\"\"\n... .a,\n... .b,\n... .c\n... \"\"\"\n&gt;&gt;&gt; sv.select(selector, soup)\n[&lt;p class=\"a\"&gt;Cat&lt;/p&gt;, &lt;p class=\"b\"&gt;Dog&lt;/p&gt;, &lt;p class=\"c\"&gt;Mouse&lt;/p&gt;]\n</code></pre> <p>You can even use comments to annotate a particularly complex selector.</p> <pre><code>&gt;&gt;&gt; selector = \"\"\"\n... /* This isn't complicated, but we're going to annotate it anyways.\n...    This is the a class */\n... .a,\n... /* This is the b class */\n... .b,\n... /* This is the c class */\n... .c\n... \"\"\"\n&gt;&gt;&gt; sv.select(selector, soup)\n[&lt;p class=\"a\"&gt;Cat&lt;/p&gt;, &lt;p class=\"b\"&gt;Dog&lt;/p&gt;, &lt;p class=\"c\"&gt;Mouse&lt;/p&gt;]\n</code></pre> <p>If you've ever used Python's Re library for regular expressions, you may know that it is often useful to pre-compile a regular expression pattern, especially if you plan to use it more than once.  The same is true for Soup Sieve's matchers, though is not required.  If you have a pattern that you want to use more than once, it may be wise to pre-compile it early on:</p> <pre><code>&gt;&gt;&gt; selector = sv.compile('p:is(.a, .b, .c)')\n&gt;&gt;&gt; selector.filter(soup.div)\n[&lt;p class=\"a\"&gt;Cat&lt;/p&gt;, &lt;p class=\"b\"&gt;Dog&lt;/p&gt;, &lt;p class=\"c\"&gt;Mouse&lt;/p&gt;]\n</code></pre> <p>A compiled object has all the same methods, though the parameters will be slightly different as they don't need things like the pattern or flags once compiled. See API documentation for more info.</p> <p>Compiled patterns are cached, so if for any reason you need to clear the cache, simply issue the <code>purge</code> command.</p> <pre><code>&gt;&gt;&gt; sv.purge()\n</code></pre>"},{"location":"api/","title":"API","text":"<p>Soup Sieve implements most of the selectors from the stable specification and even many from the latest draft specification. Selectors can be used to detect and filter elements. To learn more about which specific selectors are implemented, see CSS Selectors.</p> <p>Soup Sieve will detect the document type being used from the Beautiful Soup object that is given to it, and depending on the document type, its behavior may be slightly different.</p> <p>When detecting XHTML, Soup Sieve simply looks to see if the root element of an XML document is under the XHTML namespace and does not currently look at the <code>doctype</code>. If in the future there is a need for stricter XHTML detection, this may change.</p> <ul> <li> <p>HTML document types (HTML, HTML5) will have their tag names and attribute names treated without case     sensitivity, like most browsers do.</p> </li> <li> <p>XML document types (including XHTML) will have their tag names and attribute names treated with case sensitivity.</p> </li> <li> <p>HTML5, XHTML and XML documents will have namespaces evaluated per the document's support (provided via the     parser). Some additional configuration is required when using namespaces, see Namespace for more     information.</p> <p>Getting Proper Namespaces</p> <p>The <code>html5lib</code> parser provides proper namespaces for HTML5, but <code>lxml</code>'s HTML parser will not. If you need namespace support for HTML5, consider using <code>html5lib</code>.</p> <p>For XML, the <code>lxml-xml</code> parser (<code>xml</code> for short) will provide proper namespaces. It is generally suggested that <code>lxml-xml</code> is used to parse XHTML documents to take advantage of namespaces.</p> </li> <li> <p>While attribute values are generally treated as case sensitive, HTML5 and HTML treat the <code>type</code> attribute     special. The <code>type</code> attribute's value is always case insensitive. This is generally how most browsers treat <code>type</code>.     If you need <code>type</code> to be sensitive, you can use the <code>s</code> flag: <code>[type=\"submit\" s]</code>.</p> </li> </ul> <p>While Soup Sieve access is exposed through Beautiful Soup's API, Soup Sieve's API can always be imported and accessed directly for more controlled tag selection if needed.</p>"},{"location":"api/#flags","title":"Flags","text":""},{"location":"api/#soupseivedebug","title":"<code>soupseive.DEBUG</code>","text":"<p>Print debug output when parsing a selector.</p> <pre><code>&gt;&gt;&gt; import soupsieve as sv\n&gt;&gt;&gt; sv.compile('p:has(#id) &gt; span.some-class:contains(text)', flags=sv.DEBUG)\n## PARSING: 'p:has(#id) &gt; span.some-class:contains(text)'\nTOKEN: 'tag' --&gt; 'p' at position 0\nTOKEN: 'pseudo_class' --&gt; ':has(' at position 1\n    is_pseudo: True\n    is_open: True\n    is_relative: True\nTOKEN: 'id' --&gt; '#id' at position 6\nTOKEN: 'pseudo_close' --&gt; ')' at position 9\nTOKEN: 'combine' --&gt; ' &gt; ' at position 10\nTOKEN: 'tag' --&gt; 'span' at position 13\nTOKEN: 'class' --&gt; '.some-class' at position 17\nTOKEN: 'pseudo_contains' --&gt; ':contains(text)' at position 28\n## END PARSING\nSoupSieve(pattern='p:has(#id) &gt; span.some-class:contains(text)', namespaces=None, custom=None, flags=1)\n</code></pre>"},{"location":"api/#soupsieveselect_one","title":"<code>soupsieve.select_one()</code>","text":"<pre><code>def select_one(select, tag, namespaces=None, flags=0, **kwargs):\n    \"\"\"Select the specified tags.\"\"\"\n</code></pre> <p><code>select_one</code> will return the first tag under the given tag that matches the given CSS selectors provided, or it will return <code>None</code> if a suitable tag was not found.</p> <p><code>select_one</code> accepts a CSS selector string, a <code>Tag</code>/<code>BeautifulSoup</code> object, an optional namespace dictionary, and <code>flags</code>.</p> <pre><code>&gt;&gt;&gt; import soupsieve as sv\n&gt;&gt;&gt; sv.select_one('p:is(.a, .b, .c)', soup)\n&lt;p class=\"a\"&gt;Cat&lt;/p&gt;\n</code></pre>"},{"location":"api/#soupsieveselect","title":"<code>soupsieve.select()</code>","text":"<pre><code>def select(select, tag, namespaces=None, limit=0, flags=0, **kwargs):\n    \"\"\"Select the specified tags.\"\"\"\n</code></pre> <p><code>select</code> will return all tags under the given tag that match the given CSS selectors provided. You can also limit the number of tags returned by providing a positive integer via the <code>limit</code> parameter (0 means to return all tags).</p> <p><code>select</code> accepts a CSS selector string, a <code>Tag</code>/<code>BeautifulSoup</code> object, an optional namespace dictionary, a <code>limit</code>, and <code>flags</code>.</p> <pre><code>&gt;&gt;&gt; import soupsieve as sv\n&gt;&gt;&gt; sv.select('p:is(.a, .b, .c)', soup)\n[&lt;p class=\"a\"&gt;Cat&lt;/p&gt;, &lt;p class=\"b\"&gt;Dog&lt;/p&gt;, &lt;p class=\"c\"&gt;Mouse&lt;/p&gt;]\n</code></pre>"},{"location":"api/#soupsieveiselect","title":"<code>soupsieve.iselect()</code>","text":"<pre><code>def iselect(select, node, namespaces=None, limit=0, flags=0, **kwargs):\n    \"\"\"Select the specified tags.\"\"\"\n</code></pre> <p><code>iselect</code> is exactly like <code>select</code> except that it returns a generator instead of a list.</p>"},{"location":"api/#soupsieveclosest","title":"<code>soupsieve.closest()</code>","text":"<pre><code>def closest(select, tag, namespaces=None, flags=0, **kwargs):\n    \"\"\"Match closest ancestor to the provided tag.\"\"\"\n</code></pre> <p><code>closest</code> returns the tag closest to the given tag that matches the given selector. The element found must be a direct ancestor of the tag or the tag itself.</p> <p><code>closest</code> accepts a CSS selector string, a <code>Tag</code>/<code>BeautifulSoup</code> object, an optional namespace dictionary, and <code>flags</code>.</p>"},{"location":"api/#soupsievematch","title":"<code>soupsieve.match()</code>","text":"<pre><code>def match(select, tag, namespaces=None, flags=0, **kwargs):\n    \"\"\"Match node.\"\"\"\n</code></pre> <p>The <code>match</code> function matches a given tag with a given CSS selector.</p> <p><code>match</code> accepts a CSS selector string, a <code>Tag</code>/<code>BeautifulSoup</code> object, an optional namespace dictionary, and flags.</p> <pre><code>&gt;&gt;&gt; nodes = sv.select('p:is(.a, .b, .c)', soup)\n&gt;&gt;&gt; sv.match('p:not(.b)', nodes[0])\nTrue\n&gt;&gt;&gt; sv.match('p:not(.b)', nodes[1])\nFalse\n</code></pre>"},{"location":"api/#soupsievefilter","title":"<code>soupsieve.filter()</code>","text":"<pre><code>def filter(select, nodes, namespaces=None, flags=0, **kwargs):\n    \"\"\"Filter list of nodes.\"\"\"\n</code></pre> <p><code>filter</code> takes an iterable containing HTML nodes and will filter them based on the provided CSS selector string. If given a <code>Tag</code>/<code>BeautifulSoup</code> object, it will iterate the direct children filtering them.</p> <p><code>filter</code> accepts a CSS selector string, an iterable containing nodes, an optional namespace dictionary, and flags.</p> <pre><code>&gt;&gt;&gt; sv.filter('p:not(.b)', soup.div)\n[&lt;p class=\"a\"&gt;Cat&lt;/p&gt;, &lt;p class=\"c\"&gt;Mouse&lt;/p&gt;]\n</code></pre>"},{"location":"api/#soupsieveescape","title":"<code>soupsieve.escape()</code>","text":"<pre><code>def escape(ident):\n    \"\"\"Escape CSS identifier.\"\"\"\n</code></pre> <p><code>escape</code> is used to escape CSS identifiers. It follows the CSS specification and escapes any character that would normally cause an identifier to be invalid.</p> <pre><code>&gt;&gt;&gt; sv.escape(\".foo#bar\")\n'\\\\.foo\\\\#bar'\n&gt;&gt;&gt; sv.escape(\"()[]{}\")\n'\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}'\n&gt;&gt;&gt; sv.escape('--a')\n'--a'\n&gt;&gt;&gt; sv.escape('0')\n'\\\\30 '\n&gt;&gt;&gt; sv.escape('\\0')\n'\ufffd'\n</code></pre> <p>New in 1.9.0</p> <p><code>escape</code> is a new API function added in 1.9.0.</p>"},{"location":"api/#soupsievecompile","title":"<code>soupsieve.compile()</code>","text":"<pre><code>def compile(pattern, namespaces=None, flags=0, **kwargs):\n    \"\"\"Compile CSS pattern.\"\"\"\n</code></pre> <p><code>compile</code> will pre-compile a CSS selector pattern returning a <code>SoupSieve</code> object. The <code>SoupSieve</code> object has the same selector functions available via the module without the need to specify the selector, namespaces, or flags.</p> <pre><code>class SoupSieve:\n    \"\"\"Match tags in Beautiful Soup with CSS selectors.\"\"\"\n\n    def match(self, tag):\n        \"\"\"Match.\"\"\"\n\n    def closest(self, tag):\n        \"\"\"Match closest ancestor.\"\"\"\n\n    def filter(self, iterable):\n        \"\"\"Filter.\"\"\"\n\n    def select_one(self, tag):\n        \"\"\"Select a single tag.\"\"\"\n\n    def select(self, tag, limit=0):\n        \"\"\"Select the specified tags.\"\"\"\n\n    def iselect(self, tag, limit=0):\n        \"\"\"Iterate the specified tags.\"\"\"\n</code></pre>"},{"location":"api/#soupsievepurge","title":"<code>soupsieve.purge()</code>","text":"<p>Soup Sieve caches compiled patterns for performance. If for whatever reason, you need to purge the cache, simply call <code>purge</code>.</p>"},{"location":"api/#custom-selectors","title":"Custom Selectors","text":"<p>The custom selector feature is loosely inspired by the <code>css-extensions</code> proposal. In its current form, Soup Sieve allows assigning a complex selector to a custom pseudo-class name. The pseudo-class name must start with <code>:--</code> to avoid conflicts with any future pseudo-classes.</p> <p>To create custom selectors, you simply need to pass a dictionary containing the custom pseudo-class names (keys) with the associated CSS selectors that the pseudo-classes are meant to represent (values). It is important to remember that pseudo-class names are not case sensitive, so even though a dictionary will allow you to specify multiple keys with the same name (as long as the character cases are different), Soup Sieve will not and will throw an exception if you attempt to do so.</p> <p>In the following example, we will define our own custom selector called <code>:--header</code> that will be an alias for <code>h1, h2, h3, h4, h5, h6</code>.</p> <pre><code>import soupsieve as sv\nimport bs4\n\nmarkup = \"\"\"\n&lt;html&gt;\n&lt;body&gt;\n&lt;h1 id=\"1\"&gt;Header 1&lt;/h1&gt;\n&lt;h2 id=\"2\"&gt;Header 2&lt;/h2&gt;\n&lt;p id=\"3\"&gt;&lt;/p&gt;\n&lt;p id=\"4\"&gt;&lt;span&gt;child&lt;/span&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html\n\"\"\"\n\nsoup = bs4.BeautifulSoup(markup, 'lxml')\nprint(sv.select(':--header', soup, custom={':--header': 'h1, h2, h3, h4, h5, h6'}))\n</code></pre> <p>The above code, when run, should yield the following output:</p> <pre><code>[&lt;h1 id=\"1\"&gt;Header 1&lt;/h1&gt;, &lt;h2 id=\"2\"&gt;Header 2&lt;/h2&gt;]\n</code></pre> <p>Custom selectors can also be dependent upon other custom selectors. You don't have to worry about the order in the dictionary as custom selectors will be compiled \"just in time\" when they are needed. Be careful though, if you create a circular dependency, you will get a <code>SelectorSyntaxError</code>.</p> <p>Assuming the same markup as in the first example, we will now create a custom selector that should find any element that has child elements, we will call the selector <code>:--parent</code>. Then we will create another selector called <code>:--parent-paragraph</code> that will use the <code>:--parent</code> selector to find <code>&lt;p&gt;</code> elements that are also parents:</p> <pre><code>custom = {\n    \":--parent\": \":has(&gt; *|*)\",\n    \":--parent-paragraph\": \"p:--parent\"\n}\nprint(sv.select(':--parent-paragraph', soup, custom=custom))\n</code></pre> <p>The above code will yield the only paragraph that is a parent:</p> <pre><code>[&lt;p id=\"4\"&gt;&lt;span&gt;child&lt;/span&gt;&lt;/p&gt;]\n</code></pre>"},{"location":"api/#namespaces","title":"Namespaces","text":"<p>Many of Soup Sieve's selector functions take an optional namespace dictionary. Namespaces, just like CSS, must be defined for Soup Sieve to evaluate <code>ns|tag</code> type selectors. This is analogous to CSS's namespace at-rule:</p> <pre><code>@namespace url(\"http://www.w3.org/1999/xhtml\");\n@namespace svg url(\"http://www.w3.org/2000/svg\");\n</code></pre> <p>A namespace dictionary should have keys (prefixes) and values (namespaces). An empty key string for a key would denote the default key.  An empty value would essentially represent a null namespace.  To represent the above CSS example for Soup Sieve, we would configure it like so:</p> <pre><code>namespace = {\n    \"\": \"http://www.w3.org/1999/xhtml\",   # Default namespace is for XHTML\n    \"svg\": \"http://www.w3.org/2000/svg\",  # The SVG namespace defined with prefix of \"svg\"\n}\n</code></pre> <p>Prefixes used in the namespace dictionary do not have to match the prefixes in the document. The provided prefix is never compared against the prefixes in the document, only the namespaces are compared. The prefixes in the document are only there for the parser to know which tags get which namespace. And the prefixes in the namespace dictionary are only defined in order to provide an alias for the namespaces when using the namespace selector syntax: <code>ns|name</code>.</p> <p>Tags do not necessarily have to have a prefix for Soup Sieve to recognize them either.  For instance, in HTML5, SVG should automatically get the SVG namespace. Depending how namespaces were defined in the document, tags may inherit namespaces in some conditions.  Namespace assignment is mainly handled by the parser and exposed through the Beautiful Soup API. Soup Sieve uses the Beautiful Soup API to then compare namespaces for supported documents.</p>"},{"location":"differences/","title":"Beautiful Soup Differences","text":"<p>Soup Sieve is the official CSS \"select\" implementation of Beautiful Soup 4.7.0+. While the inclusion of Soup Sieve fixes many issues and greatly expands CSS support in Beautiful Soup, it does introduce some differences which may surprise some who've become accustom to the old \"select\" implementation.</p> <p>Beautiful Soup's old select method had numerous limitations and quirks that do not align with the actual CSS specifications. Most are insignificant, but there are a couple differences that people over the years had come to rely on. Soup Sieve, which aims to follow the CSS specification closely, does not support these differences.</p>"},{"location":"differences/#attribute-values","title":"Attribute Values","text":"<p>Beautiful Soup was very relaxed when it came to attribute values in selectors: <code>[attribute=value]</code>. Beautiful Soup would allow almost anything for a valid unquoted value. Soup Sieve, on the other hand, follows the CSS specification and requires that a value be a valid identifier, or it must be quoted. If you get an error complaining about a malformed attribute, you may need to quote the value.</p> <p>For instance, if you previously used a selector like this:</p> <pre><code>soup.select('[attr={}]')\n</code></pre> <p>You would need to quote the value as <code>{}</code> is not a valid CSS identifier, so it must be quoted:</p> <pre><code>soup.select('[attr=\"{}\"]')\n</code></pre> <p>You can also use the escape function to escape dynamic content:</p> <pre><code>import soupsieve\nsoup.select('[attr=%s]' % soupsieve.escape('{}'))\n</code></pre>"},{"location":"differences/#css-identifiers","title":"CSS Identifiers","text":"<p>Since Soup Sieve follows the CSS specification, class names, id names, tag names, etc. must be valid identifiers. Since identifiers, according to the CSS specification, cannot start with a number, some users may find that their old class, id, or tag name selectors that started with numbers will not work. To specify such selectors, you'll have to use CSS escapes.</p> <p>So if you used to use:</p> <pre><code>soup.select('.2class')\n</code></pre> <p>You would need to update with:</p> <pre><code>soup.select(r'.\\32 class')\n</code></pre> <p>Numbers in the middle or at the end of a class will work as they always did:</p> <pre><code>soup.select('.class2')\n</code></pre>"},{"location":"differences/#relative-selectors","title":"Relative Selectors","text":"<p>Whether on purpose or on accident, Beautiful Soup used to allow relative selectors:</p> <pre><code>soup.select('&gt; div')\n</code></pre> <p>The above is not a valid CSS selector according the CSS specifications. Relative selector lists have only recently been added to the CSS specifications, and they are only allowed in a <code>:has()</code> pseudo-class:</p> <pre><code>article:has(&gt; div)\n</code></pre> <p>But, in the level 4 CSS specifications, the <code>:scope</code> pseudo-class has been added which allows for the same feel as using <code>&gt; div</code>. Since Soup Sieve supports the <code>:scope</code> pseudo-class, it can be used to produce the same behavior as the legacy select method.</p> <p>In CSS, the <code>:scope</code> pseudo-class represents the element that the CSS select operation is called on. In supported browsers, the following JavaScript example would treats <code>:scope</code> as the element that <code>el</code> references:</p> <pre><code>el.querySelectorAll(':scope &gt; .class')\n</code></pre> <p>Just like in the JavaScript example above, Soup Sieve would also treat <code>:scope</code> as the element that <code>el</code> references:</p> <pre><code>el.select(':scope &gt; .class')\n</code></pre> <p>In the case where the element is the document node, <code>:scope</code> would simply represent the root element of the document.</p> <p>So, if you used to to have selectors such as:</p> <pre><code>soup.select('&gt; div')\n</code></pre> <p>You can simply add <code>:scope</code>, and it should work the same:</p> <pre><code>soup.select(':scope &gt; div')\n</code></pre> <p>While this will generally give you what is expected for the relative, descendant selectors, this will not work for sibling selectors, and the reasons why are covered in more details in Out of Scope Selectors.</p>"},{"location":"differences/#out-of-scope-selectors","title":"Out of Scope Selectors","text":"<p>In a browser, when requesting a selector via <code>querySelectorAll</code>, the element that <code>querySelectorAll</code> is called on is the scoped element. So in the following example, <code>el</code> is the scoped element.</p> <pre><code>el.querySelectorAll('.class')\n</code></pre> <p>This same concept applies to Soup Sieve, where the element that <code>select</code> or <code>select_one</code> is called on is also the scoped element. So in the following example, <code>el</code> is also the scoped element:</p> <pre><code>el.select('.class')\n</code></pre> <p>In browsers, <code>querySelectorAll</code> and <code>querySelector</code> only return elements under the scoped element. They do not return the scoped element itself, its parents, or its siblings. Only when <code>querySelectorAll</code> or <code>querySelector</code> is called on the document node will it return the scoped selector, which would be the root element, as the query is being called on the document itself and not the scoped element.</p> <p>Soup Sieve aims to essentially mimic the browser functions such as <code>querySelector</code>, <code>querySelectorAll</code>, <code>matches</code>, etc. In Soup Sieve <code>select</code> and <code>select_one</code> are analogous to <code>querySelectorAll</code> and <code>querySelector</code> respectively. For this reason, Soup Sieve also only returns elements under the scoped element. The idea is to provide a familiar interface that behaves, as close as possible, to what people familiar with CSS selectors are used to.</p> <p>So while Soup Sieve will find elements relative to <code>:scope</code> with <code>&gt;</code> or <code> </code>:</p> <pre><code>soup.select(':scope &gt; div')\n</code></pre> <p>It will not find elements relative to <code>:scope</code> with <code>+</code> or <code>~</code> as siblings to the scoped element are not under the scoped element:</p> <pre><code>soup.select(':scope + div')\n</code></pre> <p>This is by design and is in align with the behavior exhibited in all web browsers.</p>"},{"location":"differences/#selected-element-order","title":"Selected Element Order","text":"<p>Another quirk of Beautiful Soup's old implementation was that it returned the HTML nodes in the order of how the selectors were defined. For instance, Beautiful Soup, if given the pattern <code>article, body</code> would first return <code>&lt;article&gt;</code> and then <code>&lt;body&gt;</code>.</p> <p>Soup Sieve does not, and frankly cannot, honor Beautiful Soup's old ordering convention due to the way it is designed. Soup Sieve returns the nodes in the order they are defined in the document as that is how the elements are searched. This much more efficient and provides better performance.</p> <p>So, given the earlier selector pattern of <code>article, body</code>, Soup Sieve would return the element <code>&lt;body&gt;</code> and then <code>&lt;article&gt;</code> as that is how it is ordered in the HTML document.</p>"},{"location":"faq/","title":"Frequent Asked Questions","text":""},{"location":"faq/#why-do-selectors-not-work-the-same-in-beautiful-soup-47","title":"Why do selectors not work the same in Beautiful Soup 4.7+?","text":"<p>Soup Sieve is the official CSS selector library in Beautiful Soup 4.7+, and with this change, Soup Sieve introduces a number of changes that break some of the expected behaviors that existed in versions prior to 4.7.</p> <p>In short, Soup Sieve follows the CSS specifications fairly close, and this broke a number of non-standard behaviors. These non-standard behaviors were not allowed according to the CSS specifications. Soup Sieve has no intentions of bringing back these behaviors.</p> <p>For more details on specific changes, and the reasoning why a specific change is considered a good change, or simply a feature that Soup Sieve cannot/will not support, see Beautiful Soup Differences.</p>"},{"location":"faq/#how-does-iframe-handling-work","title":"How does <code>iframe</code> handling work?","text":"<p>In web browsers, CSS selectors do not usually select content inside an <code>iframe</code> element if the selector is called on an element outside of the <code>iframe</code>. Each HTML document is usually encapsulated and CSS selector leakage across this <code>iframe</code> boundary is usually prevented.</p> <p>In it's current iteration, Soup Sieve is not aware of the origin of the documents in the <code>iframe</code>, and Soup Sieve will not prevent selectors from crossing these boundaries. Soup Sieve is not used to style documents, but to scrape documents. For this reason, it seems to be more helpful to allow selector combinators to cross these boundaries.</p> <p>Soup Sieve isn't entirely unaware of <code>iframe</code> elements though. In Soup Sieve 1.9.1, it was noticed that some pseudo-classes behaved in unexpected ways without awareness to <code>iframes</code>, this was fixed in 1.9.1. Pseudo-classes such as <code>:default</code>, <code>:indeterminate</code>, <code>:dir()</code>, <code>:lang()</code>, <code>:root</code>, and <code>:contains()</code> where given awareness of <code>iframes</code> to ensure they behaved properly and returned the expected elements. This doesn't mean that <code>select</code> won't return elements in <code>iframes</code>, but it won't allow something like <code>:default</code> to select a <code>button</code> in an <code>iframe</code> whose parent <code>form</code> is outside the <code>iframe</code>. Or better put, a default <code>button</code> will be evaluated in the context of the document it is in.</p> <p>With all of this said, if your selectors have issues with <code>iframes</code>, it is most likely because <code>iframes</code> are handled differently by different parsers. <code>html.parser</code> will usually parse <code>iframe</code> elements as it sees them. <code>lxml</code> parser will often remove <code>html</code> and <code>body</code> tags of an <code>iframe</code> HTML document. <code>lxml-xml</code> will simply ignore the content in a XHTML document. And <code>html5lib</code> will HTML escape the content of an <code>iframe</code> making traversal impossible.</p> <p>In short, Soup Sieve will return elements from all documents, even <code>iframes</code>. But certain pseudo-classes may take into consideration the context of the document they are in. But even with all of this, a parser's handling of <code>iframes</code> may make handling its content difficult if it doesn't parse it as HTML elements, or augments its structure.</p>"},{"location":"about/changelog/","title":"Changelog","text":""},{"location":"about/changelog/#26","title":"2.6","text":"<ul> <li>NEW: Add official support for Python 3.13.</li> <li>NEW: Add support for <code>&amp;</code> as scoping root per the CSS Nesting Module, Level 1. When <code>&amp;</code> is used outside the     context of nesting, it is treated as the scoping root (equivalent to <code>:scope</code>).</li> <li>FIX: Improve error message when an unrecognized pseudo-class is used.</li> </ul>"},{"location":"about/changelog/#25","title":"2.5","text":"<ul> <li>NEW: Update to support Python 3.12.</li> <li>NEW: Drop support for Python 3.7.</li> </ul>"},{"location":"about/changelog/#241","title":"2.4.1","text":"<ul> <li>FIX: Attribute syntax for case insensitive flag optionally allows a space, it does not require one.</li> </ul>"},{"location":"about/changelog/#24","title":"2.4","text":"<ul> <li>NEW: Update to support changes related to <code>:lang()</code> in the official CSS spec. <code>:lang(\"\")</code> should match     unspecified languages, e.g. <code>lang=\"\"</code>, but not <code>lang=und</code>.</li> <li>NEW: Only <code>:is()</code> and <code>:where()</code> should allow forgiving selector lists according to latest CSS (as far as Soup     Sieve supports \"forgiving\" which is limited to empty selectors).</li> <li>NEW: Formally drop Python 3.6.</li> <li>NEW: Formally declare support for Python 3.11.</li> </ul>"},{"location":"about/changelog/#232post1","title":"2.3.2.post1","text":"<ul> <li>FIX: Documentation for installation from source is outdated.</li> </ul>"},{"location":"about/changelog/#232","title":"2.3.2","text":"<ul> <li>FIX: Fix some typos in error messages.</li> </ul>"},{"location":"about/changelog/#231","title":"2.3.1","text":"<ul> <li>FIX: Ensure attribute selectors match tags that have new line characters in attributes. (#233)</li> </ul>"},{"location":"about/changelog/#23","title":"2.3","text":"<ul> <li>NEW: Officially support Python 3.10.</li> <li>NEW: Add static typing.</li> <li>NEW: <code>:has()</code>, <code>:is()</code>, and <code>:where()</code> now use use a forgiving selector list. While not as forgiving as CSS     might be, it will forgive such things as empty sets and empty slots due to multiple consecutive commas, leading     commas, or trailing commas. Essentially, these pseudo-classes will match all non-empty selectors and ignore empty     ones. As the scraping environment is different than a browser environment, it was chosen not to aggressively forgive     bad syntax and invalid features to ensure the user is alerted that their program may not perform as expected.</li> <li>NEW: Add support to output a pretty print format of a compiled <code>SelectorList</code> for debug purposes.</li> <li>FIX: Some small corner cases discovered with static typing.</li> </ul>"},{"location":"about/changelog/#221","title":"2.2.1","text":"<ul> <li>FIX: Fix an issue with namespaces when one of the keys is <code>self</code>.</li> </ul>"},{"location":"about/changelog/#22","title":"2.2","text":"<ul> <li>NEW: <code>:link</code> and <code>:any-link</code> no longer include <code>&lt;link&gt;</code> due to a change in the level 4 selector     specification. This actually yields more sane results.</li> <li>FIX: BeautifulSoup, when using <code>find</code>, is quite forgiving of odd types that a user may place in an element's     attribute value. Soup Sieve will also now be more forgiving and attempt to match these unexpected values in a sane     manner by normalizing them before compare. (#212)</li> </ul>"},{"location":"about/changelog/#21","title":"2.1","text":"<ul> <li>NEW: Officially support Python 3.9.</li> <li>NEW: Drop official support for Python 3.5.</li> <li>NEW: In order to avoid conflicts with future CSS specification changes, non-standard pseudo classes will now     start with the <code>:-soup-</code> prefix. As a consequence, <code>:contains()</code> will now be known as <code>:-soup-contains()</code>, though     for a time the deprecated form of <code>:contains()</code> will still be allowed with a warning that users should migrate over     to <code>:-soup-contains()</code>.</li> <li>NEW: Added new non-standard pseudo class <code>:-soup-contains-own()</code> which operates similar to <code>:-soup-contains()</code>     except that it only looks at text nodes directly associated with the currently scoped element and not its     descendants.</li> <li>FIX: Import <code>bs4</code> globally instead of in local functions as it appears there are no adverse affects due to     circular imports as <code>bs4</code> does not immediately reference <code>soupsieve</code> functions and <code>soupsieve</code> does not immediately     reference <code>bs4</code> functions. This should give a performance boost to functions that had previously included <code>bs4</code>     locally.</li> </ul>"},{"location":"about/changelog/#201","title":"2.0.1","text":"<ul> <li>FIX: Remove unused code.</li> </ul>"},{"location":"about/changelog/#20","title":"2.0","text":"<ul> <li>NEW: <code>SelectorSyntaxError</code> is derived from <code>Exception</code> not <code>SyntaxError</code>.</li> <li>NEW: Remove deprecated <code>comments</code> and <code>icomments</code> from the API.</li> <li>NEW: Drop support for EOL Python versions (Python 2 and Python &lt; 3.5).</li> <li>FIX: Corner case with splitting namespace and tag name that that have an escaped <code>|</code>.</li> </ul>"},{"location":"about/changelog/#196","title":"1.9.6","text":"<p>Last version for Python 2.7</p> <ul> <li>FIX: Prune dead code.</li> <li>FIX: Corner case with splitting namespace and tag name that that have an escaped <code>|</code>.</li> </ul>"},{"location":"about/changelog/#195","title":"1.9.5","text":"<ul> <li>FIX: <code>:placeholder-shown</code> should not match if the element has content that overrides the placeholder.</li> </ul>"},{"location":"about/changelog/#194","title":"1.9.4","text":"<ul> <li>FIX: <code>:checked</code> rule was too strict with <code>option</code> elements. The specification for <code>:checked</code> does not require an     <code>option</code> element to be under a <code>select</code> element.</li> <li>FIX: Fix level 4 <code>:lang()</code> wildcard match handling with singletons. Implicit wildcard matching should not     match any singleton. Explicit wildcard matching (<code>*</code> in the language range: <code>*-US</code>) is allowed to match singletons.</li> </ul>"},{"location":"about/changelog/#193","title":"1.9.3","text":"<ul> <li>FIX: <code>[attr!=value]</code> pattern was mistakenly using <code>:not([attr|=value])</code> logic instead of <code>:not([attr=value])</code>.</li> <li>FIX: Remove undocumented <code>_QUIRKS</code> mode flag. Beautiful Soup was meant to use it to help with transition to Soup     Sieve, but never released with it. Help with transition at this point is no longer needed.</li> </ul>"},{"location":"about/changelog/#192","title":"1.9.2","text":"<ul> <li>FIX: Shortcut last descendant calculation if possible for performance.</li> <li>FIX: Fix issue where <code>Doctype</code> strings can be mistaken for a normal text node in some cases.</li> <li>FIX: A top level tag is not a <code>:root</code> tag if it has sibling text nodes or tag nodes. This is an issue that     mostly manifests when using <code>html.parser</code> as the parser will allow multiple root nodes.</li> </ul>"},{"location":"about/changelog/#191","title":"1.9.1","text":"<ul> <li>FIX: <code>:root</code>, <code>:contains()</code>, <code>:default</code>, <code>:indeterminate</code>, <code>:lang()</code>, and <code>:dir()</code> will properly account for     HTML <code>iframe</code> elements in their logic when selecting or matching an element. Their logic will be restricted to the     document for which the element under consideration applies.</li> <li>FIX: HTML pseudo-classes will check that all key elements checked are in the XHTML namespace (HTML parsers that     do not provide namespaces will assume the XHTML namespace).</li> <li>FIX: Ensure that all pseudo-class names are case insensitive and allow CSS escapes.</li> </ul>"},{"location":"about/changelog/#19","title":"1.9","text":"<ul> <li>NEW: Allow <code>:contains()</code> to accept a list of text to search for. (#115)</li> <li>NEW: Add new <code>escape</code> function for escaping CSS identifiers. (#125)</li> <li>NEW: Deprecate <code>comments</code> and <code>icomments</code> functions in the API to ensure Soup Sieve focuses only on CSS     selectors. <code>comments</code> and <code>icomments</code> will most likely be removed in 2.0. (#130)</li> <li>NEW: Add Python 3.8 support. (#133)</li> <li>FIX: Don't install test files when installing the <code>soupsieve</code> package. (#111)</li> <li>FIX: Improve efficiency of <code>:contains()</code> comparison.</li> <li>FIX: Null characters should translate to the Unicode REPLACEMENT CHARACTER (<code>U+FFFD</code>) according to the     specification. This applies to CSS escaped NULL characters as well. (#124)</li> <li>FIX: Escaped EOF should translate to <code>U+FFFD</code> outside of CSS strings. In a string, they should just be ignored,     but as there is no case where we could resolve such a string and still have a valid selector, string handling     remains the same. (#128)</li> </ul>"},{"location":"about/changelog/#18","title":"1.8","text":"<ul> <li>NEW: Add custom selector support. (#92)(#108)</li> <li>FIX: Small tweak to CSS identifier pattern to ensure it matches the CSS specification exactly. Specifically, you     can't have an identifier of only <code>-</code>. (#107)</li> <li>FIX: CSS string patterns should allow escaping newlines to span strings across multiple lines. (#107)</li> <li>FIX: Newline regular expression for CSS newlines should treat <code>\\r\\n</code> as a single character, especially in cases     such as string escapes: <code>\\\\\\r\\n</code>. (#107)</li> <li>FIX: Allow <code>--</code> as a valid identifier or identifier start. (#107)</li> <li>FIX: Bad CSS syntax now raises a <code>SelectorSyntaxError</code>, which is still currently derived from <code>SyntaxError</code>, but     will most likely be derived from <code>Exception</code> in the future.</li> </ul>"},{"location":"about/changelog/#173","title":"1.7.3","text":"<ul> <li>FIX: Fix regression with tag names in regards to case sensitivity, and ensure there are tests to prevent     breakage in the future.</li> <li>FIX: XHTML should always be case sensitive like XML.</li> </ul>"},{"location":"about/changelog/#172","title":"1.7.2","text":"<ul> <li>FIX: Fix HTML detection <code>type</code> selector.</li> <li>FIX: Fixes for <code>:enabled</code> and <code>:disabled</code>.</li> <li>FIX: Provide a way for Beautiful Soup to parse selectors in a quirks mode to mimic some of the quirks of the old     select method prior to Soup Sieve, but with warnings. This is to help old scripts to not break during the     transitional period with newest Beautiful Soup. In the future, these quirks will raise an exception as Soup Sieve     requires selectors to follow the CSS specification.</li> </ul>"},{"location":"about/changelog/#171","title":"1.7.1","text":"<ul> <li>FIX: Fix issue with <code>:has()</code> selector where a leading combinator can only be provided in the first selector in a     relative selector list.</li> </ul>"},{"location":"about/changelog/#17","title":"1.7","text":"<ul> <li>NEW: Add support for <code>:in-range</code> and <code>:out-of-range</code> selectors. (#60)</li> <li>NEW: Add support for <code>:defined</code> selector. (#76)</li> <li>FIX: Fix pickling issue when compiled selector contains a <code>NullSelector</code> object. (#70)</li> <li>FIX: Better exception messages in the CSS selector parser and fix a position reporting issue that can occur in     some exceptions. (#72, #73)</li> <li>FIX: Don't compare prefixes when evaluating attribute namespaces, compare the actual namespace. (#75)</li> <li>FIX: Split whitespace attribute lists by all whitespace characters, not just space.</li> <li>FIX: <code>:nth-*</code> patterns were converting numbers to base 16 when they should have been converting to base 10.</li> </ul>"},{"location":"about/changelog/#162","title":"1.6.2","text":"<ul> <li>FIX: Fix pattern compile issues on Python &lt; 2.7.4.</li> <li>FIX: Don't use <code>\\d</code> in Unicode <code>Re</code> patterns as they will contain characters outside the range of <code>[0-9]</code>.</li> </ul>"},{"location":"about/changelog/#161","title":"1.6.1","text":"<ul> <li>FIX: Fix warning about not importing <code>Mapping</code> from <code>collections.abc</code>.</li> </ul>"},{"location":"about/changelog/#16","title":"1.6","text":"<ul> <li>NEW: Add <code>closest</code> method to the API that matches closest ancestor.</li> <li>FIX: Add missing <code>select_one</code> reference to module's <code>__all__</code>.</li> </ul>"},{"location":"about/changelog/#15","title":"1.5","text":"<ul> <li>NEW: Add <code>select_one</code> method like Beautiful Soup has.</li> <li>NEW: Add <code>:dir()</code> selector (HTML only).</li> <li>FIX: Fix issues when handling HTML fragments (elements without a <code>BeautifulSoup</code> object as a parent).</li> <li>FIX: Fix internal <code>nth</code> range check.</li> </ul>"},{"location":"about/changelog/#140","title":"1.4.0","text":"<ul> <li>NEW: Throw <code>NotImplementedError</code> for at-rules: <code>@page</code>, etc.</li> <li>NEW: Match nothing for <code>:host</code>, <code>:host()</code>, and <code>:host-context()</code>.</li> <li>NEW: Add support for <code>:read-write</code> and <code>:read-only</code>.</li> <li>NEW: Selector patterns can be annotated with CSS comments.</li> <li>FIX: <code>\\r</code>, <code>\\n</code>, and <code>\\f</code> cannot be escaped with <code>\\</code> in CSS. You must use Unicode escapes.</li> </ul>"},{"location":"about/changelog/#131","title":"1.3.1","text":"<ul> <li>FIX: Fix issue with undefined namespaces.</li> </ul>"},{"location":"about/changelog/#13","title":"1.3","text":"<ul> <li>NEW: Add support for <code>:scope</code>.</li> <li>NEW: <code>:user-invalid</code>, <code>:playing</code>, <code>:paused</code>, and <code>:local-link</code> will not cause a failure, but all will match     nothing as their use cases are not possible in an environment outside a web browser.</li> <li>FIX: Fix <code>[attr~=value]</code> handling of whitespace. According to the spec, if the value contains whitespace, or is     an empty string, it should not match anything.</li> <li>FIX: Precompile internal patterns for pseudo-classes to prevent having to parse them again.</li> </ul>"},{"location":"about/changelog/#121","title":"1.2.1","text":"<ul> <li>FIX: More descriptive exceptions. Exceptions will also now mention position in the pattern that is problematic.</li> <li>FIX: <code>filter</code> ignores <code>NavigableString</code> objects in normal iterables and <code>Tag</code> iterables. Basically, it filters     all Beautiful Soup document parts regardless of iterable type where as it used to only filter out a     <code>NavigableString</code> in a <code>Tag</code> object. This is viewed as fixing an inconsistency.</li> <li>FIX: <code>DEBUG</code> flag has been added to help with debugging CSS selector parsing. This is mainly for development.</li> <li>FIX: If forced to search for language in <code>meta</code> tag, and no language is found, cache that there is no language     in the <code>meta</code> tag to prevent searching again during the current select.</li> <li>FIX: If a non <code>BeautifulSoup</code>/<code>Tag</code> object is given to the API to compare against, raise a <code>TypeError</code>.</li> </ul>"},{"location":"about/changelog/#12","title":"1.2","text":"<ul> <li>NEW: Add Python 2.7 support.</li> <li>NEW: Remove old pre 1.0 deprecations.</li> </ul>"},{"location":"about/changelog/#11","title":"1.1","text":"<ul> <li>NEW: Adds support for <code>[attr!=value]</code> which is equivalent to <code>:not([attr=value])</code>.</li> <li>NEW: Add support for <code>:active</code>, <code>:focus</code>, <code>:hover</code>, <code>:visited</code>, <code>:target</code>, <code>:focus-within</code>, <code>:focus-visible</code>,     <code>:target-within</code>, <code>:current()</code>/<code>:current</code>, <code>:past</code>, and <code>:future</code>, but they will never match as these states don't     exist in the Soup Sieve environment.</li> <li>NEW: Add support for <code>:checked</code>, <code>:enabled</code>, <code>:disabled</code>, <code>:required</code>, <code>:optional</code>, <code>:default</code>, and     <code>:placeholder-shown</code> which will only match in HTML documents as these concepts are not defined in XML.</li> <li>NEW: Add support for <code>:link</code> and <code>:any-link</code>, both of which will target all <code>&lt;a&gt;</code>, <code>&lt;area&gt;</code>, and <code>&lt;link&gt;</code>     elements with an <code>href</code> attribute as all links will be treated as unvisited in Soup Sieve.</li> <li>NEW: Add support for <code>:lang()</code> (CSS4) which works in XML and HTML.</li> <li>NEW: Users must install Beautiful Soup themselves. This requirement is removed in the hopes that Beautiful Soup     may use this in the future.</li> <li>FIX: Attributes in the form <code>prefix:attr</code> can be matched with the form <code>[prefix\\:attr]</code> without specifying a     namespaces if desired.</li> <li>FIX: Fix exception when <code>[type]</code> is used (with no value).</li> </ul>"},{"location":"about/changelog/#102","title":"1.0.2","text":"<ul> <li>FIX: Use proper CSS identifier patterns for tag names, classes, ids, etc. Things like <code>#3</code> or <code>#-3</code> should not     match and should require <code>#\\33</code> or <code>#-\\33</code>.</li> <li>FIX: Do not raise <code>NotImplementedError</code> for supported pseudo classes/elements with bad syntax, instead raise     <code>SyntaxError</code>.</li> </ul>"},{"location":"about/changelog/#101","title":"1.0.1","text":"<ul> <li>FIX: When giving a tag to <code>select</code>, it should only return the children of that tag, never the tag itself.</li> <li>FIX: For informational purposes, raise a <code>NotImplementedError</code> when an unsupported pseudo class is used.</li> </ul>"},{"location":"about/changelog/#10","title":"1.0","text":"<ul> <li>NEW: Official 1.0.0 release.</li> </ul>"},{"location":"about/changelog/#100b2","title":"1.0.0b2","text":"<ul> <li>NEW: Drop document flags. Document type can be detected from the Beautiful Soup object directly.</li> <li>FIX: CSS selectors should be evaluated with CSS whitespace rules.</li> <li>FIX: Processing instructions, CDATA, and declarations should all be ignored in <code>:contains</code> and child     considerations for <code>:empty</code>.</li> <li>FIX: In Beautiful Soup, the document itself is the first tag. Do not match the \"document\" tag by returning false     for any tag that doesn't have a parent.</li> </ul>"},{"location":"about/changelog/#100b1","title":"1.0.0b1","text":"<ul> <li>NEW: Add support for non-standard <code>:contains()</code> selector.</li> <li>FIX: Compare pseudo class names case insensitively when matching unexpected cases.</li> <li>FIX: Don't allow attribute case flags when no attribute value is defined.</li> </ul>"},{"location":"about/changelog/#06","title":"0.6","text":"<ul> <li>NEW: <code>mode</code> attribute is now called <code>flags</code> to allow for other options in the future.</li> <li>FIX: More corner cases for <code>nth</code> selectors.</li> </ul>"},{"location":"about/changelog/#053","title":"0.5.3","text":"<ul> <li>FIX: Previously, all pseudo classes' selector lists were evaluated as one big group, but now each pseudo class's     selector lists are evaluated separately.</li> <li>FIX: CSS selector tokens are not case sensitive.</li> </ul>"},{"location":"about/changelog/#052","title":"0.5.2","text":"<ul> <li>FIX: Add missing <code>s</code> flag to attribute selector for forced case sensitivity of attribute values.</li> <li>FIX: Relax attribute pattern matching to allow non-essential whitespace.</li> <li>FIX: Attribute selector flags themselves are not case sensitive.</li> <li>FIX: <code>type</code> attribute in HTML is handled special. While all other attributes values are case sensitive, <code>type</code>     in HTML is usually treated special and is insensitive. In XML, this is not the case.</li> </ul>"},{"location":"about/changelog/#051","title":"0.5.1","text":"<ul> <li>FIX: Fix namespace check for <code>:nth-of-type</code>.</li> </ul>"},{"location":"about/changelog/#05","title":"0.5","text":"<ul> <li>NEW: Deprecate <code>commentsiter</code> and <code>selectiter</code> in favor of <code>icomments</code> and <code>iselect</code>. Expect removal in version     1.0.</li> </ul>"},{"location":"about/changelog/#04","title":"0.4","text":"<ul> <li>NEW: Initial prerelease.</li> </ul>"},{"location":"about/contributing/","title":"Contributing &amp; Support","text":""},{"location":"about/contributing/#become-a-sponsor","title":"Become a Sponsor","text":"<p>Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal.</p> <p> GitHub Sponsors  PayPal</p>"},{"location":"about/contributing/#bug-reports","title":"Bug Reports","text":"<ol> <li> <p>Please read the documentation and search the issue tracker to try and find the answer to your question     before posting an issue.</p> </li> <li> <p>When creating an issue on the repository, please provide as much information as possible:</p> <ul> <li>Version being used.</li> <li>Operating system.</li> <li>Version of Python.</li> <li>Errors in console.</li> <li>Detailed description of the problem.</li> <li>Examples for reproducing the error.  You can post pictures, but if specific text or code is required to     reproduce the issue, please provide the text in a plain text format for easy copy/paste.</li> </ul> <p>The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue.</p> </li> <li> <p>Be prepared to answer questions and provide additional information if required.  Issues in which the creator refuses     to respond to follow up questions will be marked as stale and closed.</p> </li> </ol>"},{"location":"about/contributing/#reviewing-code","title":"Reviewing Code","text":"<p>Take part in reviewing pull requests and/or reviewing direct commits.  Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.</p>"},{"location":"about/contributing/#answer-questions-in-issues","title":"Answer Questions in Issues","text":"<p>Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for.  Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others.</p>"},{"location":"about/contributing/#pull-requests","title":"Pull Requests","text":"<p>Pull requests are welcome, and a great way to help fix bugs and add new features. If you you are interested in directly contributing to the code, please check out Development for more information on the environment and processes.</p>"},{"location":"about/contributing/#documentation-improvements","title":"Documentation Improvements","text":"<p>A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation.  If you feel it is still lacking, show your appreciation for the tool by helping to improve the documentation. Check out Development for more info on documentation.</p>"},{"location":"about/development/","title":"Development","text":""},{"location":"about/development/#project-layout","title":"Project Layout","text":"<p>There are a number of files for build, test, and continuous integration in the root of the project, but in general, the project is broken up like so.</p> <pre><code>\u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 src\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 dictionary\n\u2502\u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 markdown\n\u251c\u2500\u2500 soupsieve\n\u251c\u2500\u2500 requirements\n\u2514\u2500\u2500 tests\n</code></pre> Directory Description <code>docs/src/dictionary</code> Contains the spell check wordlist(s) for the project. <code>docs/src/markdown</code> Contains the content for the documentation. <code>soupsieve</code> Contains the source code for the project. <code>requirements</code> Contains files with lists of dependencies that are required for the project, and required for continuous integration. <code>tests</code> Contains unit test files."},{"location":"about/development/#coding-standards","title":"Coding Standards","text":"<p>When writing code, the code should roughly conform to PEP8 and PEP257 suggestions along with some other requirements. The project utilizes the astral-sh/ruff linter that helps to ensure code conforms (give or take some of the rules). When in doubt, follow the formatting hints of existing code when adding files or modifying existing files.</p> <p>Usually this can be automated with Tox (assuming it is installed): <code>tox -e lint</code>.</p>"},{"location":"about/development/#building-and-editing-documents","title":"Building and Editing Documents","text":"<p>Documents are in Markdown (with with some additional syntax provided by extensions) and are converted to HTML via Python Markdown. If you would like to build and preview the documentation, you must have these packages installed:</p> <ul> <li>Python-Markdown/markdown: the Markdown parser.</li> <li>mkdocs/mkdocs: the document site generator.</li> <li>squidfunk/mkdocs-material: a material theme for MkDocs.</li> <li>facelessuser/pymdown-extensions: this Python Markdown extension bundle.</li> </ul> <p>It is advised that you just install document dependencies with the following as the above list may not include all document plugins:</p> <pre><code>pip install -r requirements/docs.txt\n</code></pre> <p>In order to build and preview the documents, just run the command below from the root of the project and you should be able to view the documents at <code>localhost:8000</code> in your browser. After that, you should be able to update the documents and have your browser preview update live.</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"about/development/#spell-checking-documents","title":"Spell Checking Documents","text":"<p>Spell checking is performed via facelessuser/pyspelling.</p> <p>During validation we build the docs and spell check various files in the project. Aspell must be installed and in the path.  Currently this project uses one of the more recent versions of Aspell.  It is not expected that everyone will install and run Aspell locally, but it will be run in CI tests for pull requests.</p> <p>In order to perform the spell check locally, it is expected you are setup to build the documents, and that you have Aspell installed in your system path (if needed you can use the <code>--binary</code> option to point to the location of your Aspell binary). It is also expected that you have the <code>en</code> dictionary installed as well. To initiate the spell check, run the following command from the root of the project.</p> <p>You will need to make sure the documents are built first:</p> <pre><code>mkdocs build --clean\n</code></pre> <p>And then run the spell checker.</p> <pre><code>pyspelling\n</code></pre> <p>It should print out the files with the misspelled words if any are found.  If you find it prints words that are not misspelled, you can add them in <code>docs/src/dictionary/en-custom.text</code>.</p>"},{"location":"about/development/#validation-tests","title":"Validation Tests","text":"<p>In order to preserve good code health, a test suite has been put together with pytest (pytest-dev/pytest).  To run these tests, you can use the following command:</p> <pre><code>pytest\n</code></pre>"},{"location":"about/development/#running-validation-with-tox","title":"Running Validation With Tox","text":"<p>Tox (tox-dev/tox) is a great way to run the validation tests, spelling checks, and linting in virtual environments so as not to mess with your current working environment. Tox will use the specified Python version for the given environment and create a virtual environment and install all the needed requirements (minus Aspell).  You could also setup your own virtual environments with the Virtualenv module without Tox, and manually do the same.</p> <p>First, you need to have Tox installed:</p> <pre><code>pip install tox\n</code></pre> <p>By running Tox, it will walk through all the environments and create them (assuming you have all the python versions on your machine) and run the related tests.  See <code>tox.ini</code> to learn more.</p> <pre><code>tox\n</code></pre> <p>If you don't have all the Python versions needed to test all the environments, those entries will fail. To run the tests for specific versions of Python, you specify the environment with <code>-e PXY</code> where <code>X</code> is the major version and <code>Y</code> is the minor version.</p> <pre><code>tox -e py310\n</code></pre> <p>To target linting:</p> <pre><code>tox -e lint\n</code></pre> <p>To select spell checking and document building:</p> <pre><code>tox -e documents\n</code></pre>"},{"location":"about/development/#code-coverage","title":"Code Coverage","text":"<p>When running the validation tests through Tox, it is setup to track code coverage via the Coverage (ned/coveragepy) module.  Coverage is run on each <code>pyxx</code> environment.  If you've made changes to the code, you can clear the old coverage data:</p> <pre><code>coverage erase\n</code></pre> <p>Then run each unit test environment to generate coverage data. All the data from each run is merged together.  HTML is output for each file in <code>.tox/pyXX/tmp</code>.  You can use these to see areas that are not covered/exercised yet with testing.</p> <p>You can checkout <code>tox.ini</code> to see how this is accomplished.</p>"},{"location":"about/development/#code-documentation","title":"Code Documentation","text":"<p>The Soup Sieve module is laid out in the following structure:</p> <pre><code>soupseive\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 __meta__.py\n\u251c\u2500\u2500 css_match.py\n\u251c\u2500\u2500 css_parser.py\n\u251c\u2500\u2500 css_types.py\n\u2514\u2500\u2500 util.py\n</code></pre> File Description <code>__init__.py</code> Contains the API for the user. <code>__meta__.py</code> Contains package meta data like version. <code>css_match.py</code> Contains the logic for matching tags with a CSS selector. <code>css_parser.py</code> Contains the CSS selector parser. <code>css_types.py</code> Contains the CSS types for the compiled CSS patterns. <code>util.py</code> Contains miscellaneous helper functions, classes, and constants."},{"location":"about/development/#compiled-css-selector-structure","title":"Compiled CSS Selector Structure","text":"<p>When a CSS selector string is given to Soup Sieve, it is run through the <code>CSSParser</code> class.  <code>CSSParser</code> will return a <code>SelectorList</code> class. This class is sent to the <code>SoupSieve</code> class as a parameter along with things like <code>namespace</code> and <code>flags</code>. One of the most important things to understand when contributing is the structure of the <code>SelectorList</code> class.</p> <p>A <code>SelectorList</code> represents a list of compound selectors.  So if you had the selector <code>div &gt; p</code>, you would get a <code>SelectorList</code> object containing one <code>Selector</code> object. If you had <code>div, p</code>, you would get a <code>SelectorList</code> with two <code>Selector</code> objects as this is a selector list of two compound selectors.</p> <p>A compound selector gets parsed into pieces. Each part of a specific compound selector is usually assigned to an attribute in a single <code>Selector</code> object. The attributes of the <code>Selector</code> object may be as simple as a boolean or a string, but they can also be a tuple of more <code>SelectorList</code> objects. In the case of <code>*:not(p, div)</code>, <code>*</code> will be a <code>SelectorList</code> with one <code>Selector</code>. The <code>:not(p, div)</code> selector list will be a tuple containing one <code>SelectorList</code> of two <code>Selectors</code> (one for <code>p</code> and one for <code>div</code>) under the <code>selectors</code> attribute of the <code>*</code> <code>Selector</code>.</p> <p>In short, <code>Selectors</code> are always contained within a <code>SelectorList</code>, and a compound selector is a single <code>Selector</code> object that may chain other <code>SelectorLists</code> objects depending on the complexity of the compound selector. If you provide a selector list, then you will get multiple <code>Selector</code> objects (one for each compound selector in the list) which in turn may chain other <code>Selector</code> objects.</p> <p>To view the selector list in in a compiled object for debugging purposes, one can access it via <code>SoupSieve.selectors</code>, though it is recommended to pretty print them:</p> <pre><code>&gt;&gt;&gt; import soupsieve as sv\n&gt;&gt;&gt; sv.compile('this &gt; that.class[name=value]').selectors.pretty()\nSelectorList(\n    selectors=(\n        Selector(\n            tag=SelectorTag(\n                name='that',\n                prefix=None),\n            ids=(),\n            classes=(\n                'class',\n                ),\n            attributes=(\n                SelectorAttribute(\n                    attribute='name',\n                    prefix='',\n                    pattern=re.compile(\n                        '^value$'),\n                    xml_type_pattern=None),\n                ),\n            nth=(),\n            selectors=(),\n            relation=SelectorList(\n                selectors=(\n                    Selector(\n                        tag=SelectorTag(\n                            name='this',\n                            prefix=None),\n                        ids=(),\n                        classes=(),\n                        attributes=(),\n                        nth=(),\n                        selectors=(),\n                        relation=SelectorList(\n                            selectors=(),\n                            is_not=False,\n                            is_html=False),\n                        rel_type='&gt;',\n                        contains=(),\n                        lang=(),\n                        flags=0),\n                    ),\n                is_not=False,\n                is_html=False),\n            rel_type=None,\n            contains=(),\n            lang=(),\n            flags=0),\n        ),\n    is_not=False,\n    is_html=False)\n</code></pre>"},{"location":"about/development/#selectorlist","title":"<code>SelectorList</code>","text":"<pre><code>class SelectorList:\n    \"\"\"Selector list.\"\"\"\n\n    def __init__(self, selectors=tuple(), is_not=False):\n        \"\"\"Initialize.\"\"\"\n</code></pre> Attribute Description <code>selectors</code> A list of <code>Selector</code> objects. <code>is_not</code> The selectors in the selector list are from a <code>:not()</code>. <code>is_html</code> The selectors in the selector list are HTML specific."},{"location":"about/development/#selector","title":"<code>Selector</code>","text":"<pre><code>class Selector:\n    \"\"\"Selector.\"\"\"\n\n    def __init__(\n        self, tag, ids, classes, attributes, nth, selectors, relation,\n        rel_type, contains, lang, flags\n    ):\n        \"\"\"Initialize.\"\"\"\n</code></pre> Flags Description <code>SEL_EMPTY</code> The current compound selector contained an <code>:empty</code> pseudo-class. <code>SEL_ROOT</code> The current compound selector contains <code>:root</code>. <code>SEL_DEFAULT</code> The compound selector has a <code>:default</code> pattern  and requires additional logic to determine if it is the first <code>submit</code> button in a form. <code>SEL_INDETERMINATE</code> The compound selector has a <code>:indeterminate</code> pattern and requires additional logic to ensure a <code>radio</code> element and all of the <code>radio</code> elements with the same <code>name</code> under a form are not set. Attribute Description <code>tag</code> Contains a single <code>SelectorTag</code> object, or <code>None</code>. <code>id</code> Contains a tuple of ids to match. Usually if multiple conflicting ids are present, it simply won't match a tag, but it allows multiple to handle the syntax <code>tag#1#2</code> even if it is invalid. <code>classes</code> Contains a tuple of class names to match. <code>attributes</code> Contains a tuple of attributes. Each attribute is represented as a <code>SelectorAttribute</code>. <code>nth</code> Contains a tuple containing <code>nth</code> selectors, each selector being represented as a <code>SelectorNth</code>. <code>nth</code> selectors contain things like <code>:first-child</code>, <code>:only-child</code>, <code>:nth-child()</code>, <code>:nth-of-type()</code>, etc. <code>selectors</code> Contains a tuple of <code>SelectorList</code> objects for each pseudo-class selector  part of the compound selector: <code>:is()</code>, <code>:not()</code>, <code>:has()</code>, etc. <code>relation</code> This will contain a <code>SelectorList</code> object with one <code>Selector</code> object, which could in turn chain an additional relation depending on the complexity of the compound selector.  For instance, <code>div &gt; p + a</code> would be a <code>Selector</code> for <code>a</code> that contains a <code>relation</code> for <code>p</code> (another <code>SelectorList</code> object) which also contains a relation of <code>div</code>.  When matching, we would match that the tag is <code>a</code>, and then walk its relation chain verifying that they all match. In this case, the relation chain would be a direct, previous sibling of <code>p</code>, which has a direct parent of <code>div</code>. A <code>:has()</code> pseudo-class would walk this in the opposite order. <code>div:has(&gt; p + a)</code> would verify <code>div</code>, and then check for a child of <code>p</code> with a sibling of <code>a</code>. <code>rel_type</code> <code>rel_type</code> is attached to relational selectors. In the case of <code>div &gt; p + a</code>, the relational selectors of <code>div</code> and <code>p</code> would get a relational type of <code>&gt;</code> and <code>+</code> respectively. <code>:has()</code> relational <code>rel_type</code> are preceded with <code>:</code> to signify a forward looking relation. <code>contains</code> Contains a tuple of <code>SelectorContains</code> objects. Each object contains the list of text to match an element's content against. <code>lang</code> Contains a tuple of <code>SelectorLang</code> objects. <code>flags</code> Selector flags that used to signal a type of selector is present."},{"location":"about/development/#selectornull","title":"<code>SelectorNull</code>","text":"<pre><code>class SelectorNull:\n    \"\"\"Null Selector.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize.\"\"\"\n</code></pre> <p>The null selector is like <code>Selector</code>, but it matches nothing.</p>"},{"location":"about/development/#selectortag","title":"<code>SelectorTag</code>","text":"<pre><code>class SelectorTag:\n    \"\"\"Selector tag.\"\"\"\n\n    def __init__(self, name, prefix):\n        \"\"\"Initialize.\"\"\"\n</code></pre> Attribute Description <code>name</code> <code>name</code> contains the tag name to match. <code>prefix</code> <code>prefix</code> contains the namespace prefix to match. <code>prefix</code> can also be <code>None</code>."},{"location":"about/development/#selectorattribute","title":"<code>SelectorAttribute</code>","text":"<pre><code>class SelectorAttribute:\n    \"\"\"Selector attribute rule.\"\"\"\n\n    def __init__(self, attribute, prefix, pattern, xml_type_pattern):\n        \"\"\"Initialize.\"\"\"\n</code></pre> Attribute Description <code>attribute</code> Contains the attribute name to match. <code>prefix</code> Contains the attribute namespace prefix to match if any. <code>pattern</code> Contains a <code>re</code> regular expression object that matches the desired attribute value. <code>xml_type_pattern</code> As the default <code>type</code> pattern is case insensitive, when the attribute value is <code>type</code> and a case sensitivity has not been explicitly defined, a secondary case sensitive <code>type</code> pattern is compiled for use with XML documents when detected."},{"location":"about/development/#selectorcontains","title":"<code>SelectorContains</code>","text":"<pre><code>class SelectorContains:\n    \"\"\"Selector contains rule.\"\"\"\n\n    def __init__(self, text):\n        \"\"\"Initialize.\"\"\"\n</code></pre> Attribute Description <code>text</code> A tuple of acceptable text that that an element should match. An element only needs to match at least one."},{"location":"about/development/#selectornth","title":"<code>SelectorNth</code>","text":"<pre><code>class SelectorNth:\n    \"\"\"Selector nth type.\"\"\"\n\n    def __init__(self, a, n, b, of_type, last, selectors):\n        \"\"\"Initialize.\"\"\"\n</code></pre> Attribute Description <code>a</code> The <code>a</code> value in the formula <code>an+b</code> specifying an index. <code>n</code> <code>True</code> if the provided formula has included a literal <code>n</code> which signifies the formula is not a static index. <code>b</code> The <code>b</code> value in the formula <code>an+b</code>. <code>type</code> <code>True</code> if the <code>nth</code> pseudo-class is an <code>*-of-type</code> variant. <code>last</code> <code>True</code> if the <code>nth</code> pseudo-class is a <code>*last*</code> variant. <code>selectors</code> A <code>SelectorList</code> object representing the <code>of S</code> portion of <code>:nth-chld(an+b [of S]?)</code>."},{"location":"about/development/#selectorlang","title":"<code>SelectorLang</code>","text":"<pre><code>class SelectorLang:\n    \"\"\"Selector language rules.\"\"\"\n\n    def __init__(self, languages):\n        \"\"\"Initialize.\"\"\"\n</code></pre> Attribute Description <code>languages</code> A list of regular expression objects that match a language pattern."},{"location":"about/license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2018 - 2024 Isaac Muse isaacmuse@gmail.com</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/security/","title":"Security Vulnerabilities","text":"<p>Our policy for security related issues is to fix related issues within our power on the most recent major release.</p>"},{"location":"about/security/#versioning","title":"Versioning","text":"<p>Versioning follows PEP440: <code>major.minior.patch</code>.</p> Versions Description Major This reserved for releases that introduce breaking features. Minor This reserved for releases that introduce new functionality. Patch This is reserved for releases that only include bug fixes. <p>Example</p> <pre><code>8.0\n8.1\n8.1.3\n</code></pre>"},{"location":"about/security/#create-security-vulnerability-report","title":"Create Security Vulnerability Report","text":"<p>If you have found a security vulnerability, you can create a draft \"security advisory\" on the GitHub repository, instructions here. Such advisories are kept private as the issue is explored.</p>"},{"location":"about/security/#security-vulnerability-workflow","title":"Security Vulnerability Workflow","text":"<p>We will strive to acknowledge the report in about two business days.</p> <p>Reports will be kept private until the issue is properly understood.</p> <p>If the report is accepted we will notify Tidelift (who we've partnered with), request a CVE from GitHub, and work with the reporter to find a resolution. Work will be done privately, and the final commit will not mention the security issue.</p> <p>The fix, announcement, and release will be negotiated with the reporter.</p> <p>Afterwards, a release will be made and the vulnerability will be made public as close to each other as possible.</p>"},{"location":"selectors/","title":"General Details","text":""},{"location":"selectors/#implementation-specifics","title":"Implementation Specifics","text":"<p>The CSS selectors are based off of the CSS specification and includes not only stable selectors, but may also include selectors currently under development from the draft specifications. Primarily support has been added for selectors that were feasible to implement and most likely to get practical use. In addition to the selectors in the specification, Soup Sieve also supports a couple non-standard selectors.</p> <p>Soup Sieve aims to allow users to target XML/HTML elements with CSS selectors. It implements many pseudo classes, but it does not currently implement any pseudo elements and has no plans to do so. Soup Sieve also will not match anything for pseudo classes that are only relevant in a live, browser environment, but it will gracefully handle them if they've been implemented; such pseudo classes are non-applicable in the Beautiful Soup environment and are noted in Non-Applicable Pseudo Classes.</p> <p>When speaking about namespaces, they only apply to XML, XHTML, or when dealing with recognized foreign tags in HTML5. Currently, Beautiful Soup's <code>html5lib</code> parser is the only parser that will return the appropriate namespaces for a HTML5 document. If you are using XHTML, you have to use the Beautiful Soup's <code>lxml-xml</code> parser (or <code>xml</code> for short) to get the appropriate namespaces in an XHTML document. In addition to using the correct parser, you must provide a dictionary of namespaces to Soup Sieve in order to use namespace selectors. See the documentation on namespaces to learn more.</p> <p>While an effort is made to mimic CSS selector behavior, there may be some differences or quirks, please report issues if any are found.</p>"},{"location":"selectors/#selector-context-key","title":"Selector Context Key","text":"Symbol Name Description HTML  Some selectors are very specific to HTML and either have no meaningful representation in XML, or such functionality has not been implemented. Selectors that are HTML only will be noted with , and will match nothing if used in XML.  Custom  Soup Sieve has implemented a couple non-standard selectors. These can contain useful selectors that were rejected from the official CSS specifications, selectors implemented by other systems such as JQuery, or even selectors specifically created for Soup Sieve. If a selector is considered non standard, it will be marked with .  Experimental  All selectors that are from the current working draft of CSS4 are considered experimental and are marked with . Additionally, if there are other immature selectors, they may be marked as experimental as well. Experimental may mean we are not entirely sure if our implementation is correct, that things may still be in flux as they are part of a working draft, or even both.  If at anytime a working draft drops a selector from the current draft, it will most likely also be removed here, most likely with a deprecation path, except where there may be a conflict that requires a less graceful transition. One exception is in the rare case that the selector is found to be far too useful despite being rejected. In these cases, we may adopt them as \"custom\" selectors.  <p>Additional Reading</p> <p>If usage of a selector is not clear in this documentation, you can find more information by reading these specification documents:</p> <p>CSS Level 3 Specification : Contains the latest official document outlying official behaviors of CSS selectors.</p> <p>CSS Level 4 Working Draft : Contains the latest published working draft of the CSS level 4 selectors which outlines the experimental new selectors and experimental behavioral changes.</p> <p>HTML5 : The HTML 5.0 specification document. Defines the semantics regarding HTML.</p> <p>HTML Living Standard : The HTML Living Standard document. Defines semantics regarding HTML.</p>"},{"location":"selectors/#selector-terminology","title":"Selector Terminology","text":"<p>Certain terminology is used throughout this document when describing selectors. In order to fully understand the syntax a selector may implement, it is important to understand a couple of key terms.</p>"},{"location":"selectors/#selector","title":"Selector","text":"<p>Selector is used to describe any selector whether it is a simple, compound, or complex selector.</p>"},{"location":"selectors/#simple-selector","title":"Simple Selector","text":"<p>A simple selector represents a single condition on an element. It can be a type selector, universal selector, ID selector, class selector, attribute selector, or pseudo class selector.</p>"},{"location":"selectors/#compound-selector","title":"Compound Selector","text":"<p>A compound selector is a sequence of simple selectors. They do not contain any combinators. If a universal or type selector is used, they must come first, and only one instance of either a universal or type selector can be used, both cannot be used at the same time.</p>"},{"location":"selectors/#complex-selector","title":"Complex Selector","text":"<p>A complex selector consists of multiple simple or compound selectors joined with combinators.</p>"},{"location":"selectors/#selector-list","title":"Selector List","text":"<p>A selector list is a list of selectors joined with a comma (<code>,</code>). A selector list is used to specify that a match is valid if any of the selectors in a list matches.</p>"},{"location":"selectors/basic/","title":"Basic Selectors","text":"<p>Syntax and notation for basic selectors.</p>"},{"location":"selectors/basic/#escapes","title":"Escapes","text":"<p>Soup Sieve selectors support using CSS escapes. So if you need provide Unicode, or non-standard characters, you can use CSS style escapes.</p> <p>Escapes can be specified with a backslash followed by 1 - 6 hexadecimal digits: <code>\\20AC</code>, <code>\\0020AC</code>, etc. If you need to terminate an escape to avoid it accumulating unintended hexadecimal characters, you can use a space: <code>\\0020AC dont-escape-me</code>. You can also escape any non-hexadecimal character, and it will be treated as that character: <code>\\+</code> \u2192 <code>+</code>. The one exception is that you cannot escape the form feed, newline, or carriage return.</p> <p>You can always use Soup Sieve's escape command to escape identifiers as well.</p>"},{"location":"selectors/basic/#type-selectors","title":"Type Selectors","text":"<p>Type selectors match elements by node name.</p> <p>If a default namespace is defined in the namespace dictionary, and no namespace is explicitly defined, it will be assumed that the element must be in the default namespace.</p> SyntaxUsage <pre><code>element\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n...   &lt;div&gt;Here is some text.&lt;/div&gt;\n...   &lt;div&gt;Here is some more text.&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('div'))\n[&lt;div&gt;Here is some text.&lt;/div&gt;, &lt;div&gt;Here is some more text.&lt;/div&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors</p>"},{"location":"selectors/basic/#universal-selectors","title":"Universal Selectors","text":"<p>The Universal selector (<code>*</code>) matches elements of any type.</p> SyntaxUsage <pre><code>*\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n...    &lt;p&gt;Here is some text.&lt;/p&gt;\n...    &lt;div&gt;Here is some more text.&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('*'))\n[&lt;html&gt;&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;\n   &lt;div&gt;Here is some text.&lt;/div&gt;\n   &lt;div&gt;Here is some more text.&lt;/div&gt;\n\n\n&lt;/body&gt;&lt;/html&gt;, &lt;head&gt;&lt;/head&gt;, &lt;body&gt;\n   &lt;div&gt;Here is some text.&lt;/div&gt;\n   &lt;div&gt;Here is some more text.&lt;/div&gt;\n\n\n&lt;/body&gt;, &lt;div&gt;Here is some text.&lt;/div&gt;, &lt;div&gt;Here is some more text.&lt;/div&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors</p>"},{"location":"selectors/basic/#id-selectors","title":"ID Selectors","text":"<p>The ID selector matches an element based on its <code>id</code> attribute. The ID must match exactly.</p> SyntaxUsage <pre><code>#id\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n...    &lt;div id=\"some-id\"&gt;Here is some text.&lt;/div&gt;\n...    &lt;div&gt;Here is some more text.&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('#some-id'))\n[&lt;div id=\"some-id\"&gt;Here is some text.&lt;/div&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors</p> <p>XML Support</p> <p>While the use of the <code>id</code> attribute (in the context of CSS) is a very HTML centric idea, it is supported for XML as well because Beautiful Soup supported it before Soup Sieve's existence.</p>"},{"location":"selectors/basic/#class-selectors","title":"Class Selectors","text":"<p>The class selector matches an element based on the values contained in the <code>class</code> attribute. The <code>class</code> attribute is treated as a whitespace separated list, where each item is a class.</p> SyntaxUsage <pre><code>.class\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n...    &lt;div class=\"some-class\"&gt;Here is some text.&lt;/div&gt;\n...    &lt;div&gt;Here is some more text.&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('.some-class'))\n[&lt;div class=\"some-class\"&gt;Here is some text.&lt;/div&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors</p> <p>XML Support</p> <p>While the use of the <code>class</code> attribute (in the context of CSS) is a very HTML centric idea, it is supported for XML as well because Beautiful Soup supported it before Soup Sieve's existence.</p>"},{"location":"selectors/basic/#attribute-selectors","title":"Attribute Selectors","text":"<p>The attribute selector matches an element based on its attributes. When specifying a value of an attribute, if it contains whitespace or special characters, you should quote them with either single or double quotes.</p> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors</p> <code>[attribute]</code> <p>Represents elements with an attribute named attribute.</p> SyntaxUsage <pre><code>[attr]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;ul&gt;\n...   &lt;li&gt;&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;&lt;/li&gt;\n... &lt;/ul&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('[href]'))\n[&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;, &lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;, &lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;, &lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;]\n</code></pre> <code>[attribute=value]</code> <p>Represents elements with an attribute named attribute that also has a value of value.</p> SyntaxUsage <pre><code>[attr=value]\n[attr=\"value\"]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;ul&gt;\n...   &lt;li&gt;&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;&lt;/li&gt;\n... &lt;/ul&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('[href=\"#internal\"]'))\n[&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;]\n</code></pre> <code>[attribute~=value]</code> <p>Represents elements with an attribute named attribute whose value is a space separated list which contains     value.</p> SyntaxUsage <pre><code>[attr~=value]\n[attr~=\"value\"]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;ul&gt;\n...   &lt;li&gt;&lt;a href=\"#internal\" class=\"class1 class2 class3\"&gt;Internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;&lt;/li&gt;\n... &lt;/ul&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('[class~=class2]'))\n[&lt;a class=\"class1 class2 class3\" href=\"#internal\"&gt;Internal link&lt;/a&gt;]\n</code></pre> <code>[attribute|=value]</code> <p>Represents elements with an attribute named attribute whose value is a dash separated list that starts with     value.</p> SyntaxUsage <pre><code>[attr|=value]\n[attr|=\"value\"]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;div lang=\"en\"&gt;Some text&lt;/div&gt;\n... &lt;div lang=\"en-US\"&gt;Some more text&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('div[lang|=\"en\"]'))\n[&lt;div lang=\"en\"&gt;Some text&lt;/div&gt;, &lt;div lang=\"en-US\"&gt;Some more text&lt;/div&gt;]\n</code></pre> <code>[attribute^=value]</code> <p>Represents elements with an attribute named attribute whose value starts with value.</p> SyntaxUsage <pre><code>[attr^=value]\n[attr^=\"value\"]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;ul&gt;\n...   &lt;li&gt;&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;&lt;/li&gt;\n... &lt;/ul&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('[href^=http]'))\n[&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;, &lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;]\n</code></pre> <code>[attribute$=value]</code> <p>Represents elements with an attribute named attribute whose value ends with value.</p> SyntaxUsage <pre><code>[attr$=value]\n[attr$=\"value\"]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;ul&gt;\n...   &lt;li&gt;&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;&lt;/li&gt;\n... &lt;/ul&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('[href$=org]'))\n[&lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;]\n</code></pre> <code>[attribute*=value]</code> <p>Represents elements with an attribute named attribute whose value containing the substring value.</p> SyntaxUsage <pre><code>[attr*=value]\n[attr*=\"value\"]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;ul&gt;\n...   &lt;li&gt;&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;&lt;/li&gt;\n... &lt;/ul&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('[href*=\"example\"]'))\n[&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;, &lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;]\n</code></pre> <code>[attribute!=value]</code> <p>Equivalent to <code>:not([attribute=value])</code>.</p> SyntaxUsage <pre><code>[attr!=value]\n[attr!=\"value\"]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;ul&gt;\n...   &lt;li&gt;&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;&lt;/li&gt;\n... &lt;/ul&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('a[href!=\"#internal\"]'))\n[&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;, &lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;, &lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;]\n</code></pre> <code>[attribute operator value i]</code> <p>Represents elements with an attribute named attribute and whose value, when the operator is applied, matches     value without case sensitivity. In general, attribute comparison is insensitive in normal HTML, but not XML.     <code>i</code> is most useful in XML documents.</p> SyntaxUsage <pre><code>[attr=value i]\n[attr=\"value\" i]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;ul&gt;\n...   &lt;li&gt;&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;&lt;/li&gt;\n... &lt;/ul&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('[href=\"#INTERNAL\" i]'))\n[&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;]\n</code></pre> <code>[attribute operator value s]</code> <p>Represents elements with an attribute named attribute and whose value, when the operator is applied, matches     value with case sensitivity.</p> SyntaxUsage <pre><code>[attr=value s]\n[attr=\"value\" s]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;ul&gt;\n...   &lt;li&gt;&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.com\"&gt;Example link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"#InSensitive\"&gt;Insensitive internal link&lt;/a&gt;&lt;/li&gt;\n...   &lt;li&gt;&lt;a href=\"http://example.org\"&gt;Example org link&lt;/a&gt;&lt;/li&gt;\n... &lt;/ul&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('[href=\"#INTERNAL\" s]'))\n[]\n&gt;&gt;&gt; print(soup.select('[href=\"#internal\" s]'))\n[&lt;a href=\"#internal\"&gt;Internal link&lt;/a&gt;]\n</code></pre>"},{"location":"selectors/basic/#namespace-selectors","title":"Namespace Selectors","text":"<p>Namespace selectors are used in conjunction with type and universal selectors as well as attribute names in attribute selectors. They are specified by declaring the namespace and the selector separated with <code>|</code>: <code>namespace|selector</code>. <code>namespace</code>, in this context, is the prefix defined via the namespace dictionary. The prefix defined for the CSS selector does not need to match the prefix name in the document as it is the namespace associated with the prefix that is compared, not the prefix itself.</p> <p>The universal selector (<code>*</code>) can be used to represent any namespace just as it can with types.</p> <p>By default, type selectors without a namespace selector will match any element whose type matches, regardless of namespace. But if a CSS default namespace is declared (one with an empty key: <code>{\"\": \"http://www.w3.org/1999/xhtml\"}</code>), all type selectors will assume the default namespace unless an explicit namespace selector is specified. For example, if the default name was defined to be <code>http://www.w3.org/1999/xhtml</code>, the selector <code>a</code> would only match <code>a</code> tags that are within the <code>http://www.w3.org/1999/xhtml</code> namespace. The one exception is within pseudo classes (<code>:not()</code>, <code>:has()</code>, etc.) as namespaces are not considered within pseudo classes unless one is explicitly specified.</p> <p>If the namespace is omitted (<code>|element</code>), any element without a namespace will be matched. In HTML documents that support namespaces (XHTML and HTML5), HTML elements are counted as part of the <code>http://www.w3.org/1999/xhtml</code> namespace, but attributes usually do not have a namespace unless one is explicitly defined in the markup.</p> <p>Namespaces can be used with attribute selectors as well except that when <code>[|attribute</code>] is used, it is equivalent to <code>[attribute]</code>.</p> SyntaxUsage <pre><code>ns|element\nns|*\n*|*\n*|element\n|element\n[ns|attr]\n[*|attr]\n[|attr]\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;h1&gt;SVG Example&lt;/h1&gt;\n... &lt;p&gt;&lt;a href=\"http://facelessuser.github.io/soupsieve/\"&gt;Soup Sieve Docs&lt;/a&gt;&lt;/p&gt;\n... \n... &lt;svg viewBox=\"0 0 160 40\" xmlns=\"http://www.w3.org/2000/svg\"&gt;\n...   &lt;a xlink:href=\"https://developer.mozilla.org/\"&gt;&lt;text x=\"10\" y=\"25\"&gt;MDN Web Docs&lt;/text&gt;&lt;/a&gt;\n... &lt;/svg&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('svg|a', namespaces={'svg': 'http://www.w3.org/2000/svg'}))\n[&lt;a xlink:href=\"https://developer.mozilla.org/\"&gt;&lt;text x=\"10\" y=\"25\"&gt;MDN Web Docs&lt;/text&gt;&lt;/a&gt;]  \n&gt;&gt;&gt; print(soup.select('a', namespaces={'svg': 'http://www.w3.org/2000/svg'}))\n[&lt;a href=\"http://facelessuser.github.io/soupsieve/\"&gt;Soup Sieve Docs&lt;/a&gt;, &lt;a xlink:href=\"https://developer.mozilla.org/\"&gt;&lt;text x=\"10\" y=\"25\"&gt;MDN Web Docs&lt;/text&gt;&lt;/a&gt;]\n&gt;&gt;&gt; print(soup.select('a', namespaces={'': 'http://www.w3.org/1999/xhtml', 'svg': 'http://www.w3.org/2000/svg'}))\n[&lt;a href=\"http://facelessuser.github.io/soupsieve/\"&gt;Soup Sieve Docs&lt;/a&gt;]\n&gt;&gt;&gt; print(soup.select('[xlink|href]', namespaces={'xlink': 'http://www.w3.org/1999/xlink'}))\n[&lt;a xlink:href=\"https://developer.mozilla.org/\"&gt;&lt;text x=\"10\" y=\"25\"&gt;MDN Web Docs&lt;/text&gt;&lt;/a&gt;]\n&gt;&gt;&gt; print(soup.select('[|href]', namespaces={'xlink': 'http://www.w3.org/1999/xlink'}))\n[&lt;a href=\"http://facelessuser.github.io/soupsieve/\"&gt;Soup Sieve Docs&lt;/a&gt;]\n</code></pre>"},{"location":"selectors/combinators/","title":"Combinators and Selector Lists","text":"<p>CSS employs a number of tokens in order to represent lists or to provide relational context between two selectors.</p>"},{"location":"selectors/combinators/#selector-lists","title":"Selector Lists","text":"<p>Selector lists use the comma (<code>,</code>) to join multiple selectors in a list. When presented with a selector list, any selector in the list that matches an element will return that element.</p> SyntaxUsage <pre><code>element1, element2\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;h1&gt;Title&lt;/h1&gt;\n... &lt;p&gt;Paragraph&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('h1, p'))\n[&lt;h1&gt;Title&lt;/h1&gt;, &lt;p&gt;Paragraph&lt;/p&gt;]\n</code></pre>"},{"location":"selectors/combinators/#descendant-combinator","title":"Descendant Combinator","text":"<p>Descendant combinators combine two selectors with whitespace () in order to signify that the second element is matched if it has an ancestor that matches the first element.</p> SyntaxUsage <pre><code>parent descendant\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;div&gt;&lt;p&gt;Paragraph 1&lt;/p&gt;&lt;/div&gt;\n... &lt;div&gt;&lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('body p'))\n[&lt;p&gt;Paragraph 1&lt;/p&gt;, &lt;p&gt;Paragraph 2&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator</p>"},{"location":"selectors/combinators/#child-combinator","title":"Child combinator","text":"<p>Child combinators combine two selectors with <code>&gt;</code> in order to signify that the second element is matched if it has a parent that matches the first element.</p> SyntaxUsage <pre><code>parent &gt; child\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;div&gt;&lt;p&gt;Paragraph 1&lt;/p&gt;&lt;/div&gt;\n... &lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('div &gt; p'))\n[&lt;p&gt;Paragraph 1&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/Child_combinator</p>"},{"location":"selectors/combinators/#general-sibling-combinator","title":"General sibling combinator","text":"<p>General sibling combinators combine two selectors with <code>~</code> in order to signify that the second element is matched if it has a sibling that precedes it that matches the first element.</p> SyntaxUsage <pre><code>prevsibling ~ sibling\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;h1&gt;Title&lt;/h1&gt;\n... &lt;p&gt;Paragraph 1&lt;/p&gt;\n... &lt;p&gt;Paragraph 2&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('h1 ~ p'))\n[&lt;p&gt;Paragraph 1&lt;/p&gt;, &lt;p&gt;Paragraph 2&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_combinator</p>"},{"location":"selectors/combinators/#adjacent-sibling-combinator","title":"Adjacent sibling combinator","text":"<p>Adjacent sibling combinators combine two selectors with <code>+</code> in order to signify that the second element is matched if it has an adjacent sibling that precedes it that matches the first element.</p> SyntaxUsage <pre><code>prevsibling + nextsibling\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;h1&gt;Title&lt;/h1&gt;\n... &lt;p&gt;Paragraph 1&lt;/p&gt;\n... &lt;p&gt;Paragraph 2&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('h1 + p'))\n[&lt;p&gt;Paragraph 1&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_combinator</p>"},{"location":"selectors/pseudo-classes/","title":"Pseudo-Classes","text":""},{"location":"selectors/pseudo-classes/#overview","title":"Overview","text":"<p>These are pseudo classes that are either fully or partially supported. Partial support is usually due to limitations of not being in a live, browser environment. Pseudo classes that cannot be implemented are found under Non-Applicable Pseudo Classes. Any selectors that are not found here or under the non-applicable either are under consideration, have not yet been evaluated, or are too new and viewed as a risk to implement as they might not stick around.</p>"},{"location":"selectors/pseudo-classes/#:any-link","title":"<code>:any-link</code>","text":"<p>Selects every <code>&lt;a&gt;</code>, or <code>&lt;area&gt;</code> element that has an <code>href</code> attribute, independent of whether it has been visited.</p> SyntaxUsage <pre><code>:any-link\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p&gt;A link to &lt;a href=\"http://example.com\"&gt;click&lt;/a&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':any-link'))\n[&lt;a href=\"http://example.com\"&gt;click&lt;/a&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:any-link</p> <p>New in 2.2</p> <p>The CSS specification recently updated to not include <code>&lt;link&gt;</code> in the definition; therefore, Soup Sieve has removed it as well.</p>"},{"location":"selectors/pseudo-classes/#:checked","title":"<code>:checked</code>","text":"<p>Selects any <code>&lt;input type=\"radio\"/&gt;</code>, <code>&lt;input type=\"checkbox\"/&gt;</code>, or <code>&lt;option&gt;</code> element (in a <code>&lt;select&gt;</code> element) that is checked or toggled to an on state.</p> SyntaxUsage <pre><code>:checked\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... \n... &lt;div&gt;\n...   &lt;input type=\"radio\" name=\"my-input\" id=\"yes\" checked&gt;\n...   &lt;label for=\"yes\"&gt;Yes&lt;/label&gt;\n... \n...   &lt;input type=\"radio\" name=\"my-input\" id=\"no\"&gt;\n...   &lt;label for=\"no\"&gt;No&lt;/label&gt;\n... &lt;/div&gt;\n... \n... &lt;select name=\"my-select\" id=\"fruit\"&gt;\n...   &lt;option id=\"1\" value=\"opt1\"&gt;Apples&lt;/option&gt;\n...   &lt;option id=\"2\" value=\"opt2\" selected&gt;Grapes&lt;/option&gt;\n...   &lt;option id=\"3\" value=\"opt3\"&gt;Pears&lt;/option&gt;\n... &lt;/select&gt;\n... \n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':checked'))\n[&lt;input checked=\"\" id=\"yes\" name=\"my-input\" type=\"radio\"/&gt;, &lt;option id=\"2\" selected=\"\" value=\"opt2\"&gt;Grapes&lt;/option&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:checked</p>"},{"location":"selectors/pseudo-classes/#:default","title":"<code>:default</code>","text":"<p>Selects any form element that is the default among a group of related elements, including: <code>&lt;button&gt;</code>, <code>&lt;input type=\"checkbox\"&gt;</code>, <code>&lt;input type=\"radio\"&gt;</code>, <code>&lt;option&gt;</code> elements.</p> SyntaxUsage <pre><code>:default\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;form&gt;\n... \n... &lt;input type=\"radio\" name=\"season\" id=\"spring\"&gt;\n... &lt;label for=\"spring\"&gt;Spring&lt;/label&gt;\n... \n... &lt;input type=\"radio\" name=\"season\" id=\"summer\" checked&gt;\n... &lt;label for=\"summer\"&gt;Summer&lt;/label&gt;\n... \n... &lt;input type=\"radio\" name=\"season\" id=\"fall\"&gt;\n... &lt;label for=\"fall\"&gt;Fall&lt;/label&gt;\n... \n... &lt;input type=\"radio\" name=\"season\" id=\"winter\"&gt;\n... &lt;label for=\"winter\"&gt;Winter&lt;/label&gt;\n... \n... &lt;select id=\"pet-select\"&gt;\n...     &lt;option value=\"\"&gt;--Please choose an option--&lt;/option&gt;\n...     &lt;option id=\"dog\" value=\"dog\"&gt;Dog&lt;/option&gt;\n...     &lt;option id=\"cat\" value=\"cat\"&gt;Cat&lt;/option&gt;\n...     &lt;option id=\"hamster\" value=\"hamster\" selected&gt;Hamster&lt;/option&gt;\n...     &lt;option id=\"parrot\" value=\"parrot\"&gt;Parrot&lt;/option&gt;\n...     &lt;option id=\"spider\" value=\"spider\"&gt;Spider&lt;/option&gt;\n...     &lt;option id=\"goldfish\" value=\"goldfish\"&gt;Goldfish&lt;/option&gt;\n... &lt;/select&gt;\n... &lt;/form&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':default'))\n[&lt;input checked=\"\" id=\"summer\" name=\"season\" type=\"radio\"/&gt;, &lt;option id=\"hamster\" selected=\"\" value=\"hamster\"&gt;Hamster&lt;/option&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:default</p>"},{"location":"selectors/pseudo-classes/#:defined","title":"<code>:defined</code>","text":"<p>In a browser environment, this represents defined elements (names without hyphens) and custom elements (names with hyphens) that have been properly added to the custom element registry. Since elements cannot be added to a custom element registry in Beautiful Soup, this will select all elements that are not custom tags. <code>:defined</code> is a HTML specific selector, so it doesn't apply to XML.</p> SyntaxUsage <pre><code>:defined\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;custom-element text=\"Custom element example text\"&gt;&lt;/custom-element&gt;\n... &lt;p&gt;Standard paragraph example text&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('body &gt; *:defined'))\n[&lt;p&gt;Standard paragraph example text&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:defined</p>"},{"location":"selectors/pseudo-classes/#:dir","title":"<code>:dir()</code>","text":"<p>Selects elements based on text directionality. Accepts either <code>ltr</code> or <code>rtl</code> for \"left to right\" and \"right to left\" respectively.</p> SyntaxUsage <pre><code>:dir(ltr)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;div&gt;\n... &lt;span dir=\"auto\"&gt;\u05d6\u05d0\u05ea \u05d4\u05e9\u05e4\u05d4 \u05d4\u05e2\u05d1\u05e8\u05d9\u05ea&lt;/span&gt;\n... &lt;span dir=\"ltr\"&gt;Text&lt;/span&gt;\n... &lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':dir(rtl)'))\n[&lt;span dir=\"auto\"&gt;\u05d6\u05d0\u05ea \u05d4\u05e9\u05e4\u05d4 \u05d4\u05e2\u05d1\u05e8\u05d9\u05ea&lt;/span&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:dir</p>"},{"location":"selectors/pseudo-classes/#:disabled","title":"<code>:disabled</code>","text":"<p>Selects any element that is disabled.</p> SyntaxUsage <pre><code>:disabled\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;form action=\"#\"&gt;\n...   &lt;fieldset id=\"shipping\"&gt;\n...     &lt;legend&gt;Shipping address&lt;/legend&gt;\n...     &lt;input type=\"text\" placeholder=\"Name\"&gt;\n...     &lt;input type=\"text\" placeholder=\"Address\"&gt;\n...     &lt;input type=\"text\" placeholder=\"Zip Code\"&gt;\n...   &lt;/fieldset&gt;\n...   &lt;br&gt;\n...   &lt;fieldset id=\"billing\"&gt;\n...     &lt;legend&gt;Billing address&lt;/legend&gt;\n...     &lt;label for=\"billing-checkbox\"&gt;Same as shipping address:&lt;/label&gt;\n...     &lt;input type=\"checkbox\" id=\"billing-checkbox\" checked&gt;\n...     &lt;br&gt;\n...     &lt;input type=\"text\" placeholder=\"Name\" disabled&gt;\n...     &lt;input type=\"text\" placeholder=\"Address\" disabled&gt;\n...     &lt;input type=\"text\" placeholder=\"Zip Code\" disabled&gt;\n...   &lt;/fieldset&gt;\n... &lt;/form&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('input:disabled'))\n[&lt;input disabled=\"\" placeholder=\"Name\" type=\"text\"/&gt;, &lt;input disabled=\"\" placeholder=\"Address\" type=\"text\"/&gt;, &lt;input disabled=\"\" placeholder=\"Zip Code\" type=\"text\"/&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:disabled</p>"},{"location":"selectors/pseudo-classes/#:empty","title":"<code>:empty</code>","text":"<p>Selects elements that have no children and no text (whitespace is ignored).</p> SyntaxUsage <pre><code>:empty\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;span&gt; &lt;!-- comment --&gt; &lt;/span&gt;\n... &lt;span&gt;&lt;/span&gt;\n... &lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/span&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('body :empty'))\n[&lt;span&gt; &lt;!-- comment --&gt; &lt;/span&gt;, &lt;span&gt;&lt;/span&gt;, &lt;span&gt;    &lt;/span&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:empty</p>"},{"location":"selectors/pseudo-classes/#:enabled","title":"<code>:enabled</code>","text":"<p>Selects any element that is enabled.</p> SyntaxUsage <pre><code>:enabled\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;form action=\"#\"&gt;\n...   &lt;fieldset id=\"shipping\"&gt;\n...     &lt;legend&gt;Shipping address&lt;/legend&gt;\n...     &lt;input type=\"text\" placeholder=\"Name\"&gt;\n...     &lt;input type=\"text\" placeholder=\"Address\"&gt;\n...     &lt;input type=\"text\" placeholder=\"Zip Code\"&gt;\n...   &lt;/fieldset&gt;\n...   &lt;br&gt;\n...   &lt;fieldset id=\"billing\"&gt;\n...     &lt;legend&gt;Billing address&lt;/legend&gt;\n...     &lt;label for=\"billing-checkbox\"&gt;Same as shipping address:&lt;/label&gt;\n...     &lt;input type=\"checkbox\" id=\"billing-checkbox\" checked&gt;\n...     &lt;br&gt;\n...     &lt;input type=\"text\" placeholder=\"Name\" disabled&gt;\n...     &lt;input type=\"text\" placeholder=\"Address\" disabled&gt;\n...     &lt;input type=\"text\" placeholder=\"Zip Code\" disabled&gt;\n...   &lt;/fieldset&gt;\n... &lt;/form&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('input:enabled'))\n[&lt;input placeholder=\"Name\" type=\"text\"/&gt;, &lt;input placeholder=\"Address\" type=\"text\"/&gt;, &lt;input placeholder=\"Zip Code\" type=\"text\"/&gt;, &lt;input checked=\"\" id=\"billing-checkbox\" type=\"checkbox\"/&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:enabled</p>"},{"location":"selectors/pseudo-classes/#:first-child","title":"<code>:first-child</code>","text":"<p>Selects the first child in a group of sibling elements.</p> SyntaxUsage <pre><code>:first-child\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;p id=\"2\"&gt;&lt;/p&gt;\n... &lt;p id=\"3\"&gt;&lt;/p&gt;\n... &lt;p id=\"4\"&gt;&lt;/p&gt;\n... &lt;p id=\"5\"&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('p:first-child'))\n[&lt;p id=\"0\"&gt;&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:first-child</p>"},{"location":"selectors/pseudo-classes/#:first-of-type","title":"<code>:first-of-type</code>","text":"<p>Selects the first child of a given type in a group of sibling elements.</p> SyntaxUsage <pre><code>element:first-of-type\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;span id=\"2\"&gt;&lt;/span&gt;\n... &lt;span id=\"3\"&gt;&lt;/span&gt;\n... &lt;span id=\"4\"&gt;&lt;/span&gt;\n... &lt;span id=\"5\"&gt;&lt;/span&gt;\n... &lt;span id=\"6\"&gt;&lt;/span&gt;\n... &lt;p id=\"7\"&gt;&lt;/p&gt;\n... &lt;p id=\"8\"&gt;&lt;/p&gt;\n... &lt;p id=\"9\"&gt;&lt;/p&gt;\n... &lt;p id=\"10\"&gt;&lt;/p&gt;\n... &lt;span id=\"11\"&gt;&lt;/span&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('span:first-of-type'))\n[&lt;span id=\"2\"&gt;&lt;/span&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:first-of-type</p>"},{"location":"selectors/pseudo-classes/#has","title":"<code>:has()</code>","text":"<p>Selects an element if any of the relative selectors passed as parameters (which are relative to the <code>:scope</code> of the given element), match at least one element.</p> <p>While the level 4 specifications state that compound selectors are supported, complex selectors are planned for level 5 CSS selectors. Soup Sieve supports complex selectors.</p> <p>In addition to supporting complex selectors, Soup Sieve also supports nested <code>:has()</code> which has been excluded from the level 4 specifications to help encourage browsers to implement <code>:has()</code>. This exclusion helps to reduces complexity and improves performance in a live environment. As these performance concerns are not an issue in a scraping environment compared to a web browser, Soup Sieve has no intentions on restricting the nesting of <code>:has()</code>. Users can always choose not to nest <code>:has()</code> if there are concerns.</p> SyntaxUsage <pre><code>:has(selector)\n:has(&gt; selector)\n:has(~ selector)\n:has(+ selector)\n:has(selector1, &gt; selector2, ~ selector3, + selector4)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;div&gt;&lt;p&gt;Test &lt;span&gt;paragraph&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;\n... &lt;div&gt;&lt;p class=\"class\"&gt;Another test paragraph&lt;/p&gt;&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('div:has(span, &gt; .class)'))\n[&lt;div&gt;&lt;p&gt;Test &lt;span&gt;paragraph&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;, &lt;div&gt;&lt;p class=\"class\"&gt;Another test paragraph&lt;/p&gt;&lt;/div&gt;]  \n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:has</p>"},{"location":"selectors/pseudo-classes/#:in-range","title":"<code>:in-range</code>","text":"<p>Selects all <code>&lt;input&gt;</code> elements whose values are in range according to their <code>type</code>, <code>min</code>, and <code>max</code> attributes.</p> SyntaxUsage <pre><code>:in-range\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;input id=\"0\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1999-05\"&gt;\n... &lt;input id=\"7\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1979-02\"&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':in-range'))\n[&lt;input id=\"0\" max=\"2004-08\" min=\"1980-02\" type=\"month\" value=\"1999-05\"/&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:in-range</p>"},{"location":"selectors/pseudo-classes/#:indeterminate","title":"<code>:indeterminate</code>","text":"<p>Selects all form elements whose are in an indeterminate state.</p> <p>An element is considered indeterminate if:</p> <ul> <li>The element is of type <code>&lt;input type=\"checkbox\"/&gt;</code> and the <code>indeterminate</code> attribute is set.</li> <li>The element is of type <code>&lt;input type=\"radio\"/&gt;</code> and all other radio controls with the same name are not     selected.</li> <li>The element is of type <code>&lt;progress&gt;</code> with no value.</li> </ul> SyntaxUsage <pre><code>:indeterminate\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;input type=\"checkbox\" id=\"checkbox1\" indeterminate&gt;\n... &lt;label for=\"checkbox1\"&gt;I like cats.&lt;/label&gt;\n... \n... &lt;input type=\"checkbox\" id=\"checkbox2\"&gt;\n... &lt;label for=\"checkbox2\"&gt;I like dogs.&lt;/label&gt;\n... \n... &lt;form&gt;\n...     &lt;input type=\"radio\" name=\"test\" id=\"radio1\"&gt;\n...     &lt;label for=\"radio1\"&gt;Yes&lt;/label&gt;\n... \n...     &lt;input type=\"radio\" name=\"test\" id=\"radio2\"&gt;\n...     &lt;label for=\"radio2\"&gt;No&lt;/label&gt;\n... \n...     &lt;input type=\"radio\" name=\"test\" id=\"radio3\"&gt;\n...     &lt;label for=\"radio3\"&gt;Maybe&lt;/label&gt;\n... &lt;/form&gt;\n... &lt;form&gt;\n...     &lt;input type=\"radio\" name=\"another\" id=\"radio4\"&gt;\n...     &lt;label for=\"radio4\"&gt;Red&lt;/label&gt;\n... \n...     &lt;input type=\"radio\" name=\"another\" id=\"radio5\" checked&gt;\n...     &lt;label for=\"radio5\"&gt;Green&lt;/label&gt;\n... \n...     &lt;input type=\"radio\" name=\"another\" id=\"radio6\"&gt;\n...     &lt;label for=\"radio6\"&gt;Blue&lt;/label&gt;\n... &lt;/form&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':indeterminate'))\n[&lt;input id=\"checkbox1\" indeterminate=\"\" type=\"checkbox\"/&gt;, &lt;input id=\"radio1\" name=\"test\" type=\"radio\"/&gt;, &lt;input id=\"radio2\" name=\"test\" type=\"radio\"/&gt;, &lt;input id=\"radio3\" name=\"test\" type=\"radio\"/&gt;] \n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:indeterminate</p>"},{"location":"selectors/pseudo-classes/#:is","title":"<code>:is()</code>","text":"<p>Selects an element, but only if it matches at least one selector in the selector list.</p> <p>The alias <code>:matches()</code> is also supported as it was the original name for the selector, and some browsers support it. It is strongly encouraged to use <code>:is()</code> instead as support for <code>:matches()</code> may be dropped in the future.</p> <p>While the level 4 specifications state that compound selectors are supported, some browsers (Safari) support complex selectors which are planned for level 5 CSS selectors. Soup Sieve also supports complex selectors.</p> SyntaxUsage <pre><code>:is(selector1, selector2)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;Some text &lt;span id=\"1\"&gt; in a paragraph&lt;/span&gt;.\n... &lt;a id=\"2\" href=\"http://google.com\"&gt;Link.&lt;/a&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('[id]:is(a, span)'))\n[&lt;span id=\"1\"&gt; in a paragraph&lt;/span&gt;, &lt;a href=\"http://google.com\" id=\"2\"&gt;Link.&lt;/a&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:is</p>"},{"location":"selectors/pseudo-classes/#:lang","title":"<code>:lang()</code>","text":"Level 3 CSS <p>Selects an element whose associated language matches the provided language or whose language starts with the     provided language followed by a <code>-</code>. Language is determined by the rules of the document type.</p> SyntaxUsage <pre><code>:lang(language)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;div lang=\"de-DE\"&gt;\n...     &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;div lang=\"de-DE-1996\"&gt;\n...     &lt;p id=\"2\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;div lang=\"de-Latn-DE\"&gt;\n...     &lt;p id=\"3\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;div lang=\"de-Latf-DE\"&gt;\n...     &lt;p id=\"4\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;div lang=\"de-Latn-DE-1996\"&gt;\n...     &lt;p id=\"5\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;p id=\"6\" lang=\"de-DE\"&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('p:lang(de)'))\n[&lt;p id=\"1\"&gt;&lt;/p&gt;, &lt;p id=\"2\"&gt;&lt;/p&gt;, &lt;p id=\"3\"&gt;&lt;/p&gt;, &lt;p id=\"4\"&gt;&lt;/p&gt;, &lt;p id=\"5\"&gt;&lt;/p&gt;, &lt;p id=\"6\" lang=\"de-DE\"&gt;&lt;/p&gt;]\n</code></pre> Level 4 CSS <p>The level 4 CSS specifications adds the ability to define multiple language tags using a comma separated list. The     specifications also allow for BCP 47 language ranges as described in RFC4647     for extended filtering. This enables implicit wildcard matching between subtags. For instance, <code>:lang(de-DE)</code> will     match all of <code>de-DE</code>, <code>de-DE-1996</code>, <code>de-Latn-DE</code>, <code>de-Latf-DE</code>, and <code>de-Latn-DE-1996</code>. Implicit wildcard matching     will not take place at the beginning on the primary language tag, <code>*</code> must be used to force wildcard matching at the     beginning of the language. If desired an explicit wildcard between subtags can be used, but since implicit wildcard     matching already takes place between subtags, it is not needed: <code>de-*-DE</code> would be the same as just using <code>de-DE</code>.</p> SyntaxUsage <pre><code>:lang('*-language', language2)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;div lang=\"de-DE\"&gt;\n...     &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;div lang=\"en\"&gt;\n...     &lt;p id=\"2\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;div lang=\"de-Latn-DE\"&gt;\n...     &lt;p id=\"3\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;div lang=\"de-Latf-DE\"&gt;\n...     &lt;p id=\"4\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;div lang=\"en-US\"&gt;\n...     &lt;p id=\"5\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;p id=\"6\" lang=\"de-DE\"&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('p:lang(de-DE, \"*-US\")'))\n[&lt;p id=\"1\"&gt;&lt;/p&gt;, &lt;p id=\"3\"&gt;&lt;/p&gt;, &lt;p id=\"4\"&gt;&lt;/p&gt;, &lt;p id=\"5\"&gt;&lt;/p&gt;, &lt;p id=\"6\" lang=\"de-DE\"&gt;&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:lang</p>"},{"location":"selectors/pseudo-classes/#:last-child","title":"<code>:last-child</code>","text":"<p>Selects the last element among a group of sibling elements.</p> SyntaxUsage <pre><code>:last-child\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;p id=\"2\"&gt;&lt;/p&gt;\n... &lt;p id=\"3\"&gt;&lt;/p&gt;\n... &lt;p id=\"4\"&gt;&lt;/p&gt;\n... &lt;p id=\"5\"&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('p:last-child'))\n[&lt;p id=\"5\"&gt;&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:last-child</p>"},{"location":"selectors/pseudo-classes/#:last-of-type","title":"<code>:last-of-type</code>","text":"<p>Selects the last child of a given type in a group of sibling elements.</p> SyntaxUsage <pre><code>element:last-of-type\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;span id=\"2\"&gt;&lt;/span&gt;\n... &lt;span id=\"3\"&gt;&lt;/span&gt;\n... &lt;span id=\"4\"&gt;&lt;/span&gt;\n... &lt;span id=\"5\"&gt;&lt;/span&gt;\n... &lt;span id=\"6\"&gt;&lt;/span&gt;\n... &lt;p id=\"7\"&gt;&lt;/p&gt;\n... &lt;p id=\"8\"&gt;&lt;/p&gt;\n... &lt;p id=\"9\"&gt;&lt;/p&gt;\n... &lt;p id=\"10\"&gt;&lt;/p&gt;\n... &lt;span id=\"11\"&gt;&lt;/span&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('span:last-of-type'))\n[&lt;span id=\"11\"&gt;&lt;/span&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:last-of-type</p>"},{"location":"selectors/pseudo-classes/#:link","title":"<code>:link</code>","text":"<p>Selects a link (every <code>&lt;a&gt;</code> and <code>&lt;area&gt;</code> element with an <code>href</code> attribute) that has not yet been visited.</p> <p>Since Beautiful Soup does not have visited states, this will match all links, essentially making the behavior the same as <code>:any-link</code>.</p> SyntaxUsage <pre><code>:link\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bsx\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p&gt;A link to &lt;a href=\"http://example.com\"&gt;click&lt;/a&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':link'))\n[&lt;a href=\"http://example.com\"&gt;click&lt;/a&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:link</p> <p>New in 2.2</p> <p>The CSS specification recently updated to not include <code>&lt;link&gt;</code> in the definition; therefore, Soup Sieve has removed it as well.</p>"},{"location":"selectors/pseudo-classes/#:not","title":"<code>:not()</code>","text":"Level 3 CSS <p>Selects all elements that do not match the selector. The level 3 CSS specification states that <code>:not()</code> only     supports simple selectors.</p> SyntaxUsage <pre><code>:not(simple-selector)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n...    &lt;div&gt;Here is some text.&lt;/div&gt;\n...    &lt;div&gt;Here is some more text.&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('div:not(:-soup-contains(more))'))\n[&lt;div&gt;Here is some text.&lt;/div&gt;]\n</code></pre> Level 4+ CSS <p>Selects all elements that do not match any of the selectors in the selector list. While the level 4 specifications     state that compound selectors are supported, some browsers (Safari) support complex selectors     which are planned for level 5 CSS selectors. Soup Sieve also supports complex selectors.</p> SyntaxUsage <pre><code>:not(compound.selector, complex &gt; selector)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n...    &lt;div&gt;Here is some text.&lt;/div&gt;\n...    &lt;div&gt;Here is some more text.&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('*:not(html, head, body)'))\n[&lt;div&gt;Here is some text.&lt;/div&gt;, &lt;div&gt;Here is some more text.&lt;/div&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:not</p>"},{"location":"selectors/pseudo-classes/#:nth-child","title":"<code>:nth-child()</code>","text":"<p><code>:nth-child()</code> matches elements based on their position in a group of siblings.</p> Level 3 CSS <ul> <li> <p>The keywords <code>even</code> and <code>odd</code>  will respectively select elements whose position is either even or odd amongst a     group of siblings.</p> </li> <li> <p>Patterns in the form <code>an+b</code> selects elements based on their position in a group of siblings, for every positive     integer or zero value of <code>n</code>. The index of the first element is <code>1</code>. The values <code>a</code> and <code>b</code> must both be     integers.</p> </li> </ul> SyntaxUsage <pre><code>:nth-child(even)\n:nth-child(odd)\n:nth-child(2)\n:nth-child(2n+2)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;p id=\"2\"&gt;&lt;/p&gt;\n... &lt;p id=\"3\"&gt;&lt;/p&gt;\n... &lt;p id=\"4\"&gt;&lt;/p&gt;\n... &lt;p id=\"5\"&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('p:nth-child(even)'))\n[&lt;p id=\"1\"&gt;&lt;/p&gt;, &lt;p id=\"3\"&gt;&lt;/p&gt;, &lt;p id=\"5\"&gt;&lt;/p&gt;]\n&gt;&gt;&gt; print(soup.select('p:nth-child(odd)'))\n[&lt;p id=\"0\"&gt;&lt;/p&gt;, &lt;p id=\"2\"&gt;&lt;/p&gt;, &lt;p id=\"4\"&gt;&lt;/p&gt;]\n&gt;&gt;&gt; print(soup.select('p:nth-child(2)'))\n[&lt;p id=\"1\"&gt;&lt;/p&gt;]\n&gt;&gt;&gt; print(soup.select('p:nth-child(-n+3)'))\n[&lt;p id=\"0\"&gt;&lt;/p&gt;, &lt;p id=\"1\"&gt;&lt;/p&gt;, &lt;p id=\"2\"&gt;&lt;/p&gt;]\n</code></pre> Level 4+ CSS <p>Level 4 CSS adds the additional pattern in the form <code>an+b of S</code> where <code>S</code> represents a selector list. <code>an+b</code> can     also be substituted with <code>even</code> or <code>odd</code>.</p> <p>When using the pattern <code>an+b of S</code>, the pattern will select elements from a sub-group of sibling elements that all match the selector list (<code>[of S]?</code>), based on their position within that sub-group, using the pattern <code>an+b</code>, for every positive integer or zero value of <code>n</code>. The index of the first element is <code>1</code>. The values <code>a</code> and <code>b</code> must both be integers.</p> <p>Essentially, <code>img:nth-of-type(2)</code> would be equivalent to <code>:nth-child(2 of img)</code>. The advantage of using <code>:nth-child(an+b [of S]?)</code> over <code>:nth-of-type</code> is that <code>:nth-of-type</code> is restricted to types, while <code>:nth-child(an+b [of S]?)</code> can use complex selectors.</p> <p>While the level 4 specifications state that compound selectors are supported, complex selectors are planned for level 5 CSS selectors. Soup Sieve supports complex selectors.</p> SyntaxUsage <pre><code>:nth-child(2 of img)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;p id=\"2\"&gt;&lt;/p&gt;\n... &lt;p id=\"3\"&gt;&lt;/p&gt;\n... &lt;p id=\"4\"&gt;&lt;/p&gt;\n... &lt;p id=\"5\"&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('*:nth-child(-n+3 of [id])'))\n[&lt;p id=\"0\"&gt;&lt;/p&gt;, &lt;p id=\"1\"&gt;&lt;/p&gt;, &lt;p id=\"2\"&gt;&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child</p>"},{"location":"selectors/pseudo-classes/#:nth-last-child","title":"<code>:nth-last-child()</code>","text":"<p><code>:nth-last-child()</code> matches elements based on their position in a group of siblings, counting from the end.</p> Level 3 CSS <ul> <li> <p>Counting from the end, the keywords <code>even</code> and <code>odd</code>  will respectively select elements whose position is either     even or odd amongst a group of siblings.</p> </li> <li> <p>Counting from the end, patterns in the form <code>an+b</code> selects elements based on their position in a group of     siblings, for every positive integer or zero value of <code>n</code>. The index of the first element is <code>1</code>. The values <code>a</code>     and <code>b</code> must both be integers.</p> </li> </ul> SyntaxUsage <pre><code>:nth-last-child(even)\n:nth-last-child(odd)\n:nth-last-child(2)\n:nth-last-child(2n+2)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;p id=\"2\"&gt;&lt;/p&gt;\n... &lt;p id=\"3\"&gt;&lt;/p&gt;\n... &lt;p id=\"4\"&gt;&lt;/p&gt;\n... &lt;p id=\"5\"&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('p:nth-last-child(even)'))\n[&lt;p id=\"0\"&gt;&lt;/p&gt;, &lt;p id=\"2\"&gt;&lt;/p&gt;, &lt;p id=\"4\"&gt;&lt;/p&gt;]\n&gt;&gt;&gt; print(soup.select('p:nth-last-child(odd)'))\n[&lt;p id=\"1\"&gt;&lt;/p&gt;, &lt;p id=\"3\"&gt;&lt;/p&gt;, &lt;p id=\"5\"&gt;&lt;/p&gt;]\n&gt;&gt;&gt; print(soup.select('p:nth-last-child(2)'))\n[&lt;p id=\"4\"&gt;&lt;/p&gt;]\n&gt;&gt;&gt; print(soup.select('p:nth-last-child(-n+3)'))\n[&lt;p id=\"3\"&gt;&lt;/p&gt;, &lt;p id=\"4\"&gt;&lt;/p&gt;, &lt;p id=\"5\"&gt;&lt;/p&gt;]\n</code></pre> Level 4+ CSS <p>Level 4 CSS adds the additional pattern in the form <code>an+b of S</code> where <code>S</code> represents a selector list. <code>an+b</code> can     also be substituted with <code>even</code> or <code>odd</code>.</p> <p>When using the pattern <code>an+b of S</code>, the pattern will select elements from a sub-group of sibling elements that all match the selector list (<code>[of S]?</code>), based on their position within that sub-group, using the pattern <code>an+b</code>, for every positive integer or zero value of <code>n</code>. The index of the first element is <code>1</code>. The values <code>a</code> and <code>b</code> must both be integers. Elements will be counted from the end.</p> <p>Essentially, <code>img:nth-last-of-type(2)</code> would be equivalent to <code>:nth-last-child(2 of img)</code>. The advantage of using <code>:nth-last-child(an+b [of S]?)</code> over <code>:nth-last-of-type</code> is that <code>:nth-last-of-type</code> is restricted to types, while <code>:nth-last-child(an+b [of S]?)</code> can use complex selectors.</p> <p>While the level 4 specifications state that compound selectors are supported, complex selectors are planned for level 5 CSS selectors. Soup Sieve supports complex selectors.</p> SyntaxUsage <pre><code>:nth-last-child(2 of img)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;p id=\"2\"&gt;&lt;/p&gt;\n... &lt;p id=\"3\"&gt;&lt;/p&gt;\n... &lt;p id=\"4\"&gt;&lt;/p&gt;\n... &lt;p id=\"5\"&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('*:nth-last-child(-n+3 of [id])'))\n[&lt;p id=\"3\"&gt;&lt;/p&gt;, &lt;p id=\"4\"&gt;&lt;/p&gt;, &lt;p id=\"5\"&gt;&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-last-child</p>"},{"location":"selectors/pseudo-classes/#:nth-last-of-type","title":"<code>:nth-last-of-type()</code>","text":"<p><code>:nth-of-type()</code> matches elements of a given type, based on their position among a group of siblings, counting from the end.</p> <ul> <li> <p>The keywords <code>even</code> and <code>odd</code>, and will respectively select elements, from a sub-group of     sibling elements that all match the given type, whose position is either even or odd amongst that sub-group of     siblings. Starting position is counted from the end.</p> </li> <li> <p>Patterns in the form <code>an+b</code> select from a sub-group of sibling elements that all match the given type, based on     their position within that sub-group, for every positive integer or zero value of <code>n</code>. The index of the first     element is <code>1</code>. The values <code>a</code> and <code>b</code> must both be integers. Starting position is counted from the end.</p> </li> </ul> SyntaxUsage <pre><code>element:nth-last-of-type(even)\nelement:nth-last-of-type(odd)\nelement:nth-last-of-type(2)\nelement:nth-last-of-type(2n+2)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;span id=\"2\"&gt;&lt;/span&gt;\n... &lt;span id=\"3\"&gt;&lt;/span&gt;\n... &lt;span id=\"4\"&gt;&lt;/span&gt;\n... &lt;span id=\"5\"&gt;&lt;/span&gt;\n... &lt;span id=\"6\"&gt;&lt;/span&gt;\n... &lt;p id=\"7\"&gt;&lt;/p&gt;\n... &lt;p id=\"8\"&gt;&lt;/p&gt;\n... &lt;p id=\"9\"&gt;&lt;/p&gt;\n... &lt;p id=\"10\"&gt;&lt;/p&gt;\n... &lt;span id=\"11\"&gt;&lt;/span&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('span:nth-last-of-type(even)'))\n[&lt;span id=\"2\"&gt;&lt;/span&gt;, &lt;span id=\"4\"&gt;&lt;/span&gt;, &lt;span id=\"6\"&gt;&lt;/span&gt;]\n&gt;&gt;&gt; print(soup.select('span:nth-last-of-type(odd)'))\n[&lt;span id=\"3\"&gt;&lt;/span&gt;, &lt;span id=\"5\"&gt;&lt;/span&gt;, &lt;span id=\"11\"&gt;&lt;/span&gt;]\n&gt;&gt;&gt; print(soup.select('p:nth-last-of-type(2)'))\n[&lt;p id=\"9\"&gt;&lt;/p&gt;]\n&gt;&gt;&gt; print(soup.select('p:nth-last-of-type(-n+3)'))\n[&lt;p id=\"8\"&gt;&lt;/p&gt;, &lt;p id=\"9\"&gt;&lt;/p&gt;, &lt;p id=\"10\"&gt;&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-last-of-type</p>"},{"location":"selectors/pseudo-classes/#:nth-of-type","title":"<code>:nth-of-type()</code>","text":"<p><code>:nth-of-type()</code> matches elements of a given type, based on their position among a group of siblings.</p> <ul> <li> <p>The keywords <code>even</code> and <code>odd</code>, and will respectively select elements, from a sub-group of     sibling elements that all match the given type, whose position is either even or odd amongst that sub-group of     siblings.</p> </li> <li> <p>Patterns in the form <code>an+b</code> select from a sub-group of sibling elements that all match the given type, based on     their position within that sub-group, for every positive integer or zero value of <code>n</code>. The index of the first     element is <code>1</code>. The values <code>a</code> and <code>b</code> must both be integers.</p> </li> </ul> SyntaxUsage <pre><code>element:nth-of-type(even)\nelement:nth-of-type(odd)\nelement:nth-of-type(2)\nelement:nth-of-type(2n+2)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;span id=\"2\"&gt;&lt;/span&gt;\n... &lt;span id=\"3\"&gt;&lt;/span&gt;\n... &lt;span id=\"4\"&gt;&lt;/span&gt;\n... &lt;span id=\"5\"&gt;&lt;/span&gt;\n... &lt;span id=\"6\"&gt;&lt;/span&gt;\n... &lt;p id=\"7\"&gt;&lt;/p&gt;\n... &lt;p id=\"8\"&gt;&lt;/p&gt;\n... &lt;p id=\"9\"&gt;&lt;/p&gt;\n... &lt;p id=\"10\"&gt;&lt;/p&gt;\n... &lt;span id=\"11\"&gt;&lt;/span&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('span:nth-of-type(even)'))\n[&lt;span id=\"3\"&gt;&lt;/span&gt;, &lt;span id=\"5\"&gt;&lt;/span&gt;, &lt;span id=\"11\"&gt;&lt;/span&gt;]\n&gt;&gt;&gt; print(soup.select('span:nth-of-type(odd)'))\n[&lt;span id=\"2\"&gt;&lt;/span&gt;, &lt;span id=\"4\"&gt;&lt;/span&gt;, &lt;span id=\"6\"&gt;&lt;/span&gt;]\n&gt;&gt;&gt; print(soup.select('p:nth-of-type(2)'))\n[&lt;p id=\"1\"&gt;&lt;/p&gt;]\n&gt;&gt;&gt; print(soup.select('p:nth-of-type(-n+3)'))\n[&lt;p id=\"0\"&gt;&lt;/p&gt;, &lt;p id=\"1\"&gt;&lt;/p&gt;, &lt;p id=\"7\"&gt;&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-of-type</p>"},{"location":"selectors/pseudo-classes/#:only-child","title":"<code>:only-child</code>","text":"<p>Selects element without any siblings.</p> SyntaxUsage <pre><code>:only-child\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;div&gt;\n...     &lt;p id=\"0\"&gt;&lt;/p&gt;\n...     &lt;p id=\"1\"&gt;&lt;/p&gt;\n...     &lt;p id=\"2\"&gt;&lt;/p&gt;\n...     &lt;p id=\"3\"&gt;&lt;/p&gt;\n...     &lt;p id=\"4\"&gt;&lt;/p&gt;\n...     &lt;p id=\"5\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;div&gt;\n...     &lt;p id=\"6\"&gt;&lt;/p&gt;\n... &lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('p:only-child'))\n[&lt;p id=\"6\"&gt;&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:only-child</p>"},{"location":"selectors/pseudo-classes/#:only-of-type","title":"<code>:only-of-type</code>","text":"<p>Selects element without any siblings that matches a given type.</p> SyntaxUsage <pre><code>element:only-of-type\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;&lt;/p&gt;\n... &lt;p id=\"1\"&gt;&lt;/p&gt;\n... &lt;span id=\"2\"&gt;&lt;/span&gt;\n... &lt;p id=\"3\"&gt;&lt;/p&gt;\n... &lt;p id=\"4\"&gt;&lt;/p&gt;\n... &lt;p id=\"5\"&gt;&lt;/p&gt;\n... &lt;p id=\"6\"&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('span:only-of-type'))\n[&lt;span id=\"2\"&gt;&lt;/span&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:only-of-type</p>"},{"location":"selectors/pseudo-classes/#:optional","title":"<code>:optional</code>","text":"<p>Selects any <code>&lt;input&gt;</code>, <code>&lt;select&gt;</code>, or <code>&lt;textarea&gt;</code> element that does not have the <code>required</code> attribute set on it.</p> SyntaxUsage <pre><code>:optional\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;form&gt;\n... &lt;input type=\"name\" required&gt;\n... &lt;input type=\"checkbox\" required&gt;\n... &lt;input type=\"email\"&gt;\n... &lt;textarea name=\"name\" cols=\"30\" rows=\"10\" required&gt;&lt;/textarea&gt;\n... &lt;select name=\"nm\" required&gt;\n...     &lt;!-- options --&gt;\n... &lt;/select&gt;\n... &lt;/form&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':optional'))\n[&lt;input type=\"email\"/&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:optional</p>"},{"location":"selectors/pseudo-classes/#:out-of-range","title":"<code>:out-of-range</code>","text":"<p>Selects all <code>&lt;input&gt;</code> elements whose values are out of range according to their <code>type</code>, <code>min</code>, and <code>max</code> attributes.</p> SyntaxUsage <pre><code>:out-of-range\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;input id=\"0\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1999-05\"&gt;\n... &lt;input id=\"7\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1979-02\"&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':out-of-range'))\n[&lt;input id=\"7\" max=\"2004-08\" min=\"1980-02\" type=\"month\" value=\"1979-02\"/&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:out-of-range</p>"},{"location":"selectors/pseudo-classes/#:placeholder-shown","title":"<code>:placeholder-shown</code>","text":"<p>Selects any <code>&lt;input&gt;</code> or <code>&lt;textarea&gt;</code> element that is currently displaying placeholder text via the <code>placeholder</code> attribute.</p> SyntaxUsage <pre><code>:placeholder-shown\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;input id=\"0\" placeholder=\"This is some text\"&gt;\n... &lt;textarea id=\"1\" placeholder=\"This is some text\"&gt;&lt;/textarea&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':placeholder-shown'))\n[&lt;input id=\"0\" placeholder=\"This is some text\"/&gt;, &lt;textarea id=\"1\" placeholder=\"This is some text\"&gt;&lt;/textarea&gt;]\n</code></pre> <p>Parser Differences</p> <p>In general, when an input has a placeholder, but the element also has valid content, the placeholder is not shown. For instance, when a <code>textarea</code> has actual text associated with the element, the placeholder is overridden with the actual content. A <code>textarea</code> is allowed no more than a single newline to be considered as having no content (carriage returns don't count).</p> <p><code>html5lib</code> will strip out carriage returns, but <code>lxml</code> and <code>html.parser</code> will not. This will cause a difference between the parsers when dealing with Windows style line endings and <code>textareas</code>. <code>html5lib</code> seems to follow closest to what real browsers do. Soup Sieve is simply following the specification as best it can. Unfortunately, it can't account for the quirks of the parsers in this case without introducing other issues.</p> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:placeholder-shown</p>"},{"location":"selectors/pseudo-classes/#:read-only","title":"<code>:read-only</code>","text":"<p>Selects elements (such as <code>&lt;input&gt;</code> or <code>&lt;textarea&gt;</code>) that are not editable by the user. This does not just apply to form elements with <code>readonly</code> set, but it applies to any element that cannot be edited by the user.</p> SyntaxUsage <pre><code>:read-only\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... \n... &lt;input id=\"0\"&gt;\n... &lt;input id=\"1\" disabled&gt;\n... &lt;input id=\"2\" type=\"number\" readonly&gt;\n... \n... &lt;textarea id=\"3\"&gt;&lt;/textarea&gt;\n... \n... &lt;p id=\"4\"&gt;Not editable&lt;/p&gt;\n... &lt;p id=\"5\" contenteditable=\"true\"&gt;Editable text&lt;/p&gt;\n... \n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('body :read-only'))\n[&lt;input disabled=\"\" id=\"1\"/&gt;, &lt;input id=\"2\" readonly=\"\" type=\"number\"/&gt;, &lt;p id=\"4\"&gt;Not editable&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:read-only</p>"},{"location":"selectors/pseudo-classes/#:read-write","title":"<code>:read-write</code>","text":"<p>Selects elements (such as <code>&lt;input&gt;</code> or <code>&lt;textarea&gt;</code>) that are editable by the user. This does not just apply to form elements as it applies to any element that can be edited by the user, such as a <code>&lt;p&gt;</code> element with <code>contenteditable</code> set on it.</p> SyntaxUsage <pre><code>:read-only\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... \n... &lt;input id=\"0\"&gt;\n... &lt;input id=\"1\" disabled&gt;\n... &lt;input id=\"2\" type=\"number\" readonly&gt;\n... \n... &lt;textarea id=\"3\"&gt;&lt;/textarea&gt;\n... \n... &lt;p id=\"4\"&gt;Not editable&lt;/p&gt;\n... &lt;p id=\"5\" contenteditable=\"true\"&gt;Editable text&lt;/p&gt;\n... \n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('body :read-write'))\n[&lt;input id=\"0\"/&gt;, &lt;textarea id=\"3\"&gt;&lt;/textarea&gt;, &lt;p contenteditable=\"true\" id=\"5\"&gt;Editable text&lt;/p&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:read-write</p>"},{"location":"selectors/pseudo-classes/#:required","title":"<code>:required</code>","text":"<p>Selects any <code>&lt;input&gt;</code>, <code>&lt;select&gt;</code>, or <code>&lt;textarea&gt;</code> element that has the <code>required</code> attribute set on it.</p> SyntaxUsage <pre><code>:required\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;form&gt;\n... &lt;input type=\"name\" required&gt;\n... &lt;input type=\"checkbox\" required&gt;\n... &lt;input type=\"email\"&gt;\n... &lt;textarea name=\"name\" cols=\"30\" rows=\"10\" required&gt;&lt;/textarea&gt;\n... &lt;select name=\"nm\" required&gt;\n...     &lt;!-- options --&gt;\n... &lt;/select&gt;\n... &lt;/form&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':required'))\n[&lt;input required=\"\" type=\"name\"/&gt;, &lt;input required=\"\" type=\"checkbox\"/&gt;, &lt;textarea cols=\"30\" name=\"name\" required=\"\" rows=\"10\"&gt;&lt;/textarea&gt;, &lt;select name=\"nm\" required=\"\"&gt;\n    &lt;!-- options --&gt;\n&lt;/select&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:required</p>"},{"location":"selectors/pseudo-classes/#:root","title":"<code>:root</code>","text":"<p>Selects the root element of a document tree.</p> SyntaxUsage <pre><code>:root\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n...    &lt;div&gt;Here is some text.&lt;/div&gt;\n...    &lt;div&gt;Here is some more text.&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select(':root'))\n[&lt;html&gt;&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;\n    &lt;div&gt;Here is some text.&lt;/div&gt;\n    &lt;div&gt;Here is some more text.&lt;/div&gt;\n\n\n&lt;/body&gt;&lt;/html&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:root</p>"},{"location":"selectors/pseudo-classes/#:scope","title":"<code>:scope</code>","text":"<p>New 2.6</p> <p><code>&amp;</code>, which was introduced in CSS Nesting Level 1 can be used as an alternative to <code>:scope</code> and is essentially equivalent. Soup Sieve does not support nesting selectors, but <code>&amp;</code>, when not used in the context of nesting is treated as the scoping root per the specification.</p> <p><code>sv.select('&amp; &gt; p', soup.div)</code> is equivalent to <code>sv.select(':scope &gt; p', soup.div)</code>.</p> <p><code>:scope</code> represents the the element a <code>match</code>, <code>select</code>, or <code>filter</code> is being called on. If we were, for instance, using <code>:scope</code> on a div (<code>sv.select(':scope &gt; p', soup.div)</code>) <code>:scope</code> would represent that div element, and no others. If called on the Beautiful Soup object which represents the entire document, it would simply select <code>:root</code>.</p> SyntaxUsage <pre><code>:scope\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n...    &lt;div&gt;Here is some text.&lt;/div&gt;\n...    &lt;div&gt;Here is some more text.&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select_one('body').select(':scope &gt; div'))\n[&lt;div&gt;Here is some text.&lt;/div&gt;, &lt;div&gt;Here is some more text.&lt;/div&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:scope</p>"},{"location":"selectors/pseudo-classes/#:where","title":"<code>:where()</code>","text":"<p>Selects an element, but only if it matches at least one selector in the selector list. In browsers, this also has zero specificity, but this only has relevance in a browser environment where you have multiple CSS styles, and specificity is used to see which applies. Beautiful Soup and Soup Sieve don't care about specificity so <code>:where()</code> is essentially just an alias for <code>:is()</code>.</p> <p>While the level 4 specifications state that compound selectors are supported, some browsers (Safari) support complex selectors which are planned for level 5 CSS selectors. Soup Sieve also supports complex selectors.</p> SyntaxUsage <pre><code>:where(selector1, selector2)\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n... &lt;p id=\"0\"&gt;Some text &lt;span id=\"1\"&gt; in a paragraph&lt;/span&gt;.\n... &lt;a id=\"2\" href=\"http://google.com\"&gt;Link.&lt;/a&gt;&lt;/p&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('[id]:where(a, span)'))\n[&lt;span id=\"1\"&gt; in a paragraph&lt;/span&gt;, &lt;a href=\"http://google.com\" id=\"2\"&gt;Link.&lt;/a&gt;]\n</code></pre> <p>Additional Reading</p> <p>https://developer.mozilla.org/en-US/docs/Web/CSS/:where</p>"},{"location":"selectors/pseudo-classes/#:-soup-contains","title":"<code>:-soup-contains()</code>","text":"<p>Selects elements that contain the provided text. Text can be found in either itself, or its descendants.</p> <p>Originally, there was a pseudo-class called <code>:contains()</code> that was originally included in a CSS early draft, but was dropped from the draft in the end. Soup Sieve implements it how it was originally proposed accept for two differences: it is called <code>:-soup-contains()</code> instead of <code>:contains()</code>, and it can accept either a single value, or a comma separated list of values. An element needs only to match at least one of the items in the comma separated list to be considered matching.</p> <p>Rename 2.1</p> <p>The name <code>:-soup-contains()</code> is new in version 2.1. Previously, it was known by <code>:contains()</code>. While the alias of <code>:contains()</code> is currently allowed, this alias is deprecated moving forward and will be removed in a future version. It is recommended to migrate to the name <code>:-soup-contains</code> moving forward.</p> <p>Expensive Operation</p> <p><code>:-soup-contains()</code> is an expensive operation as it scans all the text nodes of an element under consideration, which includes all descendants. Using highly specific selectors can reduce how often it is evaluated.</p> SyntaxUsage <pre><code>:-soup-contains(text)\n:-soup-contains(\"This text\", \"or this text\")\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n...   &lt;div&gt;Here is &lt;span&gt;some text&lt;/span&gt;.&lt;/div&gt;\n...   &lt;div&gt;Here is some more text.&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('div:-soup-contains(\"some text\")'))\n[&lt;div&gt;Here is &lt;span&gt;some text&lt;/span&gt;.&lt;/div&gt;]\n</code></pre>"},{"location":"selectors/pseudo-classes/#:-soup-contains-own","title":"<code>:-soup-contains-own()</code>","text":"<p>Selects elements that contain the provided text. Text must be found in the target element and not in its descendants. If text is broken up with with descendant elements, each text node will be evaluated separately.</p> <p>Syntax is the same as <code>:-soup-contains()</code>.</p> SyntaxUsage <pre><code>:-soup-contains-own(text)\n:-soup-contains-own(\"This text\", \"or this text\")\n</code></pre> <pre><code>&gt;&gt;&gt; from bs4 import BeautifulSoup as bs\n&gt;&gt;&gt; html = \"\"\"\n... &lt;html&gt;\n... &lt;head&gt;&lt;/head&gt;\n... &lt;body&gt;\n...   &lt;div&gt;Here is &lt;span&gt;some text&lt;/span&gt;.&lt;/div&gt;\n...   &lt;div&gt;Here is some more text.&lt;/div&gt;\n... &lt;/body&gt;\n... &lt;/html&gt;\n... \"\"\"\n&gt;&gt;&gt; soup = bs(html, 'html5lib')\n&gt;&gt;&gt; print(soup.select('div:-soup-contains-own(\"some\")'))\n[&lt;div&gt;Here is some more text.&lt;/div&gt;]\n</code></pre> <p>New in 2.1</p> <p><code>:-soup-contains-own()</code> was added in 2.1.</p>"},{"location":"selectors/unsupported/","title":"Non-Applicable Pseudo Classes","text":""},{"location":"selectors/unsupported/#overview","title":"Overview","text":"<p>These pseudo classes are recognized by the parser, and have been identified as not being applicable in a Beautiful Soup environment. While the pseudo-classes will parse correctly, they will not match anything. This is because they cannot be implemented outside a live, browser environment. If at any time these are dropped from the CSS spec, they will simply be removed.</p>"},{"location":"selectors/unsupported/#:active","title":"<code>:active</code>","text":"<p>Selects active elements.</p> Syntax <pre><code>:active\n</code></pre>"},{"location":"selectors/unsupported/#:current","title":"<code>:current</code>","text":"<p><code>:current</code> selects the element, or an ancestor of the element, that is currently being displayed. The functional form of <code>:current()</code> takes a compound selector list.</p> Syntax <pre><code>:current\n:current(selector1, selector2)\n</code></pre>"},{"location":"selectors/unsupported/#:focus","title":"<code>:focus</code>","text":"<p>Represents an an element that has received focus.</p> Syntax <pre><code>:focus\n</code></pre>"},{"location":"selectors/unsupported/#:focus-visible","title":"<code>:focus-visible</code>","text":"<p>Selects an element that matches <code>:focus</code> and the user agent determines that the focus should be made evident on the element.</p> Syntax <pre><code>:focus-visible\n</code></pre>"},{"location":"selectors/unsupported/#:focus-within","title":"<code>:focus-within</code>","text":"<p>Selects an element that has received focus or contains an element that has received focus.</p> Syntax <pre><code>:focus-within\n</code></pre>"},{"location":"selectors/unsupported/#:future","title":"<code>:future</code>","text":"<p>Selects an element that is defined to occur entirely after a <code>:current</code> element.</p> Syntax <pre><code>:future\n</code></pre>"},{"location":"selectors/unsupported/#host","title":"<code>:host</code>","text":"<p><code>:host</code> selects the element hosting a shadow tree. While the function form of <code>:host()</code> takes a complex selector list and matches the shadow host only if it matches one of the selectors in the list.</p> Syntax <pre><code>:host\n:host(selector1, selector2)\n</code></pre>"},{"location":"selectors/unsupported/#:host-context","title":"<code>:host-context()</code>","text":"<p>Selects the element hosting shadow tree, but only if one of the element's ancestors match a selector in the selector list.</p> Syntax <pre><code>:host-context(parent descendant)\n</code></pre>"},{"location":"selectors/unsupported/#:hover","title":"<code>:hover</code>","text":"<p>Selects an element when the user interacts with it by hovering over it with a pointing device.</p> Syntax <pre><code>:hover\n</code></pre>"},{"location":"selectors/unsupported/#:local-link","title":"<code>:local-link</code>","text":"<p>Selects link (every <code>&lt;a&gt;</code>, <code>&lt;link&gt;</code>, and <code>&lt;area&gt;</code> element with an <code>href</code> attribute) elements whose absolute URL matches the element\u2019s own document URL.</p> Syntax <pre><code>:local-link\n</code></pre>"},{"location":"selectors/unsupported/#:past","title":"<code>:past</code>","text":"<p>Selects an element that is defined to occur entirely prior to a <code>:current</code> element.</p> Syntax <pre><code>:past\n</code></pre>"},{"location":"selectors/unsupported/#:paused","title":"<code>:paused</code>","text":"<p>Selects an element that is capable of being played or paused (such as an audio, video, or similar resource) and is currently \"paused\".</p> Syntax <pre><code>:paused\n</code></pre>"},{"location":"selectors/unsupported/#:playing","title":"<code>:playing</code>","text":"<p>Selects an element that is capable of being played or paused (such as an audio, video, or similar resource) and is currently \"playing\".</p> Syntax <pre><code>:playing\n</code></pre>"},{"location":"selectors/unsupported/#:target","title":"<code>:target</code>","text":"<p>Selects a unique element (the target element) with an id matching the URL's fragment.</p> Syntax <pre><code>:target\n</code></pre>"},{"location":"selectors/unsupported/#:target-within","title":"<code>:target-within</code>","text":"<p>Selects a unique element with an id matching the URL's fragment or an element which contains the element.</p> Syntax <pre><code>:target-within\n</code></pre>"},{"location":"selectors/unsupported/#:user-invalid","title":"<code>:user-invalid</code>","text":"<p>Selects an element with incorrect input, but only after the user has significantly interacted with it.</p> Syntax <pre><code>:user-invalid\n</code></pre>"},{"location":"selectors/unsupported/#:visited","title":"<code>:visited</code>","text":"<p>Selects links that have already been visited.</p> Syntax <pre><code>:visited\n</code></pre>"}]}