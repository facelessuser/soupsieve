{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Soup Sieve Overview Soup Sieve is a CSS selector library designed to be used with Beautiful Soup 4 . It aims to provide selecting, matching, and filtering using modern CSS selectors. Soup Sieve currently provides selectors from the CSS level 1 specifications up through the latest CSS level 4 drafts and beyond (though some are not yet implemented). Soup Sieve was written with the intent to replace Beautiful Soup's builtin select feature, and as of Beautiful Soup version 4.7.0, it now is . Soup Sieve can also be imported in order to use its API directly for more controlled, specialized parsing. Soup Sieve has implemented most of the CSS selectors up through the latest CSS draft specifications, though there are a number that don't make sense in a non-browser environment. Selectors that cannot provide meaningful functionality simply do not match anything. Some of the supported selectors are: . classes # ids [ attributes = value ] parent child parent > child sibling ~ sibling sibling + sibling : not ( element . class , element2 . class ) : is ( element . class , element2 . class ) parent : has (> child ) and many more Installation You must have Beautiful Soup already installed: pip install beautifulsoup4 In most cases, assuming you've installed version 4.7.0, that should be all you need to do, but if you've installed via some alternative method, and Soup Sieve is not automatically installed for your, you can install it directly: pip install soupsieve If you want to manually install it from source, navigate to the root of the project and run python setup.py build python setup.py install Usage To use Soup Sieve, you must create a BeautifulSoup object: >>> import bs4 >>> text = \"\"\" ... <div> ... <!-- These are animals --> ... <p class=\"a\">Cat</p> ... <p class=\"b\">Dog</p> ... <p class=\"c\">Mouse</p> ... </div> ... \"\"\" >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) For most people, using the Beautiful Soup 4.7.0+ API may be more than sufficient. Beautiful Soup offers two methods that employ Soup Sieve: select and select_one . Beautiful Soup's select API is identical to Soup Sieve's, except that you don't have to hand it the tag object, the calling object passes itself to Soup Sieve: >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) >>> soup . select_one ( 'p:is(.a, .b, .c)' ) <p class=\"a\">Cat</p> >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) >>> soup . select ( 'p:is(.a, .b, .c)' ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can also use the Soup Sieve API directly to get access to the full range of possibilities that Soup Sieve offers. You can select a single tag: >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p> You can select all tags: >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can select the closest ancestor: >>> import soupsieve as sv >>> el = sv . select_one ( '.c' , soup ) >>> sv . closest ( 'div' , el ) <div> <!-- These are animals --> <p class=\"a\">Cat</p> <p class=\"b\">Dog</p> <p class=\"c\">Mouse</p> </div> You can filter a tag's Children (or an iterable of tags): >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>] You can match a single tag: >>> els = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( els [ 0 ], 'p:not(.b)' ) True >>> sv . match ( els [ 1 ], 'p:not(.b)' ) False Or even just extract comments: >>> sv . comments ( soup ) [' These are animals '] Selectors do not have to be constrained to one line either. You can span selectors over multiple lines just like you would in a CSS file. >>> selector = \"\"\" ... .a, ... .b, ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can even use comments to annotate a particularly complex selector. >>> selector = \"\"\" ... /* This isn't complicated, but we're going to annotate it anyways. ... This is the a class */ ... .a, ... /* This is the b class */ ... .b, ... /* This is the c class */ ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] If you've ever used Python's Re library for regular expressions, you may know that it is often useful to pre-compile a regular expression pattern, especially if you plan to use it more than once. The same is true for Soup Sieve's matchers, though is not required. If you have a pattern that you want to use more than once, it may be wise to pre-compile it early on: >>> selector = sv . compile ( 'p:is(.a, .b, .c)' ) >>> selector . filter ( soup . div ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] A compiled object has all the same methods, though the parameters will be slightly different as they don't need things like the pattern or flags once compiled. See API documentation for more info. Compiled patterns are cached, so if for any reason you need to clear the cache, simply issue the purge command. >>> sv . purge ()","title":"Soup Sieve"},{"location":"#soup-sieve","text":"","title":"Soup Sieve"},{"location":"#overview","text":"Soup Sieve is a CSS selector library designed to be used with Beautiful Soup 4 . It aims to provide selecting, matching, and filtering using modern CSS selectors. Soup Sieve currently provides selectors from the CSS level 1 specifications up through the latest CSS level 4 drafts and beyond (though some are not yet implemented). Soup Sieve was written with the intent to replace Beautiful Soup's builtin select feature, and as of Beautiful Soup version 4.7.0, it now is . Soup Sieve can also be imported in order to use its API directly for more controlled, specialized parsing. Soup Sieve has implemented most of the CSS selectors up through the latest CSS draft specifications, though there are a number that don't make sense in a non-browser environment. Selectors that cannot provide meaningful functionality simply do not match anything. Some of the supported selectors are: . classes # ids [ attributes = value ] parent child parent > child sibling ~ sibling sibling + sibling : not ( element . class , element2 . class ) : is ( element . class , element2 . class ) parent : has (> child ) and many more","title":"Overview"},{"location":"#installation","text":"You must have Beautiful Soup already installed: pip install beautifulsoup4 In most cases, assuming you've installed version 4.7.0, that should be all you need to do, but if you've installed via some alternative method, and Soup Sieve is not automatically installed for your, you can install it directly: pip install soupsieve If you want to manually install it from source, navigate to the root of the project and run python setup.py build python setup.py install","title":"Installation"},{"location":"#usage","text":"To use Soup Sieve, you must create a BeautifulSoup object: >>> import bs4 >>> text = \"\"\" ... <div> ... <!-- These are animals --> ... <p class=\"a\">Cat</p> ... <p class=\"b\">Dog</p> ... <p class=\"c\">Mouse</p> ... </div> ... \"\"\" >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) For most people, using the Beautiful Soup 4.7.0+ API may be more than sufficient. Beautiful Soup offers two methods that employ Soup Sieve: select and select_one . Beautiful Soup's select API is identical to Soup Sieve's, except that you don't have to hand it the tag object, the calling object passes itself to Soup Sieve: >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) >>> soup . select_one ( 'p:is(.a, .b, .c)' ) <p class=\"a\">Cat</p> >>> soup = bs4 . BeautifulSoup ( text , 'html5lib' ) >>> soup . select ( 'p:is(.a, .b, .c)' ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can also use the Soup Sieve API directly to get access to the full range of possibilities that Soup Sieve offers. You can select a single tag: >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p> You can select all tags: >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can select the closest ancestor: >>> import soupsieve as sv >>> el = sv . select_one ( '.c' , soup ) >>> sv . closest ( 'div' , el ) <div> <!-- These are animals --> <p class=\"a\">Cat</p> <p class=\"b\">Dog</p> <p class=\"c\">Mouse</p> </div> You can filter a tag's Children (or an iterable of tags): >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>] You can match a single tag: >>> els = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( els [ 0 ], 'p:not(.b)' ) True >>> sv . match ( els [ 1 ], 'p:not(.b)' ) False Or even just extract comments: >>> sv . comments ( soup ) [' These are animals '] Selectors do not have to be constrained to one line either. You can span selectors over multiple lines just like you would in a CSS file. >>> selector = \"\"\" ... .a, ... .b, ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] You can even use comments to annotate a particularly complex selector. >>> selector = \"\"\" ... /* This isn't complicated, but we're going to annotate it anyways. ... This is the a class */ ... .a, ... /* This is the b class */ ... .b, ... /* This is the c class */ ... .c ... \"\"\" >>> sv . select ( selector , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] If you've ever used Python's Re library for regular expressions, you may know that it is often useful to pre-compile a regular expression pattern, especially if you plan to use it more than once. The same is true for Soup Sieve's matchers, though is not required. If you have a pattern that you want to use more than once, it may be wise to pre-compile it early on: >>> selector = sv . compile ( 'p:is(.a, .b, .c)' ) >>> selector . filter ( soup . div ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] A compiled object has all the same methods, though the parameters will be slightly different as they don't need things like the pattern or flags once compiled. See API documentation for more info. Compiled patterns are cached, so if for any reason you need to clear the cache, simply issue the purge command. >>> sv . purge ()","title":"Usage"},{"location":"api/","text":"API Soup Sieve implements most of the selectors from the stable specification and even many from the latest draft specification. Selectors can be used to detect and filter elements. To learn more about which specific selectors are implemented, see CSS Selectors . Soup Sieve will detect the document type being used from the Beautiful Soup object that is given to it, and depending on the document type, its behavior may be slightly different. When detecting XHTML, Soup Sieve simply looks to see if the root element of an XML document is under the XHTML namespace and does not currently look at the doctype . If in the future there is a need for stricter XHTML detection, this may change. HTML document types (HTML, HTML5) will have their tag names and attribute names treated without case sensitivity, like most browsers do. XML document types (including XHTML) will have their tag names and attribute names treated with case sensitivity. HTML5, XHTML and XML documents will have namespaces evaluated per the document's support (provided via the parser). Some additional configuration is required when using namespaces, see Namespace for more information. Getting Proper Namespaces The html5lib parser provides proper namespaces for HTML5, but lxml 's HTML parser will not. If you need namespace support for HTML5, consider using html5lib . For XML, the lxml-xml parser ( xml for short) will provide proper namespaces. It is generally suggested that lxml-xml is used to parse XHTML documents to take advantage of namespaces. While attribute values are generally treated as case sensitive, HTML5 and HTML treat the type attribute special. The type attribute's value is always case insensitive. This is generally how most browsers treat type . If you need type to be sensitive, you can use the s flag: [ type = \"submit\" s ] . While Soup Sieve access is exposed through Beautiful Soup's API, Soup Sieve's API can always be imported and accessed directly for more controlled tag selection if needed. Flags soupseive.DEBUG Print debug output when parsing a selector. >>> import soupsieve as sv >>> sv . compile ( 'p:has(#id) > span.some-class:contains(text)' , flags = sv . DEBUG ) ## PARSING: 'p:has(#id) > span.some-class:contains(text)' TOKEN: 'tag' --> 'p' at position 0 TOKEN: 'pseudo_class' --> ':has(' at position 1 is_pseudo: True is_open: True is_relative: True TOKEN: 'id' --> '#id' at position 6 TOKEN: 'pseudo_close' --> ')' at position 9 TOKEN: 'combine' --> ' > ' at position 10 TOKEN: 'tag' --> 'span' at position 13 TOKEN: 'class' --> '.some-class' at position 17 TOKEN: 'pseudo_contains' --> ':contains(text)' at position 28 ## END PARSING SoupSieve(pattern='p:has(#id) > span.some-class:contains(text)', namespaces=None, custom=None, flags=1) soupsieve.select_one() def select_one ( select , tag , namespaces = None , flags = 0 , ** kwargs ): \"\"\"Select the specified tags.\"\"\" select_one will return the first tag under the given tag that matches the given CSS selectors provided, or it will return None if a suitable tag was not found. select_one accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags . >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p> soupsieve.select() def select ( select , tag , namespaces = None , limit = 0 , flags = 0 , ** kwargs ): \"\"\"Select the specified tags.\"\"\" select will return all tags under the given tag that match the given CSS selectors provided. You can also limit the number of tags returned by providing a positive integer via the limit parameter (0 means to return all tags). select accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, a limit , and flags . >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>] soupsieve.iselect() def iselect ( select , node , namespaces = None , limit = 0 , flags = 0 , ** kwargs ): \"\"\"Select the specified tags.\"\"\" iselect is exactly like select except that it returns a generator instead of a list. soupsieve.closest() def closest ( select , tag , namespaces = None , flags = 0 , ** kwargs ): \"\"\"Match closest ancestor to the provided tag.\"\"\" closest returns the tag closest to the given tag that matches the given selector. The element found must be a direct ancestor of the tag or the tag itself. closest accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags . soupsieve.match() def match ( select , tag , namespaces = None , flags = 0 , ** kwargs ): \"\"\"Match node.\"\"\" The match function matches a given tag with a given CSS selector. match accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags. >>> nodes = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( 'p:not(.b)' , nodes [ 0 ]) True >>> sv . match ( 'p:not(.b)' , nodes [ 1 ]) False soupsieve.filter() def filter ( select , nodes , namespaces = None , flags = 0 , ** kwargs ): \"\"\"Filter list of nodes.\"\"\" filter takes an iterable containing HTML nodes and will filter them based on the provided CSS selector string. If given a Tag / BeautifulSoup object, it will iterate the direct children filtering them. filter accepts a CSS selector string, an iterable containing nodes, an optional namespace dictionary, and flags. >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>] soupsieve.escape() def escape ( ident ): \"\"\"Escape CSS identifier.\"\"\" escape is used to escape CSS identifiers. It follows the CSS specification and escapes any character that would normally cause an identifier to be invalid. >>> sv . escape ( \".foo#bar\" ) '\\\\.foo\\\\#bar' >>> sv . escape ( \"()[] {} \" ) '\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}' >>> sv . escape ( '--a' ) '--a' >>> sv . escape ( '0' ) '\\\\30 ' >>> sv . escape ( ' \\0 ' ) '\ufffd' New in 1.9.0 escape is a new API function added in 1.9.0. soupsieve.compile() def compile ( pattern , namespaces = None , flags = 0 , ** kwargs ): \"\"\"Compile CSS pattern.\"\"\" compile will pre-compile a CSS selector pattern returning a SoupSieve object. The SoupSieve object has the same selector functions available via the module without the need to specify the selector, namespaces, or flags. class SoupSieve : \"\"\"Match tags in Beautiful Soup with CSS selectors.\"\"\" def match ( self , tag ): \"\"\"Match.\"\"\" def closest ( self , tag ): \"\"\"Match closest ancestor.\"\"\" def filter ( self , iterable ): \"\"\"Filter.\"\"\" def select_one ( self , tag ): \"\"\"Select a single tag.\"\"\" def select ( self , tag , limit = 0 ): \"\"\"Select the specified tags.\"\"\" def iselect ( self , tag , limit = 0 ): \"\"\"Iterate the specified tags.\"\"\" soupsieve.purge() Soup Sieve caches compiled patterns for performance. If for whatever reason, you need to purge the cache, simply call purge . Custom Selectors The custom selector feature is loosely inspired by the css-extensions proposal . In its current form, Soup Sieve allows assigning a complex selector to a custom pseudo-class name. The pseudo-class name must start with :-- to avoid conflicts with any future pseudo-classes. To create custom selectors, you simply need to pass a dictionary containing the custom pseudo-class names (keys) with the associated CSS selectors that the pseudo-classes are meant to represent (values). It is important to remember that pseudo-class names are not case sensitive, so even though a dictionary will allow you to specify multiple keys with the same name (as long as the character cases are different), Soup Sieve will not and will throw an exception if you attempt to do so. In the following example, we will define our own custom selector called : --header that will be an alias for h1 , h2 , h3 , h4 , h5 , h6 . import soupsieve as sv import bs4 markup = \"\"\" <html> <body> <h1 id=\"1\">Header 1</h1> <h2 id=\"2\">Header 2</h2> <p id=\"3\"></p> <p id=\"4\"><span>child</span></p> </body> </html \"\"\" soup = bs4 . BeautifulSoup ( markup , 'lxml' ) print ( sv . select ( ':--header' , soup , custom = { ':--header' : 'h1, h2, h3, h4, h5, h6' })) The above code, when run, should yield the following output: [<h1 id=\"1\">Header 1</h1>, <h2 id=\"2\">Header 2</h2>] Custom selectors can also be dependent upon other custom selectors. You don't have to worry about the order in the dictionary as custom selectors will be compiled \"just in time\" when they are needed. Be careful though, if you create a circular dependency, you will get a SelectorSyntaxError . Assuming the same markup as in the first example, we will now create a custom selector that should find any element that has child elements, we will call the selector :--parent . Then we will create another selector called :--parent-paragraph that will use the :--parent selector to find < p > elements that are also parents: custom = { \":--parent\" : \":has(> *|*)\" , \":--parent-paragraph\" : \"p:--parent\" } print ( sv . select ( ':--parent-paragraph' , soup , custom = custom )) The above code will yield the only paragraph that is a parent: [<p id=\"4\"><span>child</span></p>] Namespaces Many of Soup Sieve's selector functions take an optional namespace dictionary. Namespaces, just like CSS, must be defined for Soup Sieve to evaluate ns|tag type selectors. This is analogous to CSS's namespace at-rule: @ namespace url ( \"http://www.w3.org/1999/xhtml\" ) ; @ namespace svg url ( \"http://www.w3.org/2000/svg\" ) ; A namespace dictionary should have keys (prefixes) and values (namespaces). An empty key string for a key would denote the default key. An empty value would essentially represent a null namespace. To represent the above CSS example for Soup Sieve, we would configure it like so: namespace = { \"\" : \"http://www.w3.org/1999/xhtml\" , # Default namespace is for XHTML \"svg\" : \"http://www.w3.org/2000/svg\" , # The SVG namespace defined with prefix of \"svg\" } Prefixes used in the namespace dictionary do not have to match the prefixes in the document. The provided prefix is never compared against the prefixes in the document, only the namespaces are compared. The prefixes in the document are only there for the parser to know which tags get which namespace. And the prefixes in the namespace dictionary are only defined in order to provide an alias for the namespaces when using the namespace selector syntax: ns|name . Tags do not necessarily have to have a prefix for Soup Sieve to recognize them either. For instance, in HTML5, SVG should automatically get the SVG namespace. Depending how namespaces were defined in the document, tags may inherit namespaces in some conditions. Namespace assignment is mainly handled by the parser and exposed through the Beautiful Soup API. Soup Sieve uses the Beautiful Soup API to then compare namespaces for supported documents.","title":"API"},{"location":"api/#api","text":"Soup Sieve implements most of the selectors from the stable specification and even many from the latest draft specification. Selectors can be used to detect and filter elements. To learn more about which specific selectors are implemented, see CSS Selectors . Soup Sieve will detect the document type being used from the Beautiful Soup object that is given to it, and depending on the document type, its behavior may be slightly different. When detecting XHTML, Soup Sieve simply looks to see if the root element of an XML document is under the XHTML namespace and does not currently look at the doctype . If in the future there is a need for stricter XHTML detection, this may change. HTML document types (HTML, HTML5) will have their tag names and attribute names treated without case sensitivity, like most browsers do. XML document types (including XHTML) will have their tag names and attribute names treated with case sensitivity. HTML5, XHTML and XML documents will have namespaces evaluated per the document's support (provided via the parser). Some additional configuration is required when using namespaces, see Namespace for more information. Getting Proper Namespaces The html5lib parser provides proper namespaces for HTML5, but lxml 's HTML parser will not. If you need namespace support for HTML5, consider using html5lib . For XML, the lxml-xml parser ( xml for short) will provide proper namespaces. It is generally suggested that lxml-xml is used to parse XHTML documents to take advantage of namespaces. While attribute values are generally treated as case sensitive, HTML5 and HTML treat the type attribute special. The type attribute's value is always case insensitive. This is generally how most browsers treat type . If you need type to be sensitive, you can use the s flag: [ type = \"submit\" s ] . While Soup Sieve access is exposed through Beautiful Soup's API, Soup Sieve's API can always be imported and accessed directly for more controlled tag selection if needed.","title":"API"},{"location":"api/#flags","text":"","title":"Flags"},{"location":"api/#soupseivedebug","text":"Print debug output when parsing a selector. >>> import soupsieve as sv >>> sv . compile ( 'p:has(#id) > span.some-class:contains(text)' , flags = sv . DEBUG ) ## PARSING: 'p:has(#id) > span.some-class:contains(text)' TOKEN: 'tag' --> 'p' at position 0 TOKEN: 'pseudo_class' --> ':has(' at position 1 is_pseudo: True is_open: True is_relative: True TOKEN: 'id' --> '#id' at position 6 TOKEN: 'pseudo_close' --> ')' at position 9 TOKEN: 'combine' --> ' > ' at position 10 TOKEN: 'tag' --> 'span' at position 13 TOKEN: 'class' --> '.some-class' at position 17 TOKEN: 'pseudo_contains' --> ':contains(text)' at position 28 ## END PARSING SoupSieve(pattern='p:has(#id) > span.some-class:contains(text)', namespaces=None, custom=None, flags=1)","title":"soupseive.DEBUG"},{"location":"api/#soupsieveselect_one","text":"def select_one ( select , tag , namespaces = None , flags = 0 , ** kwargs ): \"\"\"Select the specified tags.\"\"\" select_one will return the first tag under the given tag that matches the given CSS selectors provided, or it will return None if a suitable tag was not found. select_one accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags . >>> import soupsieve as sv >>> sv . select_one ( 'p:is(.a, .b, .c)' , soup ) <p class=\"a\">Cat</p>","title":"soupsieve.select_one()"},{"location":"api/#soupsieveselect","text":"def select ( select , tag , namespaces = None , limit = 0 , flags = 0 , ** kwargs ): \"\"\"Select the specified tags.\"\"\" select will return all tags under the given tag that match the given CSS selectors provided. You can also limit the number of tags returned by providing a positive integer via the limit parameter (0 means to return all tags). select accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, a limit , and flags . >>> import soupsieve as sv >>> sv . select ( 'p:is(.a, .b, .c)' , soup ) [<p class=\"a\">Cat</p>, <p class=\"b\">Dog</p>, <p class=\"c\">Mouse</p>]","title":"soupsieve.select()"},{"location":"api/#soupsieveiselect","text":"def iselect ( select , node , namespaces = None , limit = 0 , flags = 0 , ** kwargs ): \"\"\"Select the specified tags.\"\"\" iselect is exactly like select except that it returns a generator instead of a list.","title":"soupsieve.iselect()"},{"location":"api/#soupsieveclosest","text":"def closest ( select , tag , namespaces = None , flags = 0 , ** kwargs ): \"\"\"Match closest ancestor to the provided tag.\"\"\" closest returns the tag closest to the given tag that matches the given selector. The element found must be a direct ancestor of the tag or the tag itself. closest accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags .","title":"soupsieve.closest()"},{"location":"api/#soupsievematch","text":"def match ( select , tag , namespaces = None , flags = 0 , ** kwargs ): \"\"\"Match node.\"\"\" The match function matches a given tag with a given CSS selector. match accepts a CSS selector string, a Tag / BeautifulSoup object, an optional namespace dictionary, and flags. >>> nodes = sv . select ( 'p:is(.a, .b, .c)' , soup ) >>> sv . match ( 'p:not(.b)' , nodes [ 0 ]) True >>> sv . match ( 'p:not(.b)' , nodes [ 1 ]) False","title":"soupsieve.match()"},{"location":"api/#soupsievefilter","text":"def filter ( select , nodes , namespaces = None , flags = 0 , ** kwargs ): \"\"\"Filter list of nodes.\"\"\" filter takes an iterable containing HTML nodes and will filter them based on the provided CSS selector string. If given a Tag / BeautifulSoup object, it will iterate the direct children filtering them. filter accepts a CSS selector string, an iterable containing nodes, an optional namespace dictionary, and flags. >>> sv . filter ( 'p:not(.b)' , soup . div ) [<p class=\"a\">Cat</p>, <p class=\"c\">Mouse</p>]","title":"soupsieve.filter()"},{"location":"api/#soupsieveescape","text":"def escape ( ident ): \"\"\"Escape CSS identifier.\"\"\" escape is used to escape CSS identifiers. It follows the CSS specification and escapes any character that would normally cause an identifier to be invalid. >>> sv . escape ( \".foo#bar\" ) '\\\\.foo\\\\#bar' >>> sv . escape ( \"()[] {} \" ) '\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}' >>> sv . escape ( '--a' ) '--a' >>> sv . escape ( '0' ) '\\\\30 ' >>> sv . escape ( ' \\0 ' ) '\ufffd' New in 1.9.0 escape is a new API function added in 1.9.0.","title":"soupsieve.escape()"},{"location":"api/#soupsievecompile","text":"def compile ( pattern , namespaces = None , flags = 0 , ** kwargs ): \"\"\"Compile CSS pattern.\"\"\" compile will pre-compile a CSS selector pattern returning a SoupSieve object. The SoupSieve object has the same selector functions available via the module without the need to specify the selector, namespaces, or flags. class SoupSieve : \"\"\"Match tags in Beautiful Soup with CSS selectors.\"\"\" def match ( self , tag ): \"\"\"Match.\"\"\" def closest ( self , tag ): \"\"\"Match closest ancestor.\"\"\" def filter ( self , iterable ): \"\"\"Filter.\"\"\" def select_one ( self , tag ): \"\"\"Select a single tag.\"\"\" def select ( self , tag , limit = 0 ): \"\"\"Select the specified tags.\"\"\" def iselect ( self , tag , limit = 0 ): \"\"\"Iterate the specified tags.\"\"\"","title":"soupsieve.compile()"},{"location":"api/#soupsievepurge","text":"Soup Sieve caches compiled patterns for performance. If for whatever reason, you need to purge the cache, simply call purge .","title":"soupsieve.purge()"},{"location":"api/#custom-selectors","text":"The custom selector feature is loosely inspired by the css-extensions proposal . In its current form, Soup Sieve allows assigning a complex selector to a custom pseudo-class name. The pseudo-class name must start with :-- to avoid conflicts with any future pseudo-classes. To create custom selectors, you simply need to pass a dictionary containing the custom pseudo-class names (keys) with the associated CSS selectors that the pseudo-classes are meant to represent (values). It is important to remember that pseudo-class names are not case sensitive, so even though a dictionary will allow you to specify multiple keys with the same name (as long as the character cases are different), Soup Sieve will not and will throw an exception if you attempt to do so. In the following example, we will define our own custom selector called : --header that will be an alias for h1 , h2 , h3 , h4 , h5 , h6 . import soupsieve as sv import bs4 markup = \"\"\" <html> <body> <h1 id=\"1\">Header 1</h1> <h2 id=\"2\">Header 2</h2> <p id=\"3\"></p> <p id=\"4\"><span>child</span></p> </body> </html \"\"\" soup = bs4 . BeautifulSoup ( markup , 'lxml' ) print ( sv . select ( ':--header' , soup , custom = { ':--header' : 'h1, h2, h3, h4, h5, h6' })) The above code, when run, should yield the following output: [<h1 id=\"1\">Header 1</h1>, <h2 id=\"2\">Header 2</h2>] Custom selectors can also be dependent upon other custom selectors. You don't have to worry about the order in the dictionary as custom selectors will be compiled \"just in time\" when they are needed. Be careful though, if you create a circular dependency, you will get a SelectorSyntaxError . Assuming the same markup as in the first example, we will now create a custom selector that should find any element that has child elements, we will call the selector :--parent . Then we will create another selector called :--parent-paragraph that will use the :--parent selector to find < p > elements that are also parents: custom = { \":--parent\" : \":has(> *|*)\" , \":--parent-paragraph\" : \"p:--parent\" } print ( sv . select ( ':--parent-paragraph' , soup , custom = custom )) The above code will yield the only paragraph that is a parent: [<p id=\"4\"><span>child</span></p>]","title":"Custom Selectors"},{"location":"api/#namespaces","text":"Many of Soup Sieve's selector functions take an optional namespace dictionary. Namespaces, just like CSS, must be defined for Soup Sieve to evaluate ns|tag type selectors. This is analogous to CSS's namespace at-rule: @ namespace url ( \"http://www.w3.org/1999/xhtml\" ) ; @ namespace svg url ( \"http://www.w3.org/2000/svg\" ) ; A namespace dictionary should have keys (prefixes) and values (namespaces). An empty key string for a key would denote the default key. An empty value would essentially represent a null namespace. To represent the above CSS example for Soup Sieve, we would configure it like so: namespace = { \"\" : \"http://www.w3.org/1999/xhtml\" , # Default namespace is for XHTML \"svg\" : \"http://www.w3.org/2000/svg\" , # The SVG namespace defined with prefix of \"svg\" } Prefixes used in the namespace dictionary do not have to match the prefixes in the document. The provided prefix is never compared against the prefixes in the document, only the namespaces are compared. The prefixes in the document are only there for the parser to know which tags get which namespace. And the prefixes in the namespace dictionary are only defined in order to provide an alias for the namespaces when using the namespace selector syntax: ns|name . Tags do not necessarily have to have a prefix for Soup Sieve to recognize them either. For instance, in HTML5, SVG should automatically get the SVG namespace. Depending how namespaces were defined in the document, tags may inherit namespaces in some conditions. Namespace assignment is mainly handled by the parser and exposed through the Beautiful Soup API. Soup Sieve uses the Beautiful Soup API to then compare namespaces for supported documents.","title":"Namespaces"},{"location":"differences/","text":"Beautiful Soup Differences Soup Sieve is the official CSS \"select\" implementation of Beautiful Soup 4.7.0+. While the inclusion of Soup Sieve fixes many issues and greatly expands CSS support in Beautiful Soup, it does introduce some differences which may surprise some who've become accustom to the old \"select\" implementation. Beautiful Soup's old select method had numerous limitations and quirks that do not align with the actual CSS specifications. Most are insignificant, but there are a couple differences that people over the years had come to rely on. Soup Sieve, which aims to follow the CSS specification closely, does not support these differences. Attribute Values Beautiful Soup was very relaxed when it came to attribute values in selectors: [ attribute = value ] . Beautiful Soup would allow almost anything for a valid unquoted value. Soup Sieve, on the other hand, follows the CSS specification and requires that a value be a valid identifier, or it must be quoted. If you get an error complaining about a malformed attribute, you may need to quote the value. For instance, if you previously used a selector like this: soup . select ( '[attr= {} ]' ) You would need to quote the value as {} is not a valid CSS identifier, so it must be quoted: soup . select ( '[attr=\" {} \"]' ) You can also use the escape function to escape dynamic content: import soupsieve soup . select ( '[attr= %s ]' % soupsieve . escape ( ' {} ' )) CSS Identifiers Since Soup Sieve follows the CSS specification, class names, id names, tag names, etc. must be valid identifiers. Since identifiers, according to the CSS specification, cannot start with a number, some users may find that their old class, id, or tag name selectors that started with numbers will not work. To specify such selectors, you'll have to use CSS escapes. So if you used to use: soup . select ( '.2class' ) You would need to update with: soup . select ( r '.\\32 class' ) Numbers in the middle or at the end of a class will work as they always did: soup . select ( '.class2' ) Relative Selectors Whether on purpose or on accident, Beautiful Soup used to allow relative selectors: soup . select ( '> div' ) The above is not a valid CSS selector according the CSS specifications. Relative selector lists have only recently been added to the CSS specifications, and they are only allowed in a : has () pseudo-class: article : has (> div ) But, in the level 4 CSS specifications, the :scope pseudo-class has been added which allows for the same feel as using > div . Since Soup Sieve supports the :scope pseudo-class, it can be used to produce the same behavior as the legacy select method. In CSS, the :scope pseudo-class represents the element that the CSS select operation is called on. In supported browsers, the following JavaScript example would treats :scope as the element that el references: el . querySelectorAll ( ':scope > .class' ) Just like in the JavaScript example above, Soup Sieve would also treat :scope as the element that el references: el . select ( ':scope > .class' ) In the case where the element is the document node, :scope would simply represent the root element of the document. So, if you used to to have selectors such as: soup . select ( '> div' ) You can simply add :scope , and it should work the same: soup . select ( ':scope > div' ) While this will generally give you what is expected for the relative, descendant selectors, this will not work for sibling selectors, and the reasons why are covered in more details in Out of Scope Selectors . Out of Scope Selectors In a browser, when requesting a selector via querySelectorAll , the element that querySelectorAll is called on is the scoped element. So in the following example, el is the scoped element. el . querySelectorAll ( '.class' ) This same concept applies to Soup Sieve, where the element that select or select_one is called on is also the scoped element. So in the following example, el is also the scoped element: el . select ( '.class' ) In browsers, querySelectorAll and querySelector only return elements under the scoped element. They do not return the scoped element itself, its parents, or its siblings. Only when querySelectorAll or querySelector is called on the document node will it return the scoped selector, which would be the root element, as the query is being called on the document itself and not the scoped element. Soup Sieve aims to essentially mimic the browser functions such as querySelector , querySelectorAll , matches , etc. In Soup Sieve select and select_one are analogous to querySelectorAll and querySelector respectively. For this reason, Soup Sieve also only returns elements under the scoped element. The idea is to provide a familiar interface that behaves, as close as possible, to what people familiar with CSS selectors are used to. So while Soup Sieve will find elements relative to :scope with > or : soup . select ( ':scope > div' ) It will not find elements relative to :scope with + or ~ as siblings to the scoped element are not under the scoped element: soup . select ( ':scope + div' ) This is by design and is in align with the behavior exhibited in all web browsers. Selected Element Order Another quirk of Beautiful Soup's old implementation was that it returned the HTML nodes in the order of how the selectors were defined. For instance, Beautiful Soup, if given the pattern article , body would first return < article > and then < body > . Soup Sieve does not, and frankly cannot, honor Beautiful Soup's old ordering convention due to the way it is designed. Soup Sieve returns the nodes in the order they are defined in the document as that is how the elements are searched. This much more efficient and provides better performance. So, given the earlier selector pattern of article, body , Soup Sieve would return the element < body > and then < article > as that is how it is ordered in the HTML document.","title":"Beautiful Soup Differences"},{"location":"differences/#beautiful-soup-differences","text":"Soup Sieve is the official CSS \"select\" implementation of Beautiful Soup 4.7.0+. While the inclusion of Soup Sieve fixes many issues and greatly expands CSS support in Beautiful Soup, it does introduce some differences which may surprise some who've become accustom to the old \"select\" implementation. Beautiful Soup's old select method had numerous limitations and quirks that do not align with the actual CSS specifications. Most are insignificant, but there are a couple differences that people over the years had come to rely on. Soup Sieve, which aims to follow the CSS specification closely, does not support these differences.","title":"Beautiful Soup Differences"},{"location":"differences/#attribute-values","text":"Beautiful Soup was very relaxed when it came to attribute values in selectors: [ attribute = value ] . Beautiful Soup would allow almost anything for a valid unquoted value. Soup Sieve, on the other hand, follows the CSS specification and requires that a value be a valid identifier, or it must be quoted. If you get an error complaining about a malformed attribute, you may need to quote the value. For instance, if you previously used a selector like this: soup . select ( '[attr= {} ]' ) You would need to quote the value as {} is not a valid CSS identifier, so it must be quoted: soup . select ( '[attr=\" {} \"]' ) You can also use the escape function to escape dynamic content: import soupsieve soup . select ( '[attr= %s ]' % soupsieve . escape ( ' {} ' ))","title":"Attribute Values"},{"location":"differences/#css-identifiers","text":"Since Soup Sieve follows the CSS specification, class names, id names, tag names, etc. must be valid identifiers. Since identifiers, according to the CSS specification, cannot start with a number, some users may find that their old class, id, or tag name selectors that started with numbers will not work. To specify such selectors, you'll have to use CSS escapes. So if you used to use: soup . select ( '.2class' ) You would need to update with: soup . select ( r '.\\32 class' ) Numbers in the middle or at the end of a class will work as they always did: soup . select ( '.class2' )","title":"CSS Identifiers"},{"location":"differences/#relative-selectors","text":"Whether on purpose or on accident, Beautiful Soup used to allow relative selectors: soup . select ( '> div' ) The above is not a valid CSS selector according the CSS specifications. Relative selector lists have only recently been added to the CSS specifications, and they are only allowed in a : has () pseudo-class: article : has (> div ) But, in the level 4 CSS specifications, the :scope pseudo-class has been added which allows for the same feel as using > div . Since Soup Sieve supports the :scope pseudo-class, it can be used to produce the same behavior as the legacy select method. In CSS, the :scope pseudo-class represents the element that the CSS select operation is called on. In supported browsers, the following JavaScript example would treats :scope as the element that el references: el . querySelectorAll ( ':scope > .class' ) Just like in the JavaScript example above, Soup Sieve would also treat :scope as the element that el references: el . select ( ':scope > .class' ) In the case where the element is the document node, :scope would simply represent the root element of the document. So, if you used to to have selectors such as: soup . select ( '> div' ) You can simply add :scope , and it should work the same: soup . select ( ':scope > div' ) While this will generally give you what is expected for the relative, descendant selectors, this will not work for sibling selectors, and the reasons why are covered in more details in Out of Scope Selectors .","title":"Relative Selectors"},{"location":"differences/#out-of-scope-selectors","text":"In a browser, when requesting a selector via querySelectorAll , the element that querySelectorAll is called on is the scoped element. So in the following example, el is the scoped element. el . querySelectorAll ( '.class' ) This same concept applies to Soup Sieve, where the element that select or select_one is called on is also the scoped element. So in the following example, el is also the scoped element: el . select ( '.class' ) In browsers, querySelectorAll and querySelector only return elements under the scoped element. They do not return the scoped element itself, its parents, or its siblings. Only when querySelectorAll or querySelector is called on the document node will it return the scoped selector, which would be the root element, as the query is being called on the document itself and not the scoped element. Soup Sieve aims to essentially mimic the browser functions such as querySelector , querySelectorAll , matches , etc. In Soup Sieve select and select_one are analogous to querySelectorAll and querySelector respectively. For this reason, Soup Sieve also only returns elements under the scoped element. The idea is to provide a familiar interface that behaves, as close as possible, to what people familiar with CSS selectors are used to. So while Soup Sieve will find elements relative to :scope with > or : soup . select ( ':scope > div' ) It will not find elements relative to :scope with + or ~ as siblings to the scoped element are not under the scoped element: soup . select ( ':scope + div' ) This is by design and is in align with the behavior exhibited in all web browsers.","title":"Out of Scope Selectors"},{"location":"differences/#selected-element-order","text":"Another quirk of Beautiful Soup's old implementation was that it returned the HTML nodes in the order of how the selectors were defined. For instance, Beautiful Soup, if given the pattern article , body would first return < article > and then < body > . Soup Sieve does not, and frankly cannot, honor Beautiful Soup's old ordering convention due to the way it is designed. Soup Sieve returns the nodes in the order they are defined in the document as that is how the elements are searched. This much more efficient and provides better performance. So, given the earlier selector pattern of article, body , Soup Sieve would return the element < body > and then < article > as that is how it is ordered in the HTML document.","title":"Selected Element Order"},{"location":"faq/","text":"Frequent Asked Questions Why do selectors not work the same in Beautiful Soup 4.7+? Soup Sieve is the official CSS selector library in Beautiful Soup 4.7+, and with this change, Soup Sieve introduces a number of changes that break some of the expected behaviors that existed in versions prior to 4.7. In short, Soup Sieve follows the CSS specifications fairly close, and this broke a number of non-standard behaviors. These non-standard behaviors were not allowed according to the CSS specifications. Soup Sieve has no intentions of bringing back these behaviors. For more details on specific changes, and the reasoning why a specific change is considered a good change, or simply a feature that Soup Sieve cannot/will not support, see Beautiful Soup Differences . How does iframe handling work? In web browsers, CSS selectors do not usually select content inside an iframe element if the selector is called on an element outside of the iframe . Each HTML document is usually encapsulated and CSS selector leakage across this iframe boundary is usually prevented. In it's current iteration, Soup Sieve is not aware of the origin of the documents in the iframe , and Soup Sieve will not prevent selectors from crossing these boundaries. Soup Sieve is not used to style documents, but to scrape documents. For this reason, it seems to be more helpful to allow selector combinators to cross these boundaries. Soup Sieve isn't entirely unaware of iframe elements though. In Soup Sieve 1.9.1, it was noticed that some pseudo-classes behaved in unexpected ways without awareness to iframes , this was fixed in 1.9.1. Pseudo-classes such as :default , :indeterminate , :dir() , :lang() , :root , and :contains() where given awareness of iframes to ensure they behaved properly and returned the expected elements. This doesn't mean that select won't return elements in iframes , but it won't allow something like :default to select a button in an iframe whose parent form is outside the iframe . Or better put, a default button will be evaluated in the context of the document it is in. With all of this said, if your selectors have issues with iframes , it is most likely because iframes are handled differently by different parsers. html.parser will usually parse iframe elements as it sees them. lxml parser will often remove html and body tags of an iframe HTML document. lxml-xml will simply ignore the content in a XHTML document. And html5lib will HTML escape the content of an iframe making traversal impossible. In short, Soup Sieve will return elements from all documents, even iframes . But certain pseudo-classes may take into consideration the context of the document they are in. But even with all of this, a parser's handling of iframes may make handling its content difficult if it doesn't parse it as HTML elements, or augments its structure.","title":"F.A.Q."},{"location":"faq/#frequent-asked-questions","text":"","title":"Frequent Asked Questions"},{"location":"faq/#why-do-selectors-not-work-the-same-in-beautiful-soup-47","text":"Soup Sieve is the official CSS selector library in Beautiful Soup 4.7+, and with this change, Soup Sieve introduces a number of changes that break some of the expected behaviors that existed in versions prior to 4.7. In short, Soup Sieve follows the CSS specifications fairly close, and this broke a number of non-standard behaviors. These non-standard behaviors were not allowed according to the CSS specifications. Soup Sieve has no intentions of bringing back these behaviors. For more details on specific changes, and the reasoning why a specific change is considered a good change, or simply a feature that Soup Sieve cannot/will not support, see Beautiful Soup Differences .","title":"Why do selectors not work the same in Beautiful Soup 4.7+?"},{"location":"faq/#how-does-iframe-handling-work","text":"In web browsers, CSS selectors do not usually select content inside an iframe element if the selector is called on an element outside of the iframe . Each HTML document is usually encapsulated and CSS selector leakage across this iframe boundary is usually prevented. In it's current iteration, Soup Sieve is not aware of the origin of the documents in the iframe , and Soup Sieve will not prevent selectors from crossing these boundaries. Soup Sieve is not used to style documents, but to scrape documents. For this reason, it seems to be more helpful to allow selector combinators to cross these boundaries. Soup Sieve isn't entirely unaware of iframe elements though. In Soup Sieve 1.9.1, it was noticed that some pseudo-classes behaved in unexpected ways without awareness to iframes , this was fixed in 1.9.1. Pseudo-classes such as :default , :indeterminate , :dir() , :lang() , :root , and :contains() where given awareness of iframes to ensure they behaved properly and returned the expected elements. This doesn't mean that select won't return elements in iframes , but it won't allow something like :default to select a button in an iframe whose parent form is outside the iframe . Or better put, a default button will be evaluated in the context of the document it is in. With all of this said, if your selectors have issues with iframes , it is most likely because iframes are handled differently by different parsers. html.parser will usually parse iframe elements as it sees them. lxml parser will often remove html and body tags of an iframe HTML document. lxml-xml will simply ignore the content in a XHTML document. And html5lib will HTML escape the content of an iframe making traversal impossible. In short, Soup Sieve will return elements from all documents, even iframes . But certain pseudo-classes may take into consideration the context of the document they are in. But even with all of this, a parser's handling of iframes may make handling its content difficult if it doesn't parse it as HTML elements, or augments its structure.","title":"How does iframe handling work?"},{"location":"about/changelog/","text":"2.0.1 FIX : Remove unused code. 2.0.0 NEW : SelectorSyntaxError is derived from Exception not SyntaxError . NEW : Remove deprecated comments and icomments from the API. NEW : Drop support for EOL Python versions (Python 2 and Python < 3.5). FIX : Corner case with splitting namespace and tag name that that have an escaped | . 1.9.6 Last version for Python 2.7 FIX : Prune dead code. FIX : Corner case with splitting namespace and tag name that that have an escaped | . 1.9.5 FIX : :placeholder-shown should not match if the element has content that overrides the placeholder. 1.9.4 FIX : :checked rule was too strict with option elements. The specification for :checked does not require an option element to be under a select element. FIX : Fix level 4 :lang() wildcard match handling with singletons. Implicit wildcard matching should not match any singleton. Explicit wildcard matching ( * in the language range: *-US ) is allowed to match singletons. 1.9.3 FIX : [attr!=value] pattern was mistakenly using :not([attr|=value]) logic instead of :not([attr=value]) . FIX : Remove undocumented _QUIRKS mode flag. Beautiful Soup was meant to use it to help with transition to Soup Sieve, but never released with it. Help with transition at this point is no longer needed. 1.9.2 FIX : Shortcut last descendant calculation if possible for performance. FIX : Fix issue where Doctype strings can be mistaken for a normal text node in some cases. FIX : A top level tag is not a :root tag if it has sibling text nodes or tag nodes. This is an issue that mostly manifests when using html.parser as the parser will allow multiple root nodes. 1.9.1 FIX : :root , :contains() , :default , :indeterminate , :lang() , and :dir() will properly account for HTML iframe elements in their logic when selecting or matching an element. Their logic will be restricted to the document for which the element under consideration applies. FIX : HTML pseudo-classes will check that all key elements checked are in the XHTML namespace (HTML parsers that do not provide namespaces will assume the XHTML namespace). FIX : Ensure that all pseudo-class names are case insensitive and allow CSS escapes. 1.9.0 NEW : Allow :contains() to accept a list of text to search for. ( #115 ) NEW : Add new escape function for escaping CSS identifiers. ( #125 ) NEW : Deprecate comments and icomments functions in the API to ensure Soup Sieve focuses only on CSS selectors. comments and icomments will most likely be removed in 2.0. ( #130 ) NEW : Add Python 3.8 support. ( #133 ) FIX : Don't install test files when installing the soupsieve package. ( #111 ) FIX : Improve efficiency of :contains() comparison. FIX : Null characters should translate to the Unicode REPLACEMENT CHARACTER ( U+FFFD ) according to the specification. This applies to CSS escaped NULL characters as well. ( #124 ) FIX : Escaped EOF should translate to U+FFFD outside of CSS strings. In a string, they should just be ignored, but as there is no case where we could resolve such a string and still have a valid selector, string handling remains the same. ( #128 ) 1.8.0 NEW : Add custom selector support. ( #92 )( #108 ) FIX : Small tweak to CSS identifier pattern to ensure it matches the CSS specification exactly. Specifically, you can't have an identifier of only - . ( #107 ) FIX : CSS string patterns should allow escaping newlines to span strings across multiple lines. ( #107 ) FIX : Newline regular expression for CSS newlines should treat \\r\\n as a single character, especially in cases such as string escapes: \\\\\\r\\n . ( #107 ) FIX : Allow -- as a valid identifier or identifier start. ( #107 ) FIX : Bad CSS syntax now raises a SelectorSyntaxError , which is still currently derived from SyntaxError , but will most likely be derived from Exception in the future. 1.7.3 FIX : Fix regression with tag names in regards to case sensitivity, and ensure there are tests to prevent breakage in the future. FIX : XHTML should always be case sensitive like XML. 1.7.2 FIX : Fix HTML detection type selector. FIX : Fixes for :enabled and :disabled . FIX : Provide a way for Beautiful Soup to parse selectors in a quirks mode to mimic some of the quirks of the old select method prior to Soup Sieve, but with warnings. This is to help old scripts to not break during the transitional period with newest Beautiful Soup. In the future, these quirks will raise an exception as Soup Sieve requires selectors to follow the CSS specification. 1.7.1 FIX : Fix issue with :has() selector where a leading combinator can only be provided in the first selector in a relative selector list. 1.7.0 NEW : Add support for :in-range and :out-of-range selectors. ( #60 ) NEW : Add support for :defined selector. ( #76 ) FIX : Fix pickling issue when compiled selector contains a NullSelector object. ( #70 ) FIX : Better exception messages in the CSS selector parser and fix a position reporting issue that can occur in some exceptions. ( #72 , #73 ) FIX : Don't compare prefixes when evaluating attribute namespaces, compare the actual namespace. ( #75 ) FIX : Split whitespace attribute lists by all whitespace characters, not just space. FIX : :nth-* patterns were converting numbers to base 16 when they should have been converting to base 10. 1.6.2 FIX : Fix pattern compile issues on Python < 2.7.4. FIX : Don't use \\d in Unicode Re patterns as they will contain characters outside the range of [0-9] . 1.6.1 FIX : Fix warning about not importing Mapping from collections.abc . 1.6.0 NEW : Add closest method to the API that matches closest ancestor. FIX : Add missing select_one reference to module's __all__ . 1.5.0 NEW : Add select_one method like Beautiful Soup has. NEW : Add :dir() selector (HTML only). FIX : Fix issues when handling HTML fragments (elements without a BeautifulSoup object as a parent). FIX : Fix internal nth range check. 1.4.0 NEW : Throw NotImplementedError for at-rules: @page , etc. NEW : Match nothing for :host , :host() , and :host-context() . NEW : Add support for :read-write and :read-only . NEW : Selector patterns can be annotated with CSS comments. FIX : \\r , \\n , and \\f cannot be escaped with \\ in CSS. You must use Unicode escapes. 1.3.1 FIX : Fix issue with undefined namespaces. 1.3.0 NEW : Add support for :scope . NEW : :user-invalid , :playing , :paused , and :local-link will not cause a failure, but all will match nothing as their use cases are not possible in an environment outside a web browser. FIX : Fix [attr~=value] handling of whitespace. According to the spec, if the value contains whitespace, or is an empty string, it should not match anything. FIX : Precompile internal patterns for pseudo-classes to prevent having to parse them again. 1.2.1 FIX : More descriptive exceptions. Exceptions will also now mention position in the pattern that is problematic. FIX : filter ignores NavigableString objects in normal iterables and Tag iterables. Basically, it filters all Beautiful Soup document parts regardless of iterable type where as it used to only filter out a NavigableString in a Tag object. This is viewed as fixing an inconsistency. FIX : DEBUG flag has been added to help with debugging CSS selector parsing. This is mainly for development. FIX : If forced to search for language in meta tag, and no language is found, cache that there is no language in the meta tag to prevent searching again during the current select. FIX : If a non BeautifulSoup / Tag object is given to the API to compare against, raise a TypeError . 1.2.0 NEW : Add Python 2.7 support. NEW : Remove old pre 1.0 deprecations. 1.1.0 NEW : Adds support for [attr!=value] which is equivalent to :not([attr=value]) . NEW : Add support for :active , :focus , :hover , :visited , :target , :focus-within , :focus-visible , :target-within , :current() / :current , :past , and :future , but they will never match as these states don't exist in the Soup Sieve environment. NEW : Add support for :checked , :enabled , :disabled , :required , :optional , :default , and :placeholder-shown which will only match in HTML documents as these concepts are not defined in XML. NEW : Add support for :link and :any-link , both of which will target all <a> , <area> , and <link> elements with an href attribute as all links will be treated as unvisited in Soup Sieve. NEW : Add support for :lang() (CSS4) which works in XML and HTML. NEW : Users must install Beautiful Soup themselves. This requirement is removed in the hopes that Beautiful Soup may use this in the future. FIX : Attributes in the form prefix:attr can be matched with the form [prefix\\:attr] without specifying a namespaces if desired. FIX : Fix exception when [type] is used (with no value). 1.0.2 FIX : Use proper CSS identifier patterns for tag names, classes, ids, etc. Things like #3 or #-3 should not match and should require #\\33 or #-\\33 . FIX : Do not raise NotImplementedError for supported pseudo classes/elements with bad syntax, instead raise SyntaxError . 1.0.1 FIX : When giving a tag to select , it should only return the children of that tag, never the tag itself. FIX : For informational purposes, raise a NotImplementedError when an unsupported pseudo class is used. 1.0.0 NEW : Official 1.0.0 release. 1.0.0b2 NEW : Drop document flags. Document type can be detected from the Beautiful Soup object directly. FIX : CSS selectors should be evaluated with CSS whitespace rules. FIX : Processing instructions, CDATA, and declarations should all be ignored in :contains and child considerations for :empty . FIX : In Beautiful Soup, the document itself is the first tag. Do not match the \"document\" tag by returning false for any tag that doesn't have a parent. 1.0.0b1 NEW : Add support for non-standard :contains() selector. FIX : Compare pseudo class names case insensitively when matching unexpected cases. FIX : Don't allow attribute case flags when no attribute value is defined. 0.6.0 NEW : mode attribute is now called flags to allow for other options in the future. FIX : More corner cases for nth selectors. 0.5.3 FIX : Previously, all pseudo classes' selector lists were evaluated as one big group, but now each pseudo classes' selector lists are evaluated separately. FIX : CSS selector tokens are not case sensitive. 0.5.2 FIX : Add missing s flag to attribute selector for forced case sensitivity of attribute values. FIX : Relax attribute pattern matching to allow non-essential whitespace. FIX : Attribute selector flags themselves are not case sensitive. FIX : type attribute in HTML is handled special. While all other attributes values are case sensitive, type in HTML is usually treated special and is insensitive. In XML, this is not the case. 0.5.1 FIX : Fix namespace check for :nth-of-type . 0.5.0 NEW : Deprecate commentsiter and selectiter in favor of icomments and iselect . Expect removal in version 1.0. 0.4.0 NEW : Initial prerelease.","title":"Changelog"},{"location":"about/changelog/#201","text":"FIX : Remove unused code.","title":"2.0.1"},{"location":"about/changelog/#200","text":"NEW : SelectorSyntaxError is derived from Exception not SyntaxError . NEW : Remove deprecated comments and icomments from the API. NEW : Drop support for EOL Python versions (Python 2 and Python < 3.5). FIX : Corner case with splitting namespace and tag name that that have an escaped | .","title":"2.0.0"},{"location":"about/changelog/#196","text":"Last version for Python 2.7 FIX : Prune dead code. FIX : Corner case with splitting namespace and tag name that that have an escaped | .","title":"1.9.6"},{"location":"about/changelog/#195","text":"FIX : :placeholder-shown should not match if the element has content that overrides the placeholder.","title":"1.9.5"},{"location":"about/changelog/#194","text":"FIX : :checked rule was too strict with option elements. The specification for :checked does not require an option element to be under a select element. FIX : Fix level 4 :lang() wildcard match handling with singletons. Implicit wildcard matching should not match any singleton. Explicit wildcard matching ( * in the language range: *-US ) is allowed to match singletons.","title":"1.9.4"},{"location":"about/changelog/#193","text":"FIX : [attr!=value] pattern was mistakenly using :not([attr|=value]) logic instead of :not([attr=value]) . FIX : Remove undocumented _QUIRKS mode flag. Beautiful Soup was meant to use it to help with transition to Soup Sieve, but never released with it. Help with transition at this point is no longer needed.","title":"1.9.3"},{"location":"about/changelog/#192","text":"FIX : Shortcut last descendant calculation if possible for performance. FIX : Fix issue where Doctype strings can be mistaken for a normal text node in some cases. FIX : A top level tag is not a :root tag if it has sibling text nodes or tag nodes. This is an issue that mostly manifests when using html.parser as the parser will allow multiple root nodes.","title":"1.9.2"},{"location":"about/changelog/#191","text":"FIX : :root , :contains() , :default , :indeterminate , :lang() , and :dir() will properly account for HTML iframe elements in their logic when selecting or matching an element. Their logic will be restricted to the document for which the element under consideration applies. FIX : HTML pseudo-classes will check that all key elements checked are in the XHTML namespace (HTML parsers that do not provide namespaces will assume the XHTML namespace). FIX : Ensure that all pseudo-class names are case insensitive and allow CSS escapes.","title":"1.9.1"},{"location":"about/changelog/#190","text":"NEW : Allow :contains() to accept a list of text to search for. ( #115 ) NEW : Add new escape function for escaping CSS identifiers. ( #125 ) NEW : Deprecate comments and icomments functions in the API to ensure Soup Sieve focuses only on CSS selectors. comments and icomments will most likely be removed in 2.0. ( #130 ) NEW : Add Python 3.8 support. ( #133 ) FIX : Don't install test files when installing the soupsieve package. ( #111 ) FIX : Improve efficiency of :contains() comparison. FIX : Null characters should translate to the Unicode REPLACEMENT CHARACTER ( U+FFFD ) according to the specification. This applies to CSS escaped NULL characters as well. ( #124 ) FIX : Escaped EOF should translate to U+FFFD outside of CSS strings. In a string, they should just be ignored, but as there is no case where we could resolve such a string and still have a valid selector, string handling remains the same. ( #128 )","title":"1.9.0"},{"location":"about/changelog/#180","text":"NEW : Add custom selector support. ( #92 )( #108 ) FIX : Small tweak to CSS identifier pattern to ensure it matches the CSS specification exactly. Specifically, you can't have an identifier of only - . ( #107 ) FIX : CSS string patterns should allow escaping newlines to span strings across multiple lines. ( #107 ) FIX : Newline regular expression for CSS newlines should treat \\r\\n as a single character, especially in cases such as string escapes: \\\\\\r\\n . ( #107 ) FIX : Allow -- as a valid identifier or identifier start. ( #107 ) FIX : Bad CSS syntax now raises a SelectorSyntaxError , which is still currently derived from SyntaxError , but will most likely be derived from Exception in the future.","title":"1.8.0"},{"location":"about/changelog/#173","text":"FIX : Fix regression with tag names in regards to case sensitivity, and ensure there are tests to prevent breakage in the future. FIX : XHTML should always be case sensitive like XML.","title":"1.7.3"},{"location":"about/changelog/#172","text":"FIX : Fix HTML detection type selector. FIX : Fixes for :enabled and :disabled . FIX : Provide a way for Beautiful Soup to parse selectors in a quirks mode to mimic some of the quirks of the old select method prior to Soup Sieve, but with warnings. This is to help old scripts to not break during the transitional period with newest Beautiful Soup. In the future, these quirks will raise an exception as Soup Sieve requires selectors to follow the CSS specification.","title":"1.7.2"},{"location":"about/changelog/#171","text":"FIX : Fix issue with :has() selector where a leading combinator can only be provided in the first selector in a relative selector list.","title":"1.7.1"},{"location":"about/changelog/#170","text":"NEW : Add support for :in-range and :out-of-range selectors. ( #60 ) NEW : Add support for :defined selector. ( #76 ) FIX : Fix pickling issue when compiled selector contains a NullSelector object. ( #70 ) FIX : Better exception messages in the CSS selector parser and fix a position reporting issue that can occur in some exceptions. ( #72 , #73 ) FIX : Don't compare prefixes when evaluating attribute namespaces, compare the actual namespace. ( #75 ) FIX : Split whitespace attribute lists by all whitespace characters, not just space. FIX : :nth-* patterns were converting numbers to base 16 when they should have been converting to base 10.","title":"1.7.0"},{"location":"about/changelog/#162","text":"FIX : Fix pattern compile issues on Python < 2.7.4. FIX : Don't use \\d in Unicode Re patterns as they will contain characters outside the range of [0-9] .","title":"1.6.2"},{"location":"about/changelog/#161","text":"FIX : Fix warning about not importing Mapping from collections.abc .","title":"1.6.1"},{"location":"about/changelog/#160","text":"NEW : Add closest method to the API that matches closest ancestor. FIX : Add missing select_one reference to module's __all__ .","title":"1.6.0"},{"location":"about/changelog/#150","text":"NEW : Add select_one method like Beautiful Soup has. NEW : Add :dir() selector (HTML only). FIX : Fix issues when handling HTML fragments (elements without a BeautifulSoup object as a parent). FIX : Fix internal nth range check.","title":"1.5.0"},{"location":"about/changelog/#140","text":"NEW : Throw NotImplementedError for at-rules: @page , etc. NEW : Match nothing for :host , :host() , and :host-context() . NEW : Add support for :read-write and :read-only . NEW : Selector patterns can be annotated with CSS comments. FIX : \\r , \\n , and \\f cannot be escaped with \\ in CSS. You must use Unicode escapes.","title":"1.4.0"},{"location":"about/changelog/#131","text":"FIX : Fix issue with undefined namespaces.","title":"1.3.1"},{"location":"about/changelog/#130","text":"NEW : Add support for :scope . NEW : :user-invalid , :playing , :paused , and :local-link will not cause a failure, but all will match nothing as their use cases are not possible in an environment outside a web browser. FIX : Fix [attr~=value] handling of whitespace. According to the spec, if the value contains whitespace, or is an empty string, it should not match anything. FIX : Precompile internal patterns for pseudo-classes to prevent having to parse them again.","title":"1.3.0"},{"location":"about/changelog/#121","text":"FIX : More descriptive exceptions. Exceptions will also now mention position in the pattern that is problematic. FIX : filter ignores NavigableString objects in normal iterables and Tag iterables. Basically, it filters all Beautiful Soup document parts regardless of iterable type where as it used to only filter out a NavigableString in a Tag object. This is viewed as fixing an inconsistency. FIX : DEBUG flag has been added to help with debugging CSS selector parsing. This is mainly for development. FIX : If forced to search for language in meta tag, and no language is found, cache that there is no language in the meta tag to prevent searching again during the current select. FIX : If a non BeautifulSoup / Tag object is given to the API to compare against, raise a TypeError .","title":"1.2.1"},{"location":"about/changelog/#120","text":"NEW : Add Python 2.7 support. NEW : Remove old pre 1.0 deprecations.","title":"1.2.0"},{"location":"about/changelog/#110","text":"NEW : Adds support for [attr!=value] which is equivalent to :not([attr=value]) . NEW : Add support for :active , :focus , :hover , :visited , :target , :focus-within , :focus-visible , :target-within , :current() / :current , :past , and :future , but they will never match as these states don't exist in the Soup Sieve environment. NEW : Add support for :checked , :enabled , :disabled , :required , :optional , :default , and :placeholder-shown which will only match in HTML documents as these concepts are not defined in XML. NEW : Add support for :link and :any-link , both of which will target all <a> , <area> , and <link> elements with an href attribute as all links will be treated as unvisited in Soup Sieve. NEW : Add support for :lang() (CSS4) which works in XML and HTML. NEW : Users must install Beautiful Soup themselves. This requirement is removed in the hopes that Beautiful Soup may use this in the future. FIX : Attributes in the form prefix:attr can be matched with the form [prefix\\:attr] without specifying a namespaces if desired. FIX : Fix exception when [type] is used (with no value).","title":"1.1.0"},{"location":"about/changelog/#102","text":"FIX : Use proper CSS identifier patterns for tag names, classes, ids, etc. Things like #3 or #-3 should not match and should require #\\33 or #-\\33 . FIX : Do not raise NotImplementedError for supported pseudo classes/elements with bad syntax, instead raise SyntaxError .","title":"1.0.2"},{"location":"about/changelog/#101","text":"FIX : When giving a tag to select , it should only return the children of that tag, never the tag itself. FIX : For informational purposes, raise a NotImplementedError when an unsupported pseudo class is used.","title":"1.0.1"},{"location":"about/changelog/#100","text":"NEW : Official 1.0.0 release.","title":"1.0.0"},{"location":"about/changelog/#100b2","text":"NEW : Drop document flags. Document type can be detected from the Beautiful Soup object directly. FIX : CSS selectors should be evaluated with CSS whitespace rules. FIX : Processing instructions, CDATA, and declarations should all be ignored in :contains and child considerations for :empty . FIX : In Beautiful Soup, the document itself is the first tag. Do not match the \"document\" tag by returning false for any tag that doesn't have a parent.","title":"1.0.0b2"},{"location":"about/changelog/#100b1","text":"NEW : Add support for non-standard :contains() selector. FIX : Compare pseudo class names case insensitively when matching unexpected cases. FIX : Don't allow attribute case flags when no attribute value is defined.","title":"1.0.0b1"},{"location":"about/changelog/#060","text":"NEW : mode attribute is now called flags to allow for other options in the future. FIX : More corner cases for nth selectors.","title":"0.6.0"},{"location":"about/changelog/#053","text":"FIX : Previously, all pseudo classes' selector lists were evaluated as one big group, but now each pseudo classes' selector lists are evaluated separately. FIX : CSS selector tokens are not case sensitive.","title":"0.5.3"},{"location":"about/changelog/#052","text":"FIX : Add missing s flag to attribute selector for forced case sensitivity of attribute values. FIX : Relax attribute pattern matching to allow non-essential whitespace. FIX : Attribute selector flags themselves are not case sensitive. FIX : type attribute in HTML is handled special. While all other attributes values are case sensitive, type in HTML is usually treated special and is insensitive. In XML, this is not the case.","title":"0.5.2"},{"location":"about/changelog/#051","text":"FIX : Fix namespace check for :nth-of-type .","title":"0.5.1"},{"location":"about/changelog/#050","text":"NEW : Deprecate commentsiter and selectiter in favor of icomments and iselect . Expect removal in version 1.0.","title":"0.5.0"},{"location":"about/changelog/#040","text":"NEW : Initial prerelease.","title":"0.4.0"},{"location":"about/contributing/","text":"Contributing & Support Become a Sponsor Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. GitHub Sponsors If you'd like to do a one time contribution, you can do so via PayPal. PayPal Bug Reports Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much information as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Answer Questions in Issues Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others. Pull Requests Pull requests are welcome, and a great way to help fix bugs and add new features. If you you are interested in directly contributing to the code, please check out Development for more information on the environment and processes. Documentation Improvements A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool by helping to improve the documentation. Check out Development for more info on documentation.","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"about/contributing/#become-a-sponsor","text":"Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. GitHub Sponsors If you'd like to do a one time contribution, you can do so via PayPal. PayPal","title":"Become a Sponsor "},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try and find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much information as possible: Version being used. Operating system. Version of Python. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#answer-questions-in-issues","text":"Take time and answer questions and offer suggestions to people who've created issues in the issue tracker. Often people will have questions that you might have an answer for. Or maybe you know how to help them accomplish a specific task they are asking about. Feel free to share your experience to help others.","title":"Answer Questions in Issues"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and a great way to help fix bugs and add new features. If you you are interested in directly contributing to the code, please check out Development for more information on the environment and processes.","title":"Pull Requests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this tool and related extensions, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the tool by helping to improve the documentation. Check out Development for more info on documentation.","title":"Documentation Improvements"},{"location":"about/development/","text":"Development Project Layout There are a number of files for build, test, and continuous integration in the root of the project, but in general, the project is broken up like so. \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 dictionary \u2502 \u2514\u2500\u2500 markdown \u251c\u2500\u2500 soupsieve \u251c\u2500\u2500 requirements \u2514\u2500\u2500 tests Directory Description docs/src/dictionary Contains the spell check wordlist(s) for the project. docs/src/markdown Contains the content for the documentation. soupsieve Contains the source code for the project. requirements Contains files with lists of dependencies that are required for the project, and required for continuous integration. tests Contains unit test files. Coding Standards When writing code, the code should roughly conform to PEP8 and PEP257 suggestions. The project utilizes the Flake8 linter (with some additional plugins) to ensure code conforms (give or take some of the rules). When in doubt, follow the formatting hints of existing code when adding files or modifying existing files. Listed below are the modules used: pycqa/flake8 pycqa/flake8-docstrings pycqa/pep8-naming ebeweber/flake8-mutable gforcada/flake8-builtins Usually this can be automated with Tox (assuming it is installed): tox -e lint . Building and Editing Documents Documents are in Markdown (with with some additional syntax provided by extensions) and are converted to HTML via Python Markdown. If you would like to build and preview the documentation, you must have these packages installed: Python-Markdown/markdown : the Markdown parser. mkdocs/mkdocs : the document site generator. squidfunk/mkdocs-material : a material theme for MkDocs. facelessuser/pymdown-extensions : this Python Markdown extension bundle. In order to build and preview the documents, just run the command below from the root of the project and you should be able to view the documents at localhost:8000 in your browser. After that, you should be able to update the documents and have your browser preview update live. mkdocs serve Spell Checking Documents Spell checking is performed via facelessuser/pyspelling . During validation we build the docs and spell check various files in the project. Aspell must be installed and in the path. Currently this project uses one of the more recent versions of Aspell. It is not expected that everyone will install and run Aspell locally, but it will be run in CI tests for pull requests. In order to perform the spell check locally, it is expected you are setup to build the documents, and that you have Aspell installed in your system path (if needed you can use the --binary option to point to the location of your Aspell binary). It is also expected that you have the en dictionary installed as well. To initiate the spell check, run the following command from the root of the project. You will need to make sure the documents are built first: mkdocs build --clean And then run the spell checker. pyspelling It should print out the files with the misspelled words if any are found. If you find it prints words that are not misspelled, you can add them in docs/src/dictionary/en-custom.text . Validation Tests In order to preserve good code health, a test suite has been put together with pytest ( pytest-dev/pytest ). To run these tests, you can use the following command: py.test Running Validation With Tox Tox ( tox-dev/tox ) is a great way to run the validation tests, spelling checks, and linting in virtual environments so as not to mess with your current working environment. Tox will use the specified Python version for the given environment and create a virtual environment and install all the needed requirements (minus Aspell). You could also setup your own virtual environments with the Virtualenv module without Tox, and manually do the same. First, you need to have Tox installed: pip install tox By running Tox, it will walk through all the environments and create them (assuming you have all the python versions on your machine) and run the related tests. See tox.ini to learn more. tox If you don't have all the Python versions needed to test all the environments, those entries will fail. To run the tests for specific versions of Python, you specify the environment with -e PXY where X is the major version and Y is the minor version. tox -e py37 To target linting: tox -e lint To select spell checking and document building: tox -e documents Code Coverage When running the validation tests through Tox, it is setup to track code coverage via the Coverage ( ned/coveragepy ) module. Coverage is run on each pyxx environment. If you've made changes to the code, you can clear the old coverage data: coverage erase Then run each unit test environment to generate coverage data. All the data from each run is merged together. HTML is output for each file in .tox/pyXX/tmp . You can use these to see areas that are not covered/exercised yet with testing. You can checkout tox.ini to see how this is accomplished. Code Documentation The Soup Sieve module is laid out in the following structure: soupseive \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 __meta__.py \u251c\u2500\u2500 css_match.py \u251c\u2500\u2500 css_parser.py \u251c\u2500\u2500 css_types.py \u2514\u2500\u2500 util.py File Description __init__.py Contains the API for the user. __meta__.py Contains package meta data like version. css_match.py Contains the logic for matching tags with a CSS selector. css_parser.py Contains the CSS selector parser. css_types.py Contains the CSS types for the compiled CSS patterns. util.py Contains miscellaneous helper functions, classes, and constants. Compiled CSS Selector Structure When a CSS selector string is given to Soup Sieve, it is run through the CSSParser class. CSSParser will return a SelectorList class. This class is sent to the SoupSieve class as a parameter along with things like namespace and flags . One of the most important things to understand when contributing is the structure of the SelectorList class. A SelectorList represents a list of compound selectors. So if you had the selector div > p , you would get a SelectorList object containing one Selector object. If you had div , p , you would get a SelectorList with two Selector objects as this is a selector list of two compound selectors. A compound selector gets parsed into pieces. Each part of a specific compound selector is usually assigned to an attribute in a single Selector object. The attributes of the Selector object may be as simple as a boolean or a string, but they can also be a tuple of more SelectorList objects. In the case of * : not ( p , div ) , * will be a SelectorList with one Selector . The : not ( p , div ) selector list will be a tuple containing one SelectorList of two Selectors (one for p and one for div ) under the selectors attribute of the * Selector . In short, Selectors are always contained within a SelectorList , and a compound selector is a single Selector object that may chain other SelectorLists objects depending on the complexity of the compound selector. If you provide a selector list, then you will get multiple Selector objects (one for each compound selector in the list) which in turn may chain other Selector objects. SelectorList class SelectorList : \"\"\"Selector list.\"\"\" def __init__ ( self , selectors = tuple (), is_not = False ): \"\"\"Initialize.\"\"\" Attribute Description selectors A list of Selector objects. is_not The selectors in the selector list are from a :not() . is_html The selectors in the selector list are HTML specific. Selector class Selector : \"\"\"Selector.\"\"\" def __init__ ( self , tag , ids , classes , attributes , nth , selectors , relation , rel_type , contains , lang , flags ): \"\"\"Initialize.\"\"\" Flags Description SEL_EMPTY The current compound selector contained an :empty pseudo-class. SEL_ROOT The current compound selector contains :root . SEL_DEFAULT The compound selector has a :default pattern and requires additional logic to determine if it is the first submit button in a form. SEL_INDETERMINATE The compound selector has a :indeterminate pattern and requires additional logic to ensure a radio element and all of the radio elements with the same name under a form are not set. Attribute Description tag Contains a single SelectorTag object, or None . id Contains a tuple of ids to match. Usually if multiple conflicting ids are present, it simply won't match a tag, but it allows multiple to handle the syntax tag#1#2 even if it is invalid. classes Contains a tuple of class names to match. attributes Contains a tuple of attributes. Each attribute is represented as a SelectorAttribute . nth Contains a tuple containing nth selectors, each selector being represented as a SelectorNth . nth selectors contain things like :first-child , :only-child , : nth-child () , : nth-of-type () , etc. selectors Contains a tuple of SelectorList objects for each pseudo-class selector part of the compound selector: : is () , : not () , : has () , etc. relation This will contain a SelectorList object with one Selector object, which could in turn chain an additional relation depending on the complexity of the compound selector. For instance, div > p + a would be a Selector for a that contains a relation for p (another SelectorList object) which also contains a relation of div . When matching, we would match that the tag is a , and then walk its relation chain verifying that they all match. In this case, the relation chain would be a direct, previous sibling of p , which has a direct parent of div . A :has() pseudo-class would walk this in the opposite order. div:has(> p + a) would verify div , and then check for a child of p with a sibling of a . rel_type rel_type is attached to relational selectors. In the case of div > p + a , the relational selectors of div and p would get a relational type of > and + respectively. :has() relational rel_type are preceded with : to signify a forward looking relation. contains Contains a tuple of SelectorContains objects. Each object contains the list of text to match an element's content against. lang Contains a tuple of SelectorLang objects. flags Selector flags that used to signal a type of selector is present. SelectorNull class SelectorNull : \"\"\"Null Selector.\"\"\" def __init__ ( self ): \"\"\"Initialize.\"\"\" The null selector is like Selector , but it matches nothing. SelectorTag class SelectorTag : \"\"\"Selector tag.\"\"\" def __init__ ( self , name , prefix ): \"\"\"Initialize.\"\"\" Attribute Description name name contains the tag name to match. prefix prefix contains the namespace prefix to match. prefix can also be None . SelectorAttribute class SelectorAttribute : \"\"\"Selector attribute rule.\"\"\" def __init__ ( self , attribute , prefix , pattern , xml_type_pattern ): \"\"\"Initialize.\"\"\" Attribute Description attribute Contains the attribute name to match. prefix Contains the attribute namespace prefix to match if any. pattern Contains a re regular expression object that matches the desired attribute value. xml_type_pattern As the default type pattern is case insensitive, when the attribute value is type and a case sensitivity has not been explicitly defined, a secondary case sensitive type pattern is compiled for use with XML documents when detected. SelectorContains class SelectorContains : \"\"\"Selector contains rule.\"\"\" def __init__ ( self , text ): \"\"\"Initialize.\"\"\" Attribute Description text A tuple of acceptable text that that an element should match. An element only needs to match at least one. SelectorNth class SelectorNth : \"\"\"Selector nth type.\"\"\" def __init__ ( self , a , n , b , of_type , last , selectors ): \"\"\"Initialize.\"\"\" Attribute Description a The a value in the formula an+b specifying an index. n True if the provided formula has included a literal n which signifies the formula is not a static index. b The b value in the formula an+b . type True if the nth pseudo-class is an *-of-type variant. last True if the nth pseudo-class is a *last* variant. selectors A SelectorList object representing the of S portion of :nth-chld(an+b [of S]?) . SelectorLang class SelectorLang : \"\"\"Selector language rules.\"\"\" def __init__ ( self , languages ): \"\"\"Initialize.\"\"\" Attribute Description languages A list of regular expression objects that match a language pattern.","title":"Development"},{"location":"about/development/#development","text":"","title":"Development"},{"location":"about/development/#project-layout","text":"There are a number of files for build, test, and continuous integration in the root of the project, but in general, the project is broken up like so. \u251c\u2500\u2500 docs \u2502 \u2514\u2500\u2500 src \u2502 \u251c\u2500\u2500 dictionary \u2502 \u2514\u2500\u2500 markdown \u251c\u2500\u2500 soupsieve \u251c\u2500\u2500 requirements \u2514\u2500\u2500 tests Directory Description docs/src/dictionary Contains the spell check wordlist(s) for the project. docs/src/markdown Contains the content for the documentation. soupsieve Contains the source code for the project. requirements Contains files with lists of dependencies that are required for the project, and required for continuous integration. tests Contains unit test files.","title":"Project Layout"},{"location":"about/development/#coding-standards","text":"When writing code, the code should roughly conform to PEP8 and PEP257 suggestions. The project utilizes the Flake8 linter (with some additional plugins) to ensure code conforms (give or take some of the rules). When in doubt, follow the formatting hints of existing code when adding files or modifying existing files. Listed below are the modules used: pycqa/flake8 pycqa/flake8-docstrings pycqa/pep8-naming ebeweber/flake8-mutable gforcada/flake8-builtins Usually this can be automated with Tox (assuming it is installed): tox -e lint .","title":"Coding Standards"},{"location":"about/development/#building-and-editing-documents","text":"Documents are in Markdown (with with some additional syntax provided by extensions) and are converted to HTML via Python Markdown. If you would like to build and preview the documentation, you must have these packages installed: Python-Markdown/markdown : the Markdown parser. mkdocs/mkdocs : the document site generator. squidfunk/mkdocs-material : a material theme for MkDocs. facelessuser/pymdown-extensions : this Python Markdown extension bundle. In order to build and preview the documents, just run the command below from the root of the project and you should be able to view the documents at localhost:8000 in your browser. After that, you should be able to update the documents and have your browser preview update live. mkdocs serve","title":"Building and Editing Documents"},{"location":"about/development/#spell-checking-documents","text":"Spell checking is performed via facelessuser/pyspelling . During validation we build the docs and spell check various files in the project. Aspell must be installed and in the path. Currently this project uses one of the more recent versions of Aspell. It is not expected that everyone will install and run Aspell locally, but it will be run in CI tests for pull requests. In order to perform the spell check locally, it is expected you are setup to build the documents, and that you have Aspell installed in your system path (if needed you can use the --binary option to point to the location of your Aspell binary). It is also expected that you have the en dictionary installed as well. To initiate the spell check, run the following command from the root of the project. You will need to make sure the documents are built first: mkdocs build --clean And then run the spell checker. pyspelling It should print out the files with the misspelled words if any are found. If you find it prints words that are not misspelled, you can add them in docs/src/dictionary/en-custom.text .","title":"Spell Checking Documents"},{"location":"about/development/#validation-tests","text":"In order to preserve good code health, a test suite has been put together with pytest ( pytest-dev/pytest ). To run these tests, you can use the following command: py.test","title":"Validation Tests"},{"location":"about/development/#running-validation-with-tox","text":"Tox ( tox-dev/tox ) is a great way to run the validation tests, spelling checks, and linting in virtual environments so as not to mess with your current working environment. Tox will use the specified Python version for the given environment and create a virtual environment and install all the needed requirements (minus Aspell). You could also setup your own virtual environments with the Virtualenv module without Tox, and manually do the same. First, you need to have Tox installed: pip install tox By running Tox, it will walk through all the environments and create them (assuming you have all the python versions on your machine) and run the related tests. See tox.ini to learn more. tox If you don't have all the Python versions needed to test all the environments, those entries will fail. To run the tests for specific versions of Python, you specify the environment with -e PXY where X is the major version and Y is the minor version. tox -e py37 To target linting: tox -e lint To select spell checking and document building: tox -e documents","title":"Running Validation With Tox"},{"location":"about/development/#code-coverage","text":"When running the validation tests through Tox, it is setup to track code coverage via the Coverage ( ned/coveragepy ) module. Coverage is run on each pyxx environment. If you've made changes to the code, you can clear the old coverage data: coverage erase Then run each unit test environment to generate coverage data. All the data from each run is merged together. HTML is output for each file in .tox/pyXX/tmp . You can use these to see areas that are not covered/exercised yet with testing. You can checkout tox.ini to see how this is accomplished.","title":"Code Coverage"},{"location":"about/development/#code-documentation","text":"The Soup Sieve module is laid out in the following structure: soupseive \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 __meta__.py \u251c\u2500\u2500 css_match.py \u251c\u2500\u2500 css_parser.py \u251c\u2500\u2500 css_types.py \u2514\u2500\u2500 util.py File Description __init__.py Contains the API for the user. __meta__.py Contains package meta data like version. css_match.py Contains the logic for matching tags with a CSS selector. css_parser.py Contains the CSS selector parser. css_types.py Contains the CSS types for the compiled CSS patterns. util.py Contains miscellaneous helper functions, classes, and constants.","title":"Code Documentation"},{"location":"about/development/#compiled-css-selector-structure","text":"When a CSS selector string is given to Soup Sieve, it is run through the CSSParser class. CSSParser will return a SelectorList class. This class is sent to the SoupSieve class as a parameter along with things like namespace and flags . One of the most important things to understand when contributing is the structure of the SelectorList class. A SelectorList represents a list of compound selectors. So if you had the selector div > p , you would get a SelectorList object containing one Selector object. If you had div , p , you would get a SelectorList with two Selector objects as this is a selector list of two compound selectors. A compound selector gets parsed into pieces. Each part of a specific compound selector is usually assigned to an attribute in a single Selector object. The attributes of the Selector object may be as simple as a boolean or a string, but they can also be a tuple of more SelectorList objects. In the case of * : not ( p , div ) , * will be a SelectorList with one Selector . The : not ( p , div ) selector list will be a tuple containing one SelectorList of two Selectors (one for p and one for div ) under the selectors attribute of the * Selector . In short, Selectors are always contained within a SelectorList , and a compound selector is a single Selector object that may chain other SelectorLists objects depending on the complexity of the compound selector. If you provide a selector list, then you will get multiple Selector objects (one for each compound selector in the list) which in turn may chain other Selector objects.","title":"Compiled CSS Selector Structure"},{"location":"about/development/#selectorlist","text":"class SelectorList : \"\"\"Selector list.\"\"\" def __init__ ( self , selectors = tuple (), is_not = False ): \"\"\"Initialize.\"\"\" Attribute Description selectors A list of Selector objects. is_not The selectors in the selector list are from a :not() . is_html The selectors in the selector list are HTML specific.","title":"SelectorList"},{"location":"about/development/#selector","text":"class Selector : \"\"\"Selector.\"\"\" def __init__ ( self , tag , ids , classes , attributes , nth , selectors , relation , rel_type , contains , lang , flags ): \"\"\"Initialize.\"\"\" Flags Description SEL_EMPTY The current compound selector contained an :empty pseudo-class. SEL_ROOT The current compound selector contains :root . SEL_DEFAULT The compound selector has a :default pattern and requires additional logic to determine if it is the first submit button in a form. SEL_INDETERMINATE The compound selector has a :indeterminate pattern and requires additional logic to ensure a radio element and all of the radio elements with the same name under a form are not set. Attribute Description tag Contains a single SelectorTag object, or None . id Contains a tuple of ids to match. Usually if multiple conflicting ids are present, it simply won't match a tag, but it allows multiple to handle the syntax tag#1#2 even if it is invalid. classes Contains a tuple of class names to match. attributes Contains a tuple of attributes. Each attribute is represented as a SelectorAttribute . nth Contains a tuple containing nth selectors, each selector being represented as a SelectorNth . nth selectors contain things like :first-child , :only-child , : nth-child () , : nth-of-type () , etc. selectors Contains a tuple of SelectorList objects for each pseudo-class selector part of the compound selector: : is () , : not () , : has () , etc. relation This will contain a SelectorList object with one Selector object, which could in turn chain an additional relation depending on the complexity of the compound selector. For instance, div > p + a would be a Selector for a that contains a relation for p (another SelectorList object) which also contains a relation of div . When matching, we would match that the tag is a , and then walk its relation chain verifying that they all match. In this case, the relation chain would be a direct, previous sibling of p , which has a direct parent of div . A :has() pseudo-class would walk this in the opposite order. div:has(> p + a) would verify div , and then check for a child of p with a sibling of a . rel_type rel_type is attached to relational selectors. In the case of div > p + a , the relational selectors of div and p would get a relational type of > and + respectively. :has() relational rel_type are preceded with : to signify a forward looking relation. contains Contains a tuple of SelectorContains objects. Each object contains the list of text to match an element's content against. lang Contains a tuple of SelectorLang objects. flags Selector flags that used to signal a type of selector is present.","title":"Selector"},{"location":"about/development/#selectornull","text":"class SelectorNull : \"\"\"Null Selector.\"\"\" def __init__ ( self ): \"\"\"Initialize.\"\"\" The null selector is like Selector , but it matches nothing.","title":"SelectorNull"},{"location":"about/development/#selectortag","text":"class SelectorTag : \"\"\"Selector tag.\"\"\" def __init__ ( self , name , prefix ): \"\"\"Initialize.\"\"\" Attribute Description name name contains the tag name to match. prefix prefix contains the namespace prefix to match. prefix can also be None .","title":"SelectorTag"},{"location":"about/development/#selectorattribute","text":"class SelectorAttribute : \"\"\"Selector attribute rule.\"\"\" def __init__ ( self , attribute , prefix , pattern , xml_type_pattern ): \"\"\"Initialize.\"\"\" Attribute Description attribute Contains the attribute name to match. prefix Contains the attribute namespace prefix to match if any. pattern Contains a re regular expression object that matches the desired attribute value. xml_type_pattern As the default type pattern is case insensitive, when the attribute value is type and a case sensitivity has not been explicitly defined, a secondary case sensitive type pattern is compiled for use with XML documents when detected.","title":"SelectorAttribute"},{"location":"about/development/#selectorcontains","text":"class SelectorContains : \"\"\"Selector contains rule.\"\"\" def __init__ ( self , text ): \"\"\"Initialize.\"\"\" Attribute Description text A tuple of acceptable text that that an element should match. An element only needs to match at least one.","title":"SelectorContains"},{"location":"about/development/#selectornth","text":"class SelectorNth : \"\"\"Selector nth type.\"\"\" def __init__ ( self , a , n , b , of_type , last , selectors ): \"\"\"Initialize.\"\"\" Attribute Description a The a value in the formula an+b specifying an index. n True if the provided formula has included a literal n which signifies the formula is not a static index. b The b value in the formula an+b . type True if the nth pseudo-class is an *-of-type variant. last True if the nth pseudo-class is a *last* variant. selectors A SelectorList object representing the of S portion of :nth-chld(an+b [of S]?) .","title":"SelectorNth"},{"location":"about/development/#selectorlang","text":"class SelectorLang : \"\"\"Selector language rules.\"\"\" def __init__ ( self , languages ): \"\"\"Initialize.\"\"\" Attribute Description languages A list of regular expression objects that match a language pattern.","title":"SelectorLang"},{"location":"about/license/","text":"License MIT License Copyright \u00a9 2018 - 2020 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"MIT License Copyright \u00a9 2018 - 2020 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"selectors/","text":"General Details Implementation Specifics The CSS selectors are based off of the CSS specification and includes not only stable selectors, but may also include selectors currently under development from the draft specifications. Primarily support has been added for selectors that were feasible to implement and most likely to get practical use. In addition to the selectors in the specification, Soup Sieve also supports a couple non-standard selectors. Soup Sieve aims to allow users to target XML/HTML elements with CSS selectors. It implements many pseudo classes, but it does not currently implement any pseudo elements and has no plans to do so. Soup Sieve also will not match anything for pseudo classes that are only relevant in a live, browser environment, but it will gracefully handle them if they've been implemented; such pseudo classes are non-applicable in the Beautiful Soup environment and are noted in Non-Applicable Pseudo Classes . When speaking about namespaces, they only apply to XML, XHTML, or when dealing with recognized foreign tags in HTML5. Currently, Beautiful Soup's html5lib parser is the only parser that will return the appropriate namespaces for a HTML5 document. If you are using XHTML, you have to use the Beautiful Soup's lxml-xml parser (or xml for short) to get the appropriate namespaces in an XHTML document. In addition to using the correct parser, you must provide a dictionary of namespaces to Soup Sieve in order to use namespace selectors. See the documentation on namespaces to learn more. While an effort is made to mimic CSS selector behavior, there may be some differences or quirks, please report issues if any are found. Selector Context Key Symbol Description Some selectors are very specific to HTML and either have no meaningful representation in XML, or such functionality has not been implemented. Selectors that are HTML only will be noted with , and will match nothing if used in XML. Soup Sieve has implemented a couple non-standard selectors. These can contain useful selectors that were rejected from the official CSS specifications, selectors implemented by other systems such as JQuery, or even selectors specifically created for Soup Sieve. If a selector is considered non standard, it will be marked with . All selectors that are from the current working draft of CSS4 are considered experimental and are marked with . Additionally, if there are other immature selectors, they may be marked as experimental as well. Experimental may mean we are not entirely sure if our implementation is correct, that things may still be in flux as they are part of a working draft, or even both. If at anytime a working draft drops a selector from the current draft, it will most likely also be removed here, most likely with a deprecation path, except where there may be a conflict that requires a less graceful transition. One exception is in the rare case that the selector is found to be far too useful despite being rejected. In these cases, we may adopt them as \"custom\" selectors. Additional Reading If usage of a selector is not clear in this documentation, you can find more information by reading these specification documents: CSS Level 3 Specification Contains the latest official document outlying official behaviors of CSS selectors. CSS Level 4 Working Draft Contains the latest published working draft of the CSS level 4 selectors which outlines the experimental new selectors and experimental behavioral changes. HTML5 The HTML 5.0 specification document. Defines the semantics regarding HTML. HTML Living Standard The HTML Living Standard document. Defines semantics regarding HTML. Selector Terminology Certain terminology is used throughout this document when describing selectors. In order to fully understand the syntax a selector may implement, it is important to understand a couple of key terms. Selector Selector is used to describe any selector whether it is a simple , compound , or complex selector. Simple Selector A simple selector represents a single condition on an element. It can be a type selector , universal selector , ID selector , class selector , attribute selector , or pseudo class selector . Compound Selector A compound selector is a sequence of simple selectors. They do not contain any combinators . If a universal or type selector is used, they must come first, and only one instance of either a universal or type selector can be used, both cannot be used at the same time. Complex Selector A complex selector consists of multiple simple or compound selectors joined with combinators . Selector List A selector list is a list of selectors joined with a comma ( , ). A selector list is used to specify that a match is valid if any of the selectors in a list matches. html { --svg-beaker: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='beaker'%3E%3Cpath d='M3,3V5A2,2 0 0,1 5,7V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V7A2,2 0 0,1 21,5V3H3M7,9H10V10H7V9M7,11H10V12H7V11M10,16H7V15H10V16M12,14H7V13H12V14M12,8H7V7H12V8Z' /%3E%3C/svg%3E\"); --svg-html5: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath d='M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z'/%3E%3C/svg%3E\"); --svg-star: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='star'%3E%3Cpath d='M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z' /%3E%3C/svg%3E\"); } span.lab::after, span.html5::after, span.star::after { position: relative; display: inline-block; width: 1em; height: 1em; padding-right: 1em; background-size: 1em; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; content: \"\\a0\"; } span.big-icon::after { width: 3em; height: 3em; background-size: 3em; } .badge { float: right; } span.lab::after { background-color: hsl(265, 89%, 78%); -webkit-mask-image: var(--svg-beaker); mask-image: var(--svg-beaker); } span.html5::after { background-color: hsl(31, 100%, 71%); -webkit-mask-image: var(--svg-html5); mask-image: var(--svg-html5); } span.star::after { background-color: hsl(135, 94%, 65%); -webkit-mask-image: var(--svg-star); mask-image: var(--svg-star); }","title":"General Details"},{"location":"selectors/#general-details","text":"","title":"General Details"},{"location":"selectors/#implementation-specifics","text":"The CSS selectors are based off of the CSS specification and includes not only stable selectors, but may also include selectors currently under development from the draft specifications. Primarily support has been added for selectors that were feasible to implement and most likely to get practical use. In addition to the selectors in the specification, Soup Sieve also supports a couple non-standard selectors. Soup Sieve aims to allow users to target XML/HTML elements with CSS selectors. It implements many pseudo classes, but it does not currently implement any pseudo elements and has no plans to do so. Soup Sieve also will not match anything for pseudo classes that are only relevant in a live, browser environment, but it will gracefully handle them if they've been implemented; such pseudo classes are non-applicable in the Beautiful Soup environment and are noted in Non-Applicable Pseudo Classes . When speaking about namespaces, they only apply to XML, XHTML, or when dealing with recognized foreign tags in HTML5. Currently, Beautiful Soup's html5lib parser is the only parser that will return the appropriate namespaces for a HTML5 document. If you are using XHTML, you have to use the Beautiful Soup's lxml-xml parser (or xml for short) to get the appropriate namespaces in an XHTML document. In addition to using the correct parser, you must provide a dictionary of namespaces to Soup Sieve in order to use namespace selectors. See the documentation on namespaces to learn more. While an effort is made to mimic CSS selector behavior, there may be some differences or quirks, please report issues if any are found.","title":"Implementation Specifics"},{"location":"selectors/#selector-context-key","text":"Symbol Description Some selectors are very specific to HTML and either have no meaningful representation in XML, or such functionality has not been implemented. Selectors that are HTML only will be noted with , and will match nothing if used in XML. Soup Sieve has implemented a couple non-standard selectors. These can contain useful selectors that were rejected from the official CSS specifications, selectors implemented by other systems such as JQuery, or even selectors specifically created for Soup Sieve. If a selector is considered non standard, it will be marked with . All selectors that are from the current working draft of CSS4 are considered experimental and are marked with . Additionally, if there are other immature selectors, they may be marked as experimental as well. Experimental may mean we are not entirely sure if our implementation is correct, that things may still be in flux as they are part of a working draft, or even both. If at anytime a working draft drops a selector from the current draft, it will most likely also be removed here, most likely with a deprecation path, except where there may be a conflict that requires a less graceful transition. One exception is in the rare case that the selector is found to be far too useful despite being rejected. In these cases, we may adopt them as \"custom\" selectors. Additional Reading If usage of a selector is not clear in this documentation, you can find more information by reading these specification documents: CSS Level 3 Specification Contains the latest official document outlying official behaviors of CSS selectors. CSS Level 4 Working Draft Contains the latest published working draft of the CSS level 4 selectors which outlines the experimental new selectors and experimental behavioral changes. HTML5 The HTML 5.0 specification document. Defines the semantics regarding HTML. HTML Living Standard The HTML Living Standard document. Defines semantics regarding HTML.","title":"Selector Context Key"},{"location":"selectors/#selector-terminology","text":"Certain terminology is used throughout this document when describing selectors. In order to fully understand the syntax a selector may implement, it is important to understand a couple of key terms.","title":"Selector Terminology"},{"location":"selectors/#selector","text":"Selector is used to describe any selector whether it is a simple , compound , or complex selector.","title":"Selector"},{"location":"selectors/#simple-selector","text":"A simple selector represents a single condition on an element. It can be a type selector , universal selector , ID selector , class selector , attribute selector , or pseudo class selector .","title":"Simple Selector"},{"location":"selectors/#compound-selector","text":"A compound selector is a sequence of simple selectors. They do not contain any combinators . If a universal or type selector is used, they must come first, and only one instance of either a universal or type selector can be used, both cannot be used at the same time.","title":"Compound Selector"},{"location":"selectors/#complex-selector","text":"A complex selector consists of multiple simple or compound selectors joined with combinators .","title":"Complex Selector"},{"location":"selectors/#selector-list","text":"A selector list is a list of selectors joined with a comma ( , ). A selector list is used to specify that a match is valid if any of the selectors in a list matches. html { --svg-beaker: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='beaker'%3E%3Cpath d='M3,3V5A2,2 0 0,1 5,7V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V7A2,2 0 0,1 21,5V3H3M7,9H10V10H7V9M7,11H10V12H7V11M10,16H7V15H10V16M12,14H7V13H12V14M12,8H7V7H12V8Z' /%3E%3C/svg%3E\"); --svg-html5: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath d='M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z'/%3E%3C/svg%3E\"); --svg-star: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='star'%3E%3Cpath d='M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z' /%3E%3C/svg%3E\"); } span.lab::after, span.html5::after, span.star::after { position: relative; display: inline-block; width: 1em; height: 1em; padding-right: 1em; background-size: 1em; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; content: \"\\a0\"; } span.big-icon::after { width: 3em; height: 3em; background-size: 3em; } .badge { float: right; } span.lab::after { background-color: hsl(265, 89%, 78%); -webkit-mask-image: var(--svg-beaker); mask-image: var(--svg-beaker); } span.html5::after { background-color: hsl(31, 100%, 71%); -webkit-mask-image: var(--svg-html5); mask-image: var(--svg-html5); } span.star::after { background-color: hsl(135, 94%, 65%); -webkit-mask-image: var(--svg-star); mask-image: var(--svg-star); }","title":"Selector List"},{"location":"selectors/basic/","text":"Basic Selectors Syntax and notation for basic selectors. Escapes Soup Sieve selectors support using CSS escapes. So if you need provide Unicode, or non-standard characters, you can use CSS style escapes. Escapes can be specified with a backslash followed by 1 - 6 hexadecimal digits: \\ 20AC , \\ 0020AC , etc. If you need to terminate an escape to avoid it accumulating unintended hexadecimal characters, you can use a space: \\ 0020AC dont-escape-me . You can also escape any non-hexadecimal character, and it will be treated as that character: \\ + \u2192 + . The one exception is that you cannot escape the form feed, newline, or carriage return. You can always use Soup Sieve's escape command to escape identifiers as well. Type Selectors Type selectors match elements by node name. If a default namespace is defined in the namespace dictionary , and no namespace is explicitly defined, it will be assumed that the element must be in the default namespace. Syntax element Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'div' )) [<div>Here is some text.</div>, <div>Here is some more text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors Universal Selectors The Universal selector ( * ) matches elements of any type. Syntax * Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p>Here is some text.</p> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '*' )) [<html><head></head> <body> <div>Here is some text.</div> <div>Here is some more text.</div> </body></html>, <head></head>, <body> <div>Here is some text.</div> <div>Here is some more text.</div> </body>, <div>Here is some text.</div>, <div>Here is some more text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors ID Selectors The ID selector matches an element based on its id attribute. The ID must match exactly. Syntax # id Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div id=\"some-id\">Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '#some-id' )) [<div id=\"some-id\">Here is some text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors XML Support While the use of the id attribute (in the context of CSS) is a very HTML centric idea, it is supported for XML as well because Beautiful Soup supported it before Soup Sieve's existence. Class Selectors The class selector matches an element based on the values contained in the class attribute. The class attribute is treated as a whitespace separated list, where each item is a class . Syntax . class Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div class=\"some-class\">Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '.some-class' )) [<div class=\"some-class\">Here is some text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors XML Support While the use of the class attribute (in the context of CSS) is a very HTML centric idea, it is supported for XML as well because Beautiful Soup supported it before Soup Sieve's existence. Attribute Selectors The attribute selector matches an element based on its attributes. When specifying a value of an attribute, if it contains whitespace or special characters, you should quote them with either single or double quotes. Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors [attribute] Represents elements with an attribute named attribute . Syntax [ attr ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href]' )) [<a href=\"#internal\">Internal link</a>, <a href=\"http://example.com\">Example link</a>, <a href=\"#InSensitive\">Insensitive internal link</a>, <a href=\"http://example.org\">Example org link</a>] [attribute=value] Represents elements with an attribute named attribute that also has a value of value . Syntax [ attr = value ] [ attr = \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href=\"#internal\"]' )) [<a href=\"#internal\">Internal link</a>] [attribute~=value] Represents elements with an attribute named attribute whose value is a space separated list which contains value . Syntax [ attr ~= value ] [ attr ~= \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\" class=\"class1 class2 class3\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[class~=class2]' )) [<a class=\"class1 class2 class3\" href=\"#internal\">Internal link</a>] [attribute|=value] Represents elements with an attribute named attribute whose value is a dash separated list that starts with value . Syntax [ attr |= value ] [ attr |= \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div lang=\"en\">Some text</div> ... <div lang=\"en-US\">Some more text</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'a[href!=\"#internal\"]' )) [<div lang=\"en\">Some text</div>, <div lang=\"en-US\">Some more text</div>] [attribute^=value] Represents elements with an attribute named attribute whose value starts with value . Syntax [ attr ^= value ] [ attr ^= \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href^=http]' )) [<a href=\"http://example.com\">Example link</a>, <a href=\"http://example.org\">Example org link</a>] [attribute$=value] Represents elements with an attribute named attribute whose value ends with value . Syntax [ attr $= value ] [ attr $= \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href$=org]' )) [<a href=\"http://example.org\">Example org link</a>] [attribute*=value] Represents elements with an attribute named attribute whose value containing the substring value . Syntax [ attr *= value ] [ attr *= \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href*=\"example\"]' )) [<a href=\"http://example.com\">Example link</a>, <a href=\"http://example.org\">Example org link</a>] [attribute!=value] Equivalent to : not ([ attribute = value ]) . Syntax [ attr != value ] [ attr != \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'a[href!=\"#internal\"]' )) [<a href=\"http://example.com\">Example link</a>, <a href=\"#InSensitive\">Insensitive internal link</a>, <a href=\"http://example.org\">Example org link</a>] [attribute operator value i] Represents elements with an attribute named attribute and whose value, when the operator is applied, matches value without case sensitivity. In general, attribute comparison is insensitive in normal HTML, but not XML. i is most useful in XML documents. Syntax [ attr = value i ] [ attr = \"value\" i ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href=\"#INTERNAL\" i]' )) [<a href=\"#internal\">Internal link</a>] [attribute operator value s] Represents elements with an attribute named attribute and whose value, when the operator is applied, matches value with case sensitivity. Syntax [ attr = value s ] [ attr = \"value\" s ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href=\"#INTERNAL\" s]' )) [] >>> print ( soup . select ( '[href=\"#internal\" s]' )) [<a href=\"#internal\">Internal link</a>] Namespace Selectors Namespace selectors are used in conjunction with type and universal selectors as well as attribute names in attribute selectors. They are specified by declaring the namespace and the selector separated with | : namespace|selector . namespace , in this context, is the prefix defined via the namespace dictionary . The prefix defined for the CSS selector does not need to match the prefix name in the document as it is the namespace associated with the prefix that is compared, not the prefix itself. The universal selector ( * ) can be used to represent any namespace just as it can with types. By default, type selectors without a namespace selector will match any element whose type matches, regardless of namespace. But if a CSS default namespace is declared (one with an empty key: {\"\": \"http://www.w3.org/1999/xhtml\"} ), all type selectors will assume the default namespace unless an explicit namespace selector is specified. For example, if the default name was defined to be http://www.w3.org/1999/xhtml , the selector a would only match a tags that are within the http://www.w3.org/1999/xhtml namespace. The one exception is within pseudo classes ( :not() , :has() , etc.) as namespaces are not considered within pseudo classes unless one is explicitly specified. If the namespace is omitted ( |element ), any element without a namespace will be matched. In HTML documents that support namespaces (XHTML and HTML5), HTML elements are counted as part of the http://www.w3.org/1999/xhtml namespace, but attributes usually do not have a namespace unless one is explicitly defined in the markup. Namespaces can be used with attribute selectors as well except that when [|attribute ] is used, it is equivalent to [attribute] . Syntax ns | element ns |* *|* *| element | element [ ns | attr ] [*| attr ] [| attr ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <h1>SVG Example</h1> ... <p><a href=\"http://facelessuser.github.io/soupsieve/\">Soup Sieve Docs</a></p> ... ... <svg viewBox=\"0 0 160 40\" xmlns=\"http://www.w3.org/2000/svg\"> ... <a xlink:href=\"https://developer.mozilla.org/\"><text x=\"10\" y=\"25\">MDN Web Docs</text></a> ... </svg> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'svg|a' , namespaces = { 'svg' : 'http://www.w3.org/2000/svg' })) [<a xlink:href=\"https://developer.mozilla.org/\"><text x=\"10\" y=\"25\">MDN Web Docs</text></a>] >>> print ( soup . select ( 'a' , namespaces = { 'svg' : 'http://www.w3.org/2000/svg' })) [<a href=\"http://facelessuser.github.io/soupsieve/\">Soup Sieve Docs</a>, <a xlink:href=\"https://developer.mozilla.org/\"><text x=\"10\" y=\"25\">MDN Web Docs</text></a>] >>> print ( soup . select ( 'a' , namespaces = { '' : 'http://www.w3.org/1999/xhtml' , 'svg' : 'http://www.w3.org/2000/svg' })) [<a href=\"http://facelessuser.github.io/soupsieve/\">Soup Sieve Docs</a>] >>> print ( soup . select ( '[xlink|href]' , namespaces = { 'xlink' : 'http://www.w3.org/1999/xlink' })) [<a xlink:href=\"https://developer.mozilla.org/\"><text x=\"10\" y=\"25\">MDN Web Docs</text></a>] >>> print ( soup . select ( '[|href]' , namespaces = { 'xlink' : 'http://www.w3.org/1999/xlink' })) [<a href=\"http://facelessuser.github.io/soupsieve/\">Soup Sieve Docs</a>] html { --svg-beaker: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='beaker'%3E%3Cpath d='M3,3V5A2,2 0 0,1 5,7V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V7A2,2 0 0,1 21,5V3H3M7,9H10V10H7V9M7,11H10V12H7V11M10,16H7V15H10V16M12,14H7V13H12V14M12,8H7V7H12V8Z' /%3E%3C/svg%3E\"); --svg-html5: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath d='M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z'/%3E%3C/svg%3E\"); --svg-star: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='star'%3E%3Cpath d='M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z' /%3E%3C/svg%3E\"); } span.lab::after, span.html5::after, span.star::after { position: relative; display: inline-block; width: 1em; height: 1em; padding-right: 1em; background-size: 1em; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; content: \"\\a0\"; } span.big-icon::after { width: 3em; height: 3em; background-size: 3em; } .badge { float: right; } span.lab::after { background-color: hsl(265, 89%, 78%); -webkit-mask-image: var(--svg-beaker); mask-image: var(--svg-beaker); } span.html5::after { background-color: hsl(31, 100%, 71%); -webkit-mask-image: var(--svg-html5); mask-image: var(--svg-html5); } span.star::after { background-color: hsl(135, 94%, 65%); -webkit-mask-image: var(--svg-star); mask-image: var(--svg-star); }","title":"Basic Selectors"},{"location":"selectors/basic/#basic-selectors","text":"Syntax and notation for basic selectors.","title":"Basic Selectors"},{"location":"selectors/basic/#escapes","text":"Soup Sieve selectors support using CSS escapes. So if you need provide Unicode, or non-standard characters, you can use CSS style escapes. Escapes can be specified with a backslash followed by 1 - 6 hexadecimal digits: \\ 20AC , \\ 0020AC , etc. If you need to terminate an escape to avoid it accumulating unintended hexadecimal characters, you can use a space: \\ 0020AC dont-escape-me . You can also escape any non-hexadecimal character, and it will be treated as that character: \\ + \u2192 + . The one exception is that you cannot escape the form feed, newline, or carriage return. You can always use Soup Sieve's escape command to escape identifiers as well.","title":"Escapes"},{"location":"selectors/basic/#type-selectors","text":"Type selectors match elements by node name. If a default namespace is defined in the namespace dictionary , and no namespace is explicitly defined, it will be assumed that the element must be in the default namespace. Syntax element Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'div' )) [<div>Here is some text.</div>, <div>Here is some more text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Type_selectors","title":"Type Selectors"},{"location":"selectors/basic/#universal-selectors","text":"The Universal selector ( * ) matches elements of any type. Syntax * Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p>Here is some text.</p> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '*' )) [<html><head></head> <body> <div>Here is some text.</div> <div>Here is some more text.</div> </body></html>, <head></head>, <body> <div>Here is some text.</div> <div>Here is some more text.</div> </body>, <div>Here is some text.</div>, <div>Here is some more text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors","title":"Universal Selectors"},{"location":"selectors/basic/#id-selectors","text":"The ID selector matches an element based on its id attribute. The ID must match exactly. Syntax # id Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div id=\"some-id\">Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '#some-id' )) [<div id=\"some-id\">Here is some text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors XML Support While the use of the id attribute (in the context of CSS) is a very HTML centric idea, it is supported for XML as well because Beautiful Soup supported it before Soup Sieve's existence.","title":"ID Selectors"},{"location":"selectors/basic/#class-selectors","text":"The class selector matches an element based on the values contained in the class attribute. The class attribute is treated as a whitespace separated list, where each item is a class . Syntax . class Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div class=\"some-class\">Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '.some-class' )) [<div class=\"some-class\">Here is some text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors XML Support While the use of the class attribute (in the context of CSS) is a very HTML centric idea, it is supported for XML as well because Beautiful Soup supported it before Soup Sieve's existence.","title":"Class Selectors"},{"location":"selectors/basic/#attribute-selectors","text":"The attribute selector matches an element based on its attributes. When specifying a value of an attribute, if it contains whitespace or special characters, you should quote them with either single or double quotes. Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors [attribute] Represents elements with an attribute named attribute . Syntax [ attr ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href]' )) [<a href=\"#internal\">Internal link</a>, <a href=\"http://example.com\">Example link</a>, <a href=\"#InSensitive\">Insensitive internal link</a>, <a href=\"http://example.org\">Example org link</a>] [attribute=value] Represents elements with an attribute named attribute that also has a value of value . Syntax [ attr = value ] [ attr = \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href=\"#internal\"]' )) [<a href=\"#internal\">Internal link</a>] [attribute~=value] Represents elements with an attribute named attribute whose value is a space separated list which contains value . Syntax [ attr ~= value ] [ attr ~= \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\" class=\"class1 class2 class3\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[class~=class2]' )) [<a class=\"class1 class2 class3\" href=\"#internal\">Internal link</a>] [attribute|=value] Represents elements with an attribute named attribute whose value is a dash separated list that starts with value . Syntax [ attr |= value ] [ attr |= \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div lang=\"en\">Some text</div> ... <div lang=\"en-US\">Some more text</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'a[href!=\"#internal\"]' )) [<div lang=\"en\">Some text</div>, <div lang=\"en-US\">Some more text</div>] [attribute^=value] Represents elements with an attribute named attribute whose value starts with value . Syntax [ attr ^= value ] [ attr ^= \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href^=http]' )) [<a href=\"http://example.com\">Example link</a>, <a href=\"http://example.org\">Example org link</a>] [attribute$=value] Represents elements with an attribute named attribute whose value ends with value . Syntax [ attr $= value ] [ attr $= \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href$=org]' )) [<a href=\"http://example.org\">Example org link</a>] [attribute*=value] Represents elements with an attribute named attribute whose value containing the substring value . Syntax [ attr *= value ] [ attr *= \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href*=\"example\"]' )) [<a href=\"http://example.com\">Example link</a>, <a href=\"http://example.org\">Example org link</a>] [attribute!=value] Equivalent to : not ([ attribute = value ]) . Syntax [ attr != value ] [ attr != \"value\" ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'a[href!=\"#internal\"]' )) [<a href=\"http://example.com\">Example link</a>, <a href=\"#InSensitive\">Insensitive internal link</a>, <a href=\"http://example.org\">Example org link</a>] [attribute operator value i] Represents elements with an attribute named attribute and whose value, when the operator is applied, matches value without case sensitivity. In general, attribute comparison is insensitive in normal HTML, but not XML. i is most useful in XML documents. Syntax [ attr = value i ] [ attr = \"value\" i ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href=\"#INTERNAL\" i]' )) [<a href=\"#internal\">Internal link</a>] [attribute operator value s] Represents elements with an attribute named attribute and whose value, when the operator is applied, matches value with case sensitivity. Syntax [ attr = value s ] [ attr = \"value\" s ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <ul> ... <li><a href=\"#internal\">Internal link</a></li> ... <li><a href=\"http://example.com\">Example link</a></li> ... <li><a href=\"#InSensitive\">Insensitive internal link</a></li> ... <li><a href=\"http://example.org\">Example org link</a></li> ... </ul> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[href=\"#INTERNAL\" s]' )) [] >>> print ( soup . select ( '[href=\"#internal\" s]' )) [<a href=\"#internal\">Internal link</a>]","title":"Attribute Selectors"},{"location":"selectors/basic/#namespace-selectors","text":"Namespace selectors are used in conjunction with type and universal selectors as well as attribute names in attribute selectors. They are specified by declaring the namespace and the selector separated with | : namespace|selector . namespace , in this context, is the prefix defined via the namespace dictionary . The prefix defined for the CSS selector does not need to match the prefix name in the document as it is the namespace associated with the prefix that is compared, not the prefix itself. The universal selector ( * ) can be used to represent any namespace just as it can with types. By default, type selectors without a namespace selector will match any element whose type matches, regardless of namespace. But if a CSS default namespace is declared (one with an empty key: {\"\": \"http://www.w3.org/1999/xhtml\"} ), all type selectors will assume the default namespace unless an explicit namespace selector is specified. For example, if the default name was defined to be http://www.w3.org/1999/xhtml , the selector a would only match a tags that are within the http://www.w3.org/1999/xhtml namespace. The one exception is within pseudo classes ( :not() , :has() , etc.) as namespaces are not considered within pseudo classes unless one is explicitly specified. If the namespace is omitted ( |element ), any element without a namespace will be matched. In HTML documents that support namespaces (XHTML and HTML5), HTML elements are counted as part of the http://www.w3.org/1999/xhtml namespace, but attributes usually do not have a namespace unless one is explicitly defined in the markup. Namespaces can be used with attribute selectors as well except that when [|attribute ] is used, it is equivalent to [attribute] . Syntax ns | element ns |* *|* *| element | element [ ns | attr ] [*| attr ] [| attr ] Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <h1>SVG Example</h1> ... <p><a href=\"http://facelessuser.github.io/soupsieve/\">Soup Sieve Docs</a></p> ... ... <svg viewBox=\"0 0 160 40\" xmlns=\"http://www.w3.org/2000/svg\"> ... <a xlink:href=\"https://developer.mozilla.org/\"><text x=\"10\" y=\"25\">MDN Web Docs</text></a> ... </svg> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'svg|a' , namespaces = { 'svg' : 'http://www.w3.org/2000/svg' })) [<a xlink:href=\"https://developer.mozilla.org/\"><text x=\"10\" y=\"25\">MDN Web Docs</text></a>] >>> print ( soup . select ( 'a' , namespaces = { 'svg' : 'http://www.w3.org/2000/svg' })) [<a href=\"http://facelessuser.github.io/soupsieve/\">Soup Sieve Docs</a>, <a xlink:href=\"https://developer.mozilla.org/\"><text x=\"10\" y=\"25\">MDN Web Docs</text></a>] >>> print ( soup . select ( 'a' , namespaces = { '' : 'http://www.w3.org/1999/xhtml' , 'svg' : 'http://www.w3.org/2000/svg' })) [<a href=\"http://facelessuser.github.io/soupsieve/\">Soup Sieve Docs</a>] >>> print ( soup . select ( '[xlink|href]' , namespaces = { 'xlink' : 'http://www.w3.org/1999/xlink' })) [<a xlink:href=\"https://developer.mozilla.org/\"><text x=\"10\" y=\"25\">MDN Web Docs</text></a>] >>> print ( soup . select ( '[|href]' , namespaces = { 'xlink' : 'http://www.w3.org/1999/xlink' })) [<a href=\"http://facelessuser.github.io/soupsieve/\">Soup Sieve Docs</a>] html { --svg-beaker: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='beaker'%3E%3Cpath d='M3,3V5A2,2 0 0,1 5,7V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V7A2,2 0 0,1 21,5V3H3M7,9H10V10H7V9M7,11H10V12H7V11M10,16H7V15H10V16M12,14H7V13H12V14M12,8H7V7H12V8Z' /%3E%3C/svg%3E\"); --svg-html5: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath d='M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z'/%3E%3C/svg%3E\"); --svg-star: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='star'%3E%3Cpath d='M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z' /%3E%3C/svg%3E\"); } span.lab::after, span.html5::after, span.star::after { position: relative; display: inline-block; width: 1em; height: 1em; padding-right: 1em; background-size: 1em; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; content: \"\\a0\"; } span.big-icon::after { width: 3em; height: 3em; background-size: 3em; } .badge { float: right; } span.lab::after { background-color: hsl(265, 89%, 78%); -webkit-mask-image: var(--svg-beaker); mask-image: var(--svg-beaker); } span.html5::after { background-color: hsl(31, 100%, 71%); -webkit-mask-image: var(--svg-html5); mask-image: var(--svg-html5); } span.star::after { background-color: hsl(135, 94%, 65%); -webkit-mask-image: var(--svg-star); mask-image: var(--svg-star); }","title":"Namespace Selectors"},{"location":"selectors/combinators/","text":"Combinators and Selector Lists CSS employs a number of tokens in order to represent lists or to provide relational context between two selectors. Selector Lists Selector lists use the comma ( , ) to join multiple selectors in a list. When presented with a selector list, any selector in the list that matches an element will return that element. Syntax element1 , element2 Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <h1>Title</h1> ... <p>Paragraph</p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'h1, p' )) [<h1>Title</h1>, <p>Paragraph</p>] Descendant Combinator Descendant combinators combine two selectors with whitespace ( ) in order to signify that the second element is matched if it has an ancestor that matches the first element. Syntax parent descendant Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div><p>Paragraph 1</p></div> ... <div><p>Paragraph 2</p></div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'body p' )) [<p>Paragraph 1</p>, <p>Paragraph 2</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator Child combinator Child combinators combine two selectors with > in order to signify that the second element is matched if it has a parent that matches the first element. Syntax parent > child Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div><p>Paragraph 1</p></div> ... <div><ul><li><p>Paragraph 2</p></li></ul></div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'div > p' )) [<p>Paragraph 1</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Child_combinator General sibling combinator General sibling combinators combine two selectors with ~ in order to signify that the second element is matched if it has a sibling that precedes it that matches the first element. Syntax prevsibling ~ sibling Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <h1>Title</h1> ... <p>Paragraph 1</p> ... <p>Paragraph 2</p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'h1 ~ p' )) [<p>Paragraph 1</p>, <p>Paragraph 2</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_combinator Adjacent sibling combinator Adjacent sibling combinators combine two selectors with + in order to signify that the second element is matched if it has an adjacent sibling that precedes it that matches the first element. Syntax prevsibling + nextsibling Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <h1>Title</h1> ... <p>Paragraph 1</p> ... <p>Paragraph 2</p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'h1 ~ p' )) [<p>Paragraph 1</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_combinator html { --svg-beaker: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='beaker'%3E%3Cpath d='M3,3V5A2,2 0 0,1 5,7V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V7A2,2 0 0,1 21,5V3H3M7,9H10V10H7V9M7,11H10V12H7V11M10,16H7V15H10V16M12,14H7V13H12V14M12,8H7V7H12V8Z' /%3E%3C/svg%3E\"); --svg-html5: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath d='M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z'/%3E%3C/svg%3E\"); --svg-star: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='star'%3E%3Cpath d='M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z' /%3E%3C/svg%3E\"); } span.lab::after, span.html5::after, span.star::after { position: relative; display: inline-block; width: 1em; height: 1em; padding-right: 1em; background-size: 1em; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; content: \"\\a0\"; } span.big-icon::after { width: 3em; height: 3em; background-size: 3em; } .badge { float: right; } span.lab::after { background-color: hsl(265, 89%, 78%); -webkit-mask-image: var(--svg-beaker); mask-image: var(--svg-beaker); } span.html5::after { background-color: hsl(31, 100%, 71%); -webkit-mask-image: var(--svg-html5); mask-image: var(--svg-html5); } span.star::after { background-color: hsl(135, 94%, 65%); -webkit-mask-image: var(--svg-star); mask-image: var(--svg-star); }","title":"Combinators and Lists"},{"location":"selectors/combinators/#combinators-and-selector-lists","text":"CSS employs a number of tokens in order to represent lists or to provide relational context between two selectors.","title":"Combinators and Selector Lists"},{"location":"selectors/combinators/#selector-lists","text":"Selector lists use the comma ( , ) to join multiple selectors in a list. When presented with a selector list, any selector in the list that matches an element will return that element. Syntax element1 , element2 Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <h1>Title</h1> ... <p>Paragraph</p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'h1, p' )) [<h1>Title</h1>, <p>Paragraph</p>]","title":"Selector Lists"},{"location":"selectors/combinators/#descendant-combinator","text":"Descendant combinators combine two selectors with whitespace ( ) in order to signify that the second element is matched if it has an ancestor that matches the first element. Syntax parent descendant Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div><p>Paragraph 1</p></div> ... <div><p>Paragraph 2</p></div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'body p' )) [<p>Paragraph 1</p>, <p>Paragraph 2</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Descendant_combinator","title":"Descendant Combinator"},{"location":"selectors/combinators/#child-combinator","text":"Child combinators combine two selectors with > in order to signify that the second element is matched if it has a parent that matches the first element. Syntax parent > child Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div><p>Paragraph 1</p></div> ... <div><ul><li><p>Paragraph 2</p></li></ul></div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'div > p' )) [<p>Paragraph 1</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Child_combinator","title":"Child combinator"},{"location":"selectors/combinators/#general-sibling-combinator","text":"General sibling combinators combine two selectors with ~ in order to signify that the second element is matched if it has a sibling that precedes it that matches the first element. Syntax prevsibling ~ sibling Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <h1>Title</h1> ... <p>Paragraph 1</p> ... <p>Paragraph 2</p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'h1 ~ p' )) [<p>Paragraph 1</p>, <p>Paragraph 2</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/General_sibling_combinator","title":"General sibling combinator"},{"location":"selectors/combinators/#adjacent-sibling-combinator","text":"Adjacent sibling combinators combine two selectors with + in order to signify that the second element is matched if it has an adjacent sibling that precedes it that matches the first element. Syntax prevsibling + nextsibling Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <h1>Title</h1> ... <p>Paragraph 1</p> ... <p>Paragraph 2</p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'h1 ~ p' )) [<p>Paragraph 1</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_combinator html { --svg-beaker: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='beaker'%3E%3Cpath d='M3,3V5A2,2 0 0,1 5,7V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V7A2,2 0 0,1 21,5V3H3M7,9H10V10H7V9M7,11H10V12H7V11M10,16H7V15H10V16M12,14H7V13H12V14M12,8H7V7H12V8Z' /%3E%3C/svg%3E\"); --svg-html5: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath d='M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z'/%3E%3C/svg%3E\"); --svg-star: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='star'%3E%3Cpath d='M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z' /%3E%3C/svg%3E\"); } span.lab::after, span.html5::after, span.star::after { position: relative; display: inline-block; width: 1em; height: 1em; padding-right: 1em; background-size: 1em; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; content: \"\\a0\"; } span.big-icon::after { width: 3em; height: 3em; background-size: 3em; } .badge { float: right; } span.lab::after { background-color: hsl(265, 89%, 78%); -webkit-mask-image: var(--svg-beaker); mask-image: var(--svg-beaker); } span.html5::after { background-color: hsl(31, 100%, 71%); -webkit-mask-image: var(--svg-html5); mask-image: var(--svg-html5); } span.star::after { background-color: hsl(135, 94%, 65%); -webkit-mask-image: var(--svg-star); mask-image: var(--svg-star); }","title":"Adjacent sibling combinator"},{"location":"selectors/pseudo-classes/","text":"Pseudo-Classes Overview These are pseudo classes that are either fully or partially supported. Partial support is usually due to limitations of not being in a live, browser environment. Pseudo classes that cannot be implemented are found under Non-Applicable Pseudo Classes . Any selectors that are not found here or under the non-applicable either are under consideration, have not yet been evaluated, or are too new and viewed as a risk to implement as they might not stick around. :any-link Selects every < a > , < area > , or < link > element that has an href attribute, independent of whether it has been visited. Syntax : any-link Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p>A link to <a href=\"http://example.com\">click</a></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':any-link' )) [<a href=\"http://example.com\">click</a>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:any-link :checked Selects any < input type = \"radio\" /> , < input type = \"checkbox\" /> , or < option > element (in a < select > element) that is checked or toggled to an on state. Syntax : checked Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... ... <div> ... <input type=\"radio\" name=\"my-input\" id=\"yes\" checked> ... <label for=\"yes\">Yes</label> ... ... <input type=\"radio\" name=\"my-input\" id=\"no\"> ... <label for=\"no\">No</label> ... </div> ... ... <select name=\"my-select\" id=\"fruit\"> ... <option id=\"1\" value=\"opt1\">Apples</option> ... <option id=\"2\" value=\"opt2\" selected>Grapes</option> ... <option id=\"3\" value=\"opt3\">Pears</option> ... </select> ... ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':checked' )) [<input checked=\"\" id=\"yes\" name=\"my-input\" type=\"radio\"/>, <option id=\"2\" selected=\"\" value=\"opt2\">Grapes</option>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:checked :contains() Selects elements that contain the provided text. Text can be found in either itself, or its descendants. Contains was originally included in a CSS early draft , but was, in the end, dropped from the draft. Soup Sieve implements it how it was originally proposed in the draft with the addition that :contains() can accept either a single value, or a comma separated list of values. An element needs only to match at least one of the items in the comma separated list to be considered matching. Contains :contains() is an expensive operation as it scans all the text nodes of an element under consideration, which includes all descendants. Using highly specific selectors can reduce how often it is evaluated. Syntax : contains ( text ) : contains ( \"This text\" , \"or this text\" ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is <span>some text</span>.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'div:contains(\"some text\")' )) [<div>Here is <span>some text</span>.</div>] :default Selects any form element that is the default among a group of related elements, including: < button > , < input type = \"checkbox\" > , < input type = \"radio\" > , < option > elements. Syntax : default Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <form> ... ... <input type=\"radio\" name=\"season\" id=\"spring\"> ... <label for=\"spring\">Spring</label> ... ... <input type=\"radio\" name=\"season\" id=\"summer\" checked> ... <label for=\"summer\">Summer</label> ... ... <input type=\"radio\" name=\"season\" id=\"fall\"> ... <label for=\"fall\">Fall</label> ... ... <input type=\"radio\" name=\"season\" id=\"winter\"> ... <label for=\"winter\">Winter</label> ... ... <select id=\"pet-select\"> ... <option value=\"\">--Please choose an option--</option> ... <option id=\"dog\" value=\"dog\">Dog</option> ... <option id=\"cat\" value=\"cat\">Cat</option> ... <option id=\"hamster\" value=\"hamster\" selected>Hamster</option> ... <option id=\"parrot\" value=\"parrot\">Parrot</option> ... <option id=\"spider\" value=\"spider\">Spider</option> ... <option id=\"goldfish\" value=\"goldfish\">Goldfish</option> ... </select> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':default' )) [<input checked=\"\" id=\"summer\" name=\"season\" type=\"radio\"/>, <option id=\"hamster\" selected=\"\" value=\"hamster\">Hamster</option>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:default :defined In a browser environment, this represents defined elements (names without hyphens) and custom elements (names with hyphens) that have been properly added to the custom element registry. Since elements cannot be added to a custom element registry in Beautiful Soup, this will select all elements that are not custom tags. :defined is a HTML specific selector, so it doesn't apply to XML. Syntax : defined Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <custom-element text=\"Custom element example text\"></custom-element> ... <p>Standard paragraph example text</p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'body > *:defined' )) [<p>Standard paragraph example text</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:defined :dir() Selects elements based on text directionality. Accepts either ltr or rtl for \"left to right\" and \"right to left\" respectively. Syntax : dir ( ltr ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div> ... <span dir=\"auto\">\u05d6\u05d0\u05ea \u05d4\u05e9\u05e4\u05d4 \u05d4\u05e2\u05d1\u05e8\u05d9\u05ea</span> ... <span dir=\"ltr\">Text</span> ... </div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':dir(rtl)' )) [<span dir=\"auto\">\u05d6\u05d0\u05ea \u05d4\u05e9\u05e4\u05d4 \u05d4\u05e2\u05d1\u05e8\u05d9\u05ea</span>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:dir :disabled Selects any element that is disabled. Syntax : disabled Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <form action=\"#\"> ... <fieldset id=\"shipping\"> ... <legend>Shipping address</legend> ... <input type=\"text\" placeholder=\"Name\"> ... <input type=\"text\" placeholder=\"Address\"> ... <input type=\"text\" placeholder=\"Zip Code\"> ... </fieldset> ... <br> ... <fieldset id=\"billing\"> ... <legend>Billing address</legend> ... <label for=\"billing-checkbox\">Same as shipping address:</label> ... <input type=\"checkbox\" id=\"billing-checkbox\" checked> ... <br> ... <input type=\"text\" placeholder=\"Name\" disabled> ... <input type=\"text\" placeholder=\"Address\" disabled> ... <input type=\"text\" placeholder=\"Zip Code\" disabled> ... </fieldset> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'input:disabled' )) [<input disabled=\"\" placeholder=\"Name\" type=\"text\"/>, <input disabled=\"\" placeholder=\"Address\" type=\"text\"/>, <input disabled=\"\" placeholder=\"Zip Code\" type=\"text\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:disabled :empty Selects elements that have no children and no text (whitespace is ignored). Syntax : empty Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <span> <!-- comment --> </span> ... <span></span> ... <span><span> </span></span> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'body :empty' )) [<span> <!-- comment --> </span>, <span></span>, <span> </span>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:empty :enabled Selects any element that is enabled. Syntax : enabled Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <form action=\"#\"> ... <fieldset id=\"shipping\"> ... <legend>Shipping address</legend> ... <input type=\"text\" placeholder=\"Name\"> ... <input type=\"text\" placeholder=\"Address\"> ... <input type=\"text\" placeholder=\"Zip Code\"> ... </fieldset> ... <br> ... <fieldset id=\"billing\"> ... <legend>Billing address</legend> ... <label for=\"billing-checkbox\">Same as shipping address:</label> ... <input type=\"checkbox\" id=\"billing-checkbox\" checked> ... <br> ... <input type=\"text\" placeholder=\"Name\" disabled> ... <input type=\"text\" placeholder=\"Address\" disabled> ... <input type=\"text\" placeholder=\"Zip Code\" disabled> ... </fieldset> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'input:enabled' )) [<input placeholder=\"Name\" type=\"text\"/>, <input placeholder=\"Address\" type=\"text\"/>, <input placeholder=\"Zip Code\" type=\"text\"/>, <input checked=\"\" id=\"billing-checkbox\" type=\"checkbox\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:enabled :first-child Selects the first child in a group of sibling elements. Syntax : first-child Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:first-child' )) [<p id=\"0\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:first-child :first-of-type Selects the first child of a given type in a group of sibling elements. Syntax element : first-of-type Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <span id=\"2\"></span> ... <span id=\"3\"></span> ... <span id=\"4\"></span> ... <span id=\"5\"></span> ... <span id=\"6\"></span> ... <p id=\"7\"></p> ... <p id=\"8\"></p> ... <p id=\"9\"></p> ... <p id=\"10\"></p> ... <span id=\"11\"></span> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'span:first-of-type' )) [<span id=\"2\"></span>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:first-of-type :has() Selects an element if any of the relative selectors passed as parameters (which are relative to the :scope of the given element), match at least one element. While the level 4 specifications state that compound selectors are supported, complex selectors are planned for level 5 CSS selectors. Soup Sieve supports complex selectors. Syntax : has ( selector ) : has (> selector ) : has (~ selector ) : has (+ selector ) : has ( selector1 , > selector2 , ~ selector3 , + selector4 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div><p>Test <span>paragraph</span></p></div> ... <div><p class=\"class\">Another test paragraph</p></div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'div:has(span, > .class)' )) [<div><p>Test <span>paragraph</span></p></div>, <div><p class=\"class\">Another test paragraph</p></div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:has :in-range Selects all < input > elements whose values are in range according to their type , min , and max attributes. Syntax : in-range Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <input id=\"0\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1999-05\"> ... <input id=\"7\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1979-02\"> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':in-range' )) [<input id=\"0\" max=\"2004-08\" min=\"1980-02\" type=\"month\" value=\"1999-05\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:in-range :indeterminate Selects all form elements whose are in an indeterminate state. An element is considered indeterminate if: The element is of type < input type = \"checkbox\" /> and the indeterminate attribute is set. The element is of type < input type = \"radio\" /> and all other radio controls with the same name are not selected. The element is of type < progress > with no value. Syntax : indeterminate Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <input type=\"checkbox\" id=\"checkbox1\" indeterminate> ... <label for=\"checkbox1\">I like cats.</label> ... ... <input type=\"checkbox\" id=\"checkbox2\"> ... <label for=\"checkbox2\">I like dogs.</label> ... ... <form> ... <input type=\"radio\" name=\"test\" id=\"radio1\"> ... <label for=\"radio1\">Yes</label> ... ... <input type=\"radio\" name=\"test\" id=\"radio2\"> ... <label for=\"radio2\">No</label> ... ... <input type=\"radio\" name=\"test\" id=\"radio3\"> ... <label for=\"radio3\">Maybe</label> ... </form> ... <form> ... <input type=\"radio\" name=\"another\" id=\"radio4\"> ... <label for=\"radio4\">Red</label> ... ... <input type=\"radio\" name=\"another\" id=\"radio5\" checked> ... <label for=\"radio5\">Green</label> ... ... <input type=\"radio\" name=\"another\" id=\"radio6\"> ... <label for=\"radio6\">Blue</label> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':indeterminate' )) [<input id=\"checkbox1\" indeterminate=\"\" type=\"checkbox\"/>, <input id=\"radio1\" name=\"test\" type=\"radio\"/>, <input id=\"radio2\" name=\"test\" type=\"radio\"/>, <input id=\"radio3\" name=\"test\" type=\"radio\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:indeterminate :is() Selects an element, but only if it matches at least one selector in the selector list. The alias :matches() is also supported as it was the original name for the selector, and some browsers support it. It is strongly encouraged to use :is() instead as support for :matches() may be dropped in the future. While the level 4 specifications state that compound selectors are supported, some browsers (Safari) support complex selectors which are planned for level 5 CSS selectors. Soup Sieve also supports complex selectors. Syntax : is ( selector1 , selector2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>. ... <a id=\"2\" href=\"http://google.com\">Link.</a></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[id]:is(a, span)' )) [<span id=\"1\"> in a paragraph</span>, <a href=\"http://google.com\" id=\"2\">Link.</a>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:is :lang() Level 3 CSS Selects an element whose associated language matches the provided language or whose language starts with the provided language followed by a - . Language is determined by the rules of the document type. Syntax : lang ( language ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div lang=\"de-DE\"> ... <p id=\"1\"></p> ... </div> ... <div lang=\"de-DE-1996\"> ... <p id=\"2\"></p> ... </div> ... <div lang=\"de-Latn-DE\"> ... <p id=\"3\"></p> ... </div> ... <div lang=\"de-Latf-DE\"> ... <p id=\"4\"></p> ... </div> ... <div lang=\"de-Latn-DE-1996\"> ... <p id=\"5\"></p> ... </div> ... <p id=\"6\" lang=\"de-DE\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:lang(de)' )) [<p id=\"1\"></p>, <p id=\"2\"></p>, <p id=\"3\"></p>, <p id=\"4\"></p>, <p id=\"5\"></p>, <p id=\"6\" lang=\"de-DE\"></p>] Level 4 CSS The level 4 CSS specifications adds the ability to define multiple language tags using a comma separated list. The specifications also allow for BCP 47 language ranges as described in RFC4647 for extended filtering. This enables implicit wildcard matching between subtags. For instance, :lang(de-DE) will match all of de-DE , de-DE-1996 , de-Latn-DE , de-Latf-DE , and de-Latn-DE-1996 . Implicit wildcard matching will not take place at the beginning on the primary language tag, * must be used to force wildcard matching at the beginning of the language. If desired an explicit wildcard between subtags can be used, but since implicit wildcard matching already takes place between subtags, it is not needed: de-*-DE would be the same as just using de-DE . Syntax : lang ( '*-language' , language2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div lang=\"de-DE\"> ... <p id=\"1\"></p> ... </div> ... <div lang=\"en\"> ... <p id=\"2\"></p> ... </div> ... <div lang=\"de-Latn-DE\"> ... <p id=\"3\"></p> ... </div> ... <div lang=\"de-Latf-DE\"> ... <p id=\"4\"></p> ... </div> ... <div lang=\"en-US\"> ... <p id=\"5\"></p> ... </div> ... <p id=\"6\" lang=\"de-DE\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:lang(de-DE, \"*-US\")' )) [<p id=\"1\"></p>, <p id=\"3\"></p>, <p id=\"4\"></p>, <p id=\"5\"></p>, <p id=\"6\" lang=\"de-DE\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:lang :last-child Selects the last element among a group of sibling elements. Syntax : last-child Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:last-child' )) [<p id=\"5\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:last-child :last-of-type Selects the last child of a given type in a group of sibling elements. Syntax element : last-of-type Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <span id=\"2\"></span> ... <span id=\"3\"></span> ... <span id=\"4\"></span> ... <span id=\"5\"></span> ... <span id=\"6\"></span> ... <p id=\"7\"></p> ... <p id=\"8\"></p> ... <p id=\"9\"></p> ... <p id=\"10\"></p> ... <span id=\"11\"></span> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'span:last-of-type' )) [<span id=\"11\"></span>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:last-of-type :link Selects a link (every < a > , < link > , and < area > element with an href attribute) that has not yet been visited. Since Beautiful Soup does not have visited states, this will match all links, essentially making the behavior the same as :any-link . Syntax : link Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p>A link to <a href=\"http://example.com\">click</a></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':link' )) [<a href=\"http://example.com\">click</a>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:link :not() Level 3 CSS Selects all elements that do not match the selector. The level 3 CSS specification states that :not() only supports simple selectors. Syntax : not ( simple-selector ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'div:not(:contains(more))' )) [<div>Here is some text.</div>] Level 4+ CSS Selects all elements that do not match any of the selectors in the selector list. While the level 4 specifications state that compound selectors are supported, some browsers (Safari) support complex selectors which are planned for level 5 CSS selectors. Soup Sieve also supports complex selectors. Syntax : not ( compound . selector , complex > selector ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '*:not(html, head, body)' )) [<div>Here is some text.</div>, <div>Here is some more text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:not :nth-child() :nth-child() matches elements based on their position in a group of siblings. Level 3 CSS The keywords even and odd will respectively select elements whose position is either even or odd amongst a group of siblings. Patterns in the form an+b selects elements based on their position in a group of siblings, for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Syntax : nth-child ( even ) : nth-child ( odd ) : nth-child ( 2 ) : nth-child ( 2n + 2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:nth-child(even)' )) [<p id=\"1\"></p>, <p id=\"3\"></p>, <p id=\"5\"></p>] >>> print ( soup . select ( 'p:nth-child(odd)' )) [<p id=\"0\"></p>, <p id=\"2\"></p>, <p id=\"4\"></p>] >>> print ( soup . select ( 'p:nth-child(2)' )) [<p id=\"1\"></p>] >>> print ( soup . select ( 'p:nth-child(-n+3)' )) [<p id=\"0\"></p>, <p id=\"1\"></p>, <p id=\"2\"></p>] Level 4+ CSS Level 4 CSS adds the additional pattern in the form an+b of S where S represents a selector list. an+b can also be substituted with even or odd . Wen using the pattern an+b of S , the pattern will select elements from a sub-group of sibling elements that all match the selector list ( [of S]? ), based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Essentially, img : nth-of-type ( 2 ) would be equivalent to : nth-child ( 2 of img ) . The advantage of using :nth-child(an+b [of S]?) over :nth-of-type is that :nth-of-type is restricted to types, while :nth-child(an+b [of S]?) can use complex selectors. While the level 4 specifications state that compound selectors are supported, complex selectors are planned for level 5 CSS selectors. Soup Sieve supports complex selectors. Syntax : nth-child ( 2 of img ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '*:nth-child(-n+3 of [id])' )) [<p id=\"0\"></p>, <p id=\"1\"></p>, <p id=\"2\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child :nth-last-child() :nth-last-child() matches elements based on their position in a group of siblings, counting from the end. Level 3 CSS Counting from the end, the keywords even and odd will respectively select elements whose position is either even or odd amongst a group of siblings. Counting from the end, patterns in the form an+b selects elements based on their position in a group of siblings, for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Syntax : nth-last-child ( even ) : nth-last-child ( odd ) : nth-last-child ( 2 ) : nth-last-child ( 2n + 2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:nth-last-child(even)' )) [<p id=\"0\"></p>, <p id=\"2\"></p>, <p id=\"4\"></p>] >>> print ( soup . select ( 'p:nth-last-child(odd)' )) [<p id=\"1\"></p>, <p id=\"3\"></p>, <p id=\"5\"></p>] >>> print ( soup . select ( 'p:nth-last-child(2)' )) [<p id=\"4\"></p>] >>> print ( soup . select ( 'p:nth-last-child(-n+3)' )) [<p id=\"3\"></p>, <p id=\"4\"></p>, <p id=\"5\"></p>] Level 4+ CSS Level 4 CSS adds the additional pattern in the form an+b of S where S represents a selector list. an+b can also be substituted with even or odd . Wen using the pattern an+b of S , the pattern will select elements from a sub-group of sibling elements that all match the selector list ( [of S]? ), based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Elements will be counted from the end. Essentially, img : nth-last-of-type ( 2 ) would be equivalent to : nth-last-child ( 2 of img ) . The advantage of using :nth-last-child(an+b [of S]?) over :nth-last-of-type is that :nth-last-of-type is restricted to types, while :nth-last-child(an+b [of S]?) can use complex selectors. While the level 4 specifications state that compound selectors are supported, complex selectors are planned for level 5 CSS selectors. Soup Sieve supports complex selectors. Syntax : nth-last-child ( 2 of img ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '*:nth-last-child(-n+3 of [id])' )) [<p id=\"3\"></p>, <p id=\"4\"></p>, <p id=\"5\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-last-child :nth-last-of-type() :nth-of-type() matches elements of a given type, based on their position among a group of siblings, counting from the end. The keywords even and odd , and will respectively select elements, from a sub-group of sibling elements that all match the given type, whose position is either even or odd amongst that sub-group of siblings. Starting position is counted from the end. Patterns in the form an+b select from a sub-group of sibling elements that all match the given type, based on their position within that sub-group, for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Starting position is counted from the end. Syntax element : nth-last-of-type ( even ) element : nth-last-of-type ( odd ) element : nth-last-of-type ( 2 ) element : nth-last-of-type ( 2n + 2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <span id=\"2\"></span> ... <span id=\"3\"></span> ... <span id=\"4\"></span> ... <span id=\"5\"></span> ... <span id=\"6\"></span> ... <p id=\"7\"></p> ... <p id=\"8\"></p> ... <p id=\"9\"></p> ... <p id=\"10\"></p> ... <span id=\"11\"></span> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'span:nth-last-of-type(even)' )) [<span id=\"2\"></span>, <span id=\"4\"></span>, <span id=\"6\"></span>] >>> print ( soup . select ( 'span:nth-last-of-type(odd)' )) [<span id=\"3\"></span>, <span id=\"5\"></span>, <span id=\"11\"></span>] >>> print ( soup . select ( 'p:nth-last-of-type(2)' )) [<p id=\"9\"></p>] >>> print ( soup . select ( 'p:nth-last-of-type(-n+3)' )) [<p id=\"8\"></p>, <p id=\"9\"></p>, <p id=\"10\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-last-of-type :nth-of-type() :nth-of-type() matches elements of a given type, based on their position among a group of siblings. The keywords even and odd , and will respectively select elements, from a sub-group of sibling elements that all match the given type, whose position is either even or odd amongst that sub-group of siblings. Patterns in the form an+b select from a sub-group of sibling elements that all match the given type, based on their position within that sub-group, for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Syntax element : nth-of-type ( even ) element : nth-of-type ( odd ) element : nth-of-type ( 2 ) element : nth-of-type ( 2n + 2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <span id=\"2\"></span> ... <span id=\"3\"></span> ... <span id=\"4\"></span> ... <span id=\"5\"></span> ... <span id=\"6\"></span> ... <p id=\"7\"></p> ... <p id=\"8\"></p> ... <p id=\"9\"></p> ... <p id=\"10\"></p> ... <span id=\"11\"></span> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'span:nth-of-type(even)' )) [<span id=\"3\"></span>, <span id=\"5\"></span>, <span id=\"11\"></span>] >>> print ( soup . select ( 'span:nth-of-type(odd)' )) [<span id=\"2\"></span>, <span id=\"4\"></span>, <span id=\"6\"></span>] >>> print ( soup . select ( 'p:nth-of-type(2)' )) [<p id=\"1\"></p>] >>> print ( soup . select ( 'p:nth-of-type(-n+3)' )) [<p id=\"0\"></p>, <p id=\"1\"></p>, <p id=\"7\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-of-type :only-child Selects element without any siblings. Syntax : only-child Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </div> ... <div> ... <p id=\"6\"></p> ... </div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:only-child' )) [<p id=\"6\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:only-child :only-of-type Selects element without any siblings that matches a given type. Syntax element : only-of-type Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <span id=\"2\"></span> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... <p id=\"6\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'span:only-of-type' )) [<span id=\"2\"></span>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:only-of-type :optional Selects any < input > , < select > , or < textarea > element that does not have the required attribute set on it. Syntax : optional Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <form> ... <input type=\"name\" required> ... <input type=\"checkbox\" required> ... <input type=\"email\"> ... <textarea name=\"name\" cols=\"30\" rows=\"10\" required></textarea> ... <select name=\"nm\" required> ... <!-- options --> ... </select> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':optional' )) [<input type=\"email\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:optional :out-of-range Selects all < input > elements whose values are out of range according to their type , min , and max attributes. Syntax : out-of-range Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <input id=\"0\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1999-05\"> ... <input id=\"7\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1979-02\"> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':out-of-range' )) [<input id=\"7\" max=\"2004-08\" min=\"1980-02\" type=\"month\" value=\"1979-02\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:out-of-range :placeholder-shown Selects any < input > or < textarea > element that is currently displaying placeholder text via the placeholder attribute. Syntax : placeholder-shown Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <input id=\"0\" placeholder=\"This is some text\"> ... <textarea id=\"1\" placeholder=\"This is some text\"></textarea> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':placeholder-shown' )) [<input id=\"0\" placeholder=\"This is some text\"/>, <textarea id=\"1\" placeholder=\"This is some text\"></textarea>] Parser Differences In general, when an input has a placeholder, but the element also has valid content, the placeholder is not shown. For instance, when a textarea has actual text associated with the element, the placeholder is overridden with the actual content. A textarea is allowed no more than a single newline to be considered as having no content (carriage returns don't count). html5lib will strip out carriage returns, but lxml and html.parser will not. This will cause a difference between the parsers when dealing with Windows style line endings and textareas . html5lib seems to follow closest to what real browsers do. Soup Sieve is simply following the specification as best it can. Unfortunately, it can't account for the quirks of the parsers in this case without introducing other issues. Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:placeholder-shown :read-only Selects elements (such as < input > or < textarea > ) that are not editable by the user. This does not just apply to form elements with readonly set, but it applies to any element that cannot be edited by the user. Syntax : read-only Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... ... <input id=\"0\"> ... <input id=\"1\" disabled> ... <input id=\"2\" type=\"number\" readonly> ... ... <textarea id=\"3\"></textarea> ... ... <p id=\"4\">Not editable</p> ... <p id=\"5\" contenteditable=\"true\">Editable text</p> ... ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'body :read-only' )) [<input disabled=\"\" id=\"1\"/>, <input id=\"2\" readonly=\"\" type=\"number\"/>, <p id=\"4\">Not editable</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:read-only :read-write Selects elements (such as < input > or < textarea > ) that are editable by the user. This does not just apply to form elements as it applies to any element that can be edited by the user, such as a < p > element with contenteditable set on it. Syntax : read-only Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... ... <input id=\"0\"> ... <input id=\"1\" disabled> ... <input id=\"2\" type=\"number\" readonly> ... ... <textarea id=\"3\"></textarea> ... ... <p id=\"4\">Not editable</p> ... <p id=\"5\" contenteditable=\"true\">Editable text</p> ... ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'body :read-write' )) [<input id=\"0\"/>, <textarea id=\"3\"></textarea>, <p contenteditable=\"true\" id=\"5\">Editable text</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:read-write :required Selects any < input > , < select > , or < textarea > element that has the required attribute set on it. Syntax : required Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <form> ... <input type=\"name\" required> ... <input type=\"checkbox\" required> ... <input type=\"email\"> ... <textarea name=\"name\" cols=\"30\" rows=\"10\" required></textarea> ... <select name=\"nm\" required> ... <!-- options --> ... </select> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':required' )) [<input required=\"\" type=\"name\"/>, <input required=\"\" type=\"checkbox\"/>, <textarea cols=\"30\" name=\"name\" required=\"\" rows=\"10\"></textarea>, <select name=\"nm\" required=\"\"> <!-- options --> </select>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:required :root Selects the root element of a document tree. Syntax : root Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':root' )) [<html><head></head> <body> <div>Here is some text.</div> <div>Here is some more text.</div> </body></html>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:root :scope :scope represents the the element a match , select , or filter is being called on. If we were, for instance, using :scope on a div ( sv . select ( ':scope > p' , soup . div ) ) :scope would represent that div element, and no others. If called on the Beautiful Soup object which represents the entire document, it would simply select :root . Syntax : scope Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select_one ( 'body' ) . select ( ':scope > div' )) [<div>Here is some text.</div>, <div>Here is some more text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:scope :where() Selects an element, but only if it matches at least one selector in the selector list. In browsers, this also has zero specificity, but this only has relevance in a browser environment where you have multiple CSS styles, and specificity is used to see which applies. Beautiful Soup and Soup Sieve don't care about specificity so :where() is essentially just an alias for :is() . While the level 4 specifications state that compound selectors are supported, some browsers (Safari) support complex selectors which are planned for level 5 CSS selectors. Soup Sieve also supports complex selectors. Syntax : where ( selector1 , selector2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>. ... <a id=\"2\" href=\"http://google.com\">Link.</a></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[id]:where(a, span)' )) [<span id=\"1\"> in a paragraph</span>, <a href=\"http://google.com\" id=\"2\">Link.</a>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:where html { --svg-beaker: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='beaker'%3E%3Cpath d='M3,3V5A2,2 0 0,1 5,7V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V7A2,2 0 0,1 21,5V3H3M7,9H10V10H7V9M7,11H10V12H7V11M10,16H7V15H10V16M12,14H7V13H12V14M12,8H7V7H12V8Z' /%3E%3C/svg%3E\"); --svg-html5: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath d='M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z'/%3E%3C/svg%3E\"); --svg-star: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='star'%3E%3Cpath d='M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z' /%3E%3C/svg%3E\"); } span.lab::after, span.html5::after, span.star::after { position: relative; display: inline-block; width: 1em; height: 1em; padding-right: 1em; background-size: 1em; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; content: \"\\a0\"; } span.big-icon::after { width: 3em; height: 3em; background-size: 3em; } .badge { float: right; } span.lab::after { background-color: hsl(265, 89%, 78%); -webkit-mask-image: var(--svg-beaker); mask-image: var(--svg-beaker); } span.html5::after { background-color: hsl(31, 100%, 71%); -webkit-mask-image: var(--svg-html5); mask-image: var(--svg-html5); } span.star::after { background-color: hsl(135, 94%, 65%); -webkit-mask-image: var(--svg-star); mask-image: var(--svg-star); }","title":"Pseudo Classes"},{"location":"selectors/pseudo-classes/#pseudo-classes","text":"","title":"Pseudo-Classes"},{"location":"selectors/pseudo-classes/#overview","text":"These are pseudo classes that are either fully or partially supported. Partial support is usually due to limitations of not being in a live, browser environment. Pseudo classes that cannot be implemented are found under Non-Applicable Pseudo Classes . Any selectors that are not found here or under the non-applicable either are under consideration, have not yet been evaluated, or are too new and viewed as a risk to implement as they might not stick around.","title":"Overview"},{"location":"selectors/pseudo-classes/#:any-link","text":"Selects every < a > , < area > , or < link > element that has an href attribute, independent of whether it has been visited. Syntax : any-link Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p>A link to <a href=\"http://example.com\">click</a></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':any-link' )) [<a href=\"http://example.com\">click</a>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:any-link","title":":any-link"},{"location":"selectors/pseudo-classes/#:checked","text":"Selects any < input type = \"radio\" /> , < input type = \"checkbox\" /> , or < option > element (in a < select > element) that is checked or toggled to an on state. Syntax : checked Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... ... <div> ... <input type=\"radio\" name=\"my-input\" id=\"yes\" checked> ... <label for=\"yes\">Yes</label> ... ... <input type=\"radio\" name=\"my-input\" id=\"no\"> ... <label for=\"no\">No</label> ... </div> ... ... <select name=\"my-select\" id=\"fruit\"> ... <option id=\"1\" value=\"opt1\">Apples</option> ... <option id=\"2\" value=\"opt2\" selected>Grapes</option> ... <option id=\"3\" value=\"opt3\">Pears</option> ... </select> ... ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':checked' )) [<input checked=\"\" id=\"yes\" name=\"my-input\" type=\"radio\"/>, <option id=\"2\" selected=\"\" value=\"opt2\">Grapes</option>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:checked","title":":checked"},{"location":"selectors/pseudo-classes/#:contains","text":"Selects elements that contain the provided text. Text can be found in either itself, or its descendants. Contains was originally included in a CSS early draft , but was, in the end, dropped from the draft. Soup Sieve implements it how it was originally proposed in the draft with the addition that :contains() can accept either a single value, or a comma separated list of values. An element needs only to match at least one of the items in the comma separated list to be considered matching. Contains :contains() is an expensive operation as it scans all the text nodes of an element under consideration, which includes all descendants. Using highly specific selectors can reduce how often it is evaluated. Syntax : contains ( text ) : contains ( \"This text\" , \"or this text\" ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is <span>some text</span>.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'div:contains(\"some text\")' )) [<div>Here is <span>some text</span>.</div>]","title":":contains()"},{"location":"selectors/pseudo-classes/#:default","text":"Selects any form element that is the default among a group of related elements, including: < button > , < input type = \"checkbox\" > , < input type = \"radio\" > , < option > elements. Syntax : default Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <form> ... ... <input type=\"radio\" name=\"season\" id=\"spring\"> ... <label for=\"spring\">Spring</label> ... ... <input type=\"radio\" name=\"season\" id=\"summer\" checked> ... <label for=\"summer\">Summer</label> ... ... <input type=\"radio\" name=\"season\" id=\"fall\"> ... <label for=\"fall\">Fall</label> ... ... <input type=\"radio\" name=\"season\" id=\"winter\"> ... <label for=\"winter\">Winter</label> ... ... <select id=\"pet-select\"> ... <option value=\"\">--Please choose an option--</option> ... <option id=\"dog\" value=\"dog\">Dog</option> ... <option id=\"cat\" value=\"cat\">Cat</option> ... <option id=\"hamster\" value=\"hamster\" selected>Hamster</option> ... <option id=\"parrot\" value=\"parrot\">Parrot</option> ... <option id=\"spider\" value=\"spider\">Spider</option> ... <option id=\"goldfish\" value=\"goldfish\">Goldfish</option> ... </select> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':default' )) [<input checked=\"\" id=\"summer\" name=\"season\" type=\"radio\"/>, <option id=\"hamster\" selected=\"\" value=\"hamster\">Hamster</option>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:default","title":":default"},{"location":"selectors/pseudo-classes/#:defined","text":"In a browser environment, this represents defined elements (names without hyphens) and custom elements (names with hyphens) that have been properly added to the custom element registry. Since elements cannot be added to a custom element registry in Beautiful Soup, this will select all elements that are not custom tags. :defined is a HTML specific selector, so it doesn't apply to XML. Syntax : defined Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <custom-element text=\"Custom element example text\"></custom-element> ... <p>Standard paragraph example text</p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'body > *:defined' )) [<p>Standard paragraph example text</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:defined","title":":defined"},{"location":"selectors/pseudo-classes/#:dir","text":"Selects elements based on text directionality. Accepts either ltr or rtl for \"left to right\" and \"right to left\" respectively. Syntax : dir ( ltr ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div> ... <span dir=\"auto\">\u05d6\u05d0\u05ea \u05d4\u05e9\u05e4\u05d4 \u05d4\u05e2\u05d1\u05e8\u05d9\u05ea</span> ... <span dir=\"ltr\">Text</span> ... </div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':dir(rtl)' )) [<span dir=\"auto\">\u05d6\u05d0\u05ea \u05d4\u05e9\u05e4\u05d4 \u05d4\u05e2\u05d1\u05e8\u05d9\u05ea</span>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:dir","title":":dir()"},{"location":"selectors/pseudo-classes/#:disabled","text":"Selects any element that is disabled. Syntax : disabled Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <form action=\"#\"> ... <fieldset id=\"shipping\"> ... <legend>Shipping address</legend> ... <input type=\"text\" placeholder=\"Name\"> ... <input type=\"text\" placeholder=\"Address\"> ... <input type=\"text\" placeholder=\"Zip Code\"> ... </fieldset> ... <br> ... <fieldset id=\"billing\"> ... <legend>Billing address</legend> ... <label for=\"billing-checkbox\">Same as shipping address:</label> ... <input type=\"checkbox\" id=\"billing-checkbox\" checked> ... <br> ... <input type=\"text\" placeholder=\"Name\" disabled> ... <input type=\"text\" placeholder=\"Address\" disabled> ... <input type=\"text\" placeholder=\"Zip Code\" disabled> ... </fieldset> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'input:disabled' )) [<input disabled=\"\" placeholder=\"Name\" type=\"text\"/>, <input disabled=\"\" placeholder=\"Address\" type=\"text\"/>, <input disabled=\"\" placeholder=\"Zip Code\" type=\"text\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:disabled","title":":disabled"},{"location":"selectors/pseudo-classes/#:empty","text":"Selects elements that have no children and no text (whitespace is ignored). Syntax : empty Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <span> <!-- comment --> </span> ... <span></span> ... <span><span> </span></span> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'body :empty' )) [<span> <!-- comment --> </span>, <span></span>, <span> </span>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:empty","title":":empty"},{"location":"selectors/pseudo-classes/#:enabled","text":"Selects any element that is enabled. Syntax : enabled Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <form action=\"#\"> ... <fieldset id=\"shipping\"> ... <legend>Shipping address</legend> ... <input type=\"text\" placeholder=\"Name\"> ... <input type=\"text\" placeholder=\"Address\"> ... <input type=\"text\" placeholder=\"Zip Code\"> ... </fieldset> ... <br> ... <fieldset id=\"billing\"> ... <legend>Billing address</legend> ... <label for=\"billing-checkbox\">Same as shipping address:</label> ... <input type=\"checkbox\" id=\"billing-checkbox\" checked> ... <br> ... <input type=\"text\" placeholder=\"Name\" disabled> ... <input type=\"text\" placeholder=\"Address\" disabled> ... <input type=\"text\" placeholder=\"Zip Code\" disabled> ... </fieldset> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'input:enabled' )) [<input placeholder=\"Name\" type=\"text\"/>, <input placeholder=\"Address\" type=\"text\"/>, <input placeholder=\"Zip Code\" type=\"text\"/>, <input checked=\"\" id=\"billing-checkbox\" type=\"checkbox\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:enabled","title":":enabled"},{"location":"selectors/pseudo-classes/#:first-child","text":"Selects the first child in a group of sibling elements. Syntax : first-child Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:first-child' )) [<p id=\"0\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:first-child","title":":first-child"},{"location":"selectors/pseudo-classes/#:first-of-type","text":"Selects the first child of a given type in a group of sibling elements. Syntax element : first-of-type Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <span id=\"2\"></span> ... <span id=\"3\"></span> ... <span id=\"4\"></span> ... <span id=\"5\"></span> ... <span id=\"6\"></span> ... <p id=\"7\"></p> ... <p id=\"8\"></p> ... <p id=\"9\"></p> ... <p id=\"10\"></p> ... <span id=\"11\"></span> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'span:first-of-type' )) [<span id=\"2\"></span>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:first-of-type","title":":first-of-type"},{"location":"selectors/pseudo-classes/#has","text":"Selects an element if any of the relative selectors passed as parameters (which are relative to the :scope of the given element), match at least one element. While the level 4 specifications state that compound selectors are supported, complex selectors are planned for level 5 CSS selectors. Soup Sieve supports complex selectors. Syntax : has ( selector ) : has (> selector ) : has (~ selector ) : has (+ selector ) : has ( selector1 , > selector2 , ~ selector3 , + selector4 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div><p>Test <span>paragraph</span></p></div> ... <div><p class=\"class\">Another test paragraph</p></div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'div:has(span, > .class)' )) [<div><p>Test <span>paragraph</span></p></div>, <div><p class=\"class\">Another test paragraph</p></div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:has","title":":has()"},{"location":"selectors/pseudo-classes/#:in-range","text":"Selects all < input > elements whose values are in range according to their type , min , and max attributes. Syntax : in-range Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <input id=\"0\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1999-05\"> ... <input id=\"7\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1979-02\"> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':in-range' )) [<input id=\"0\" max=\"2004-08\" min=\"1980-02\" type=\"month\" value=\"1999-05\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:in-range","title":":in-range"},{"location":"selectors/pseudo-classes/#:indeterminate","text":"Selects all form elements whose are in an indeterminate state. An element is considered indeterminate if: The element is of type < input type = \"checkbox\" /> and the indeterminate attribute is set. The element is of type < input type = \"radio\" /> and all other radio controls with the same name are not selected. The element is of type < progress > with no value. Syntax : indeterminate Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <input type=\"checkbox\" id=\"checkbox1\" indeterminate> ... <label for=\"checkbox1\">I like cats.</label> ... ... <input type=\"checkbox\" id=\"checkbox2\"> ... <label for=\"checkbox2\">I like dogs.</label> ... ... <form> ... <input type=\"radio\" name=\"test\" id=\"radio1\"> ... <label for=\"radio1\">Yes</label> ... ... <input type=\"radio\" name=\"test\" id=\"radio2\"> ... <label for=\"radio2\">No</label> ... ... <input type=\"radio\" name=\"test\" id=\"radio3\"> ... <label for=\"radio3\">Maybe</label> ... </form> ... <form> ... <input type=\"radio\" name=\"another\" id=\"radio4\"> ... <label for=\"radio4\">Red</label> ... ... <input type=\"radio\" name=\"another\" id=\"radio5\" checked> ... <label for=\"radio5\">Green</label> ... ... <input type=\"radio\" name=\"another\" id=\"radio6\"> ... <label for=\"radio6\">Blue</label> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':indeterminate' )) [<input id=\"checkbox1\" indeterminate=\"\" type=\"checkbox\"/>, <input id=\"radio1\" name=\"test\" type=\"radio\"/>, <input id=\"radio2\" name=\"test\" type=\"radio\"/>, <input id=\"radio3\" name=\"test\" type=\"radio\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:indeterminate","title":":indeterminate"},{"location":"selectors/pseudo-classes/#:is","text":"Selects an element, but only if it matches at least one selector in the selector list. The alias :matches() is also supported as it was the original name for the selector, and some browsers support it. It is strongly encouraged to use :is() instead as support for :matches() may be dropped in the future. While the level 4 specifications state that compound selectors are supported, some browsers (Safari) support complex selectors which are planned for level 5 CSS selectors. Soup Sieve also supports complex selectors. Syntax : is ( selector1 , selector2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>. ... <a id=\"2\" href=\"http://google.com\">Link.</a></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[id]:is(a, span)' )) [<span id=\"1\"> in a paragraph</span>, <a href=\"http://google.com\" id=\"2\">Link.</a>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:is","title":":is()"},{"location":"selectors/pseudo-classes/#:lang","text":"Level 3 CSS Selects an element whose associated language matches the provided language or whose language starts with the provided language followed by a - . Language is determined by the rules of the document type. Syntax : lang ( language ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div lang=\"de-DE\"> ... <p id=\"1\"></p> ... </div> ... <div lang=\"de-DE-1996\"> ... <p id=\"2\"></p> ... </div> ... <div lang=\"de-Latn-DE\"> ... <p id=\"3\"></p> ... </div> ... <div lang=\"de-Latf-DE\"> ... <p id=\"4\"></p> ... </div> ... <div lang=\"de-Latn-DE-1996\"> ... <p id=\"5\"></p> ... </div> ... <p id=\"6\" lang=\"de-DE\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:lang(de)' )) [<p id=\"1\"></p>, <p id=\"2\"></p>, <p id=\"3\"></p>, <p id=\"4\"></p>, <p id=\"5\"></p>, <p id=\"6\" lang=\"de-DE\"></p>] Level 4 CSS The level 4 CSS specifications adds the ability to define multiple language tags using a comma separated list. The specifications also allow for BCP 47 language ranges as described in RFC4647 for extended filtering. This enables implicit wildcard matching between subtags. For instance, :lang(de-DE) will match all of de-DE , de-DE-1996 , de-Latn-DE , de-Latf-DE , and de-Latn-DE-1996 . Implicit wildcard matching will not take place at the beginning on the primary language tag, * must be used to force wildcard matching at the beginning of the language. If desired an explicit wildcard between subtags can be used, but since implicit wildcard matching already takes place between subtags, it is not needed: de-*-DE would be the same as just using de-DE . Syntax : lang ( '*-language' , language2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div lang=\"de-DE\"> ... <p id=\"1\"></p> ... </div> ... <div lang=\"en\"> ... <p id=\"2\"></p> ... </div> ... <div lang=\"de-Latn-DE\"> ... <p id=\"3\"></p> ... </div> ... <div lang=\"de-Latf-DE\"> ... <p id=\"4\"></p> ... </div> ... <div lang=\"en-US\"> ... <p id=\"5\"></p> ... </div> ... <p id=\"6\" lang=\"de-DE\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:lang(de-DE, \"*-US\")' )) [<p id=\"1\"></p>, <p id=\"3\"></p>, <p id=\"4\"></p>, <p id=\"5\"></p>, <p id=\"6\" lang=\"de-DE\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:lang","title":":lang()"},{"location":"selectors/pseudo-classes/#:last-child","text":"Selects the last element among a group of sibling elements. Syntax : last-child Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:last-child' )) [<p id=\"5\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:last-child","title":":last-child"},{"location":"selectors/pseudo-classes/#:last-of-type","text":"Selects the last child of a given type in a group of sibling elements. Syntax element : last-of-type Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <span id=\"2\"></span> ... <span id=\"3\"></span> ... <span id=\"4\"></span> ... <span id=\"5\"></span> ... <span id=\"6\"></span> ... <p id=\"7\"></p> ... <p id=\"8\"></p> ... <p id=\"9\"></p> ... <p id=\"10\"></p> ... <span id=\"11\"></span> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'span:last-of-type' )) [<span id=\"11\"></span>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:last-of-type","title":":last-of-type"},{"location":"selectors/pseudo-classes/#:link","text":"Selects a link (every < a > , < link > , and < area > element with an href attribute) that has not yet been visited. Since Beautiful Soup does not have visited states, this will match all links, essentially making the behavior the same as :any-link . Syntax : link Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p>A link to <a href=\"http://example.com\">click</a></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':link' )) [<a href=\"http://example.com\">click</a>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:link","title":":link"},{"location":"selectors/pseudo-classes/#:not","text":"Level 3 CSS Selects all elements that do not match the selector. The level 3 CSS specification states that :not() only supports simple selectors. Syntax : not ( simple-selector ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'div:not(:contains(more))' )) [<div>Here is some text.</div>] Level 4+ CSS Selects all elements that do not match any of the selectors in the selector list. While the level 4 specifications state that compound selectors are supported, some browsers (Safari) support complex selectors which are planned for level 5 CSS selectors. Soup Sieve also supports complex selectors. Syntax : not ( compound . selector , complex > selector ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '*:not(html, head, body)' )) [<div>Here is some text.</div>, <div>Here is some more text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:not","title":":not()"},{"location":"selectors/pseudo-classes/#:nth-child","text":":nth-child() matches elements based on their position in a group of siblings. Level 3 CSS The keywords even and odd will respectively select elements whose position is either even or odd amongst a group of siblings. Patterns in the form an+b selects elements based on their position in a group of siblings, for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Syntax : nth-child ( even ) : nth-child ( odd ) : nth-child ( 2 ) : nth-child ( 2n + 2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:nth-child(even)' )) [<p id=\"1\"></p>, <p id=\"3\"></p>, <p id=\"5\"></p>] >>> print ( soup . select ( 'p:nth-child(odd)' )) [<p id=\"0\"></p>, <p id=\"2\"></p>, <p id=\"4\"></p>] >>> print ( soup . select ( 'p:nth-child(2)' )) [<p id=\"1\"></p>] >>> print ( soup . select ( 'p:nth-child(-n+3)' )) [<p id=\"0\"></p>, <p id=\"1\"></p>, <p id=\"2\"></p>] Level 4+ CSS Level 4 CSS adds the additional pattern in the form an+b of S where S represents a selector list. an+b can also be substituted with even or odd . Wen using the pattern an+b of S , the pattern will select elements from a sub-group of sibling elements that all match the selector list ( [of S]? ), based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Essentially, img : nth-of-type ( 2 ) would be equivalent to : nth-child ( 2 of img ) . The advantage of using :nth-child(an+b [of S]?) over :nth-of-type is that :nth-of-type is restricted to types, while :nth-child(an+b [of S]?) can use complex selectors. While the level 4 specifications state that compound selectors are supported, complex selectors are planned for level 5 CSS selectors. Soup Sieve supports complex selectors. Syntax : nth-child ( 2 of img ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '*:nth-child(-n+3 of [id])' )) [<p id=\"0\"></p>, <p id=\"1\"></p>, <p id=\"2\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child","title":":nth-child()"},{"location":"selectors/pseudo-classes/#:nth-last-child","text":":nth-last-child() matches elements based on their position in a group of siblings, counting from the end. Level 3 CSS Counting from the end, the keywords even and odd will respectively select elements whose position is either even or odd amongst a group of siblings. Counting from the end, patterns in the form an+b selects elements based on their position in a group of siblings, for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Syntax : nth-last-child ( even ) : nth-last-child ( odd ) : nth-last-child ( 2 ) : nth-last-child ( 2n + 2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:nth-last-child(even)' )) [<p id=\"0\"></p>, <p id=\"2\"></p>, <p id=\"4\"></p>] >>> print ( soup . select ( 'p:nth-last-child(odd)' )) [<p id=\"1\"></p>, <p id=\"3\"></p>, <p id=\"5\"></p>] >>> print ( soup . select ( 'p:nth-last-child(2)' )) [<p id=\"4\"></p>] >>> print ( soup . select ( 'p:nth-last-child(-n+3)' )) [<p id=\"3\"></p>, <p id=\"4\"></p>, <p id=\"5\"></p>] Level 4+ CSS Level 4 CSS adds the additional pattern in the form an+b of S where S represents a selector list. an+b can also be substituted with even or odd . Wen using the pattern an+b of S , the pattern will select elements from a sub-group of sibling elements that all match the selector list ( [of S]? ), based on their position within that sub-group, using the pattern an+b , for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Elements will be counted from the end. Essentially, img : nth-last-of-type ( 2 ) would be equivalent to : nth-last-child ( 2 of img ) . The advantage of using :nth-last-child(an+b [of S]?) over :nth-last-of-type is that :nth-last-of-type is restricted to types, while :nth-last-child(an+b [of S]?) can use complex selectors. While the level 4 specifications state that compound selectors are supported, complex selectors are planned for level 5 CSS selectors. Soup Sieve supports complex selectors. Syntax : nth-last-child ( 2 of img ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '*:nth-last-child(-n+3 of [id])' )) [<p id=\"3\"></p>, <p id=\"4\"></p>, <p id=\"5\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-last-child","title":":nth-last-child()"},{"location":"selectors/pseudo-classes/#:nth-last-of-type","text":":nth-of-type() matches elements of a given type, based on their position among a group of siblings, counting from the end. The keywords even and odd , and will respectively select elements, from a sub-group of sibling elements that all match the given type, whose position is either even or odd amongst that sub-group of siblings. Starting position is counted from the end. Patterns in the form an+b select from a sub-group of sibling elements that all match the given type, based on their position within that sub-group, for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Starting position is counted from the end. Syntax element : nth-last-of-type ( even ) element : nth-last-of-type ( odd ) element : nth-last-of-type ( 2 ) element : nth-last-of-type ( 2n + 2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <span id=\"2\"></span> ... <span id=\"3\"></span> ... <span id=\"4\"></span> ... <span id=\"5\"></span> ... <span id=\"6\"></span> ... <p id=\"7\"></p> ... <p id=\"8\"></p> ... <p id=\"9\"></p> ... <p id=\"10\"></p> ... <span id=\"11\"></span> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'span:nth-last-of-type(even)' )) [<span id=\"2\"></span>, <span id=\"4\"></span>, <span id=\"6\"></span>] >>> print ( soup . select ( 'span:nth-last-of-type(odd)' )) [<span id=\"3\"></span>, <span id=\"5\"></span>, <span id=\"11\"></span>] >>> print ( soup . select ( 'p:nth-last-of-type(2)' )) [<p id=\"9\"></p>] >>> print ( soup . select ( 'p:nth-last-of-type(-n+3)' )) [<p id=\"8\"></p>, <p id=\"9\"></p>, <p id=\"10\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-last-of-type","title":":nth-last-of-type()"},{"location":"selectors/pseudo-classes/#:nth-of-type","text":":nth-of-type() matches elements of a given type, based on their position among a group of siblings. The keywords even and odd , and will respectively select elements, from a sub-group of sibling elements that all match the given type, whose position is either even or odd amongst that sub-group of siblings. Patterns in the form an+b select from a sub-group of sibling elements that all match the given type, based on their position within that sub-group, for every positive integer or zero value of n . The index of the first element is 1 . The values a and b must both be integers. Syntax element : nth-of-type ( even ) element : nth-of-type ( odd ) element : nth-of-type ( 2 ) element : nth-of-type ( 2n + 2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <span id=\"2\"></span> ... <span id=\"3\"></span> ... <span id=\"4\"></span> ... <span id=\"5\"></span> ... <span id=\"6\"></span> ... <p id=\"7\"></p> ... <p id=\"8\"></p> ... <p id=\"9\"></p> ... <p id=\"10\"></p> ... <span id=\"11\"></span> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'span:nth-of-type(even)' )) [<span id=\"3\"></span>, <span id=\"5\"></span>, <span id=\"11\"></span>] >>> print ( soup . select ( 'span:nth-of-type(odd)' )) [<span id=\"2\"></span>, <span id=\"4\"></span>, <span id=\"6\"></span>] >>> print ( soup . select ( 'p:nth-of-type(2)' )) [<p id=\"1\"></p>] >>> print ( soup . select ( 'p:nth-of-type(-n+3)' )) [<p id=\"0\"></p>, <p id=\"1\"></p>, <p id=\"7\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-of-type","title":":nth-of-type()"},{"location":"selectors/pseudo-classes/#:only-child","text":"Selects element without any siblings. Syntax : only-child Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <p id=\"2\"></p> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... </div> ... <div> ... <p id=\"6\"></p> ... </div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'p:only-child' )) [<p id=\"6\"></p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:only-child","title":":only-child"},{"location":"selectors/pseudo-classes/#:only-of-type","text":"Selects element without any siblings that matches a given type. Syntax element : only-of-type Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\"></p> ... <p id=\"1\"></p> ... <span id=\"2\"></span> ... <p id=\"3\"></p> ... <p id=\"4\"></p> ... <p id=\"5\"></p> ... <p id=\"6\"></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'span:only-of-type' )) [<span id=\"2\"></span>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:only-of-type","title":":only-of-type"},{"location":"selectors/pseudo-classes/#:optional","text":"Selects any < input > , < select > , or < textarea > element that does not have the required attribute set on it. Syntax : optional Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <form> ... <input type=\"name\" required> ... <input type=\"checkbox\" required> ... <input type=\"email\"> ... <textarea name=\"name\" cols=\"30\" rows=\"10\" required></textarea> ... <select name=\"nm\" required> ... <!-- options --> ... </select> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':optional' )) [<input type=\"email\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:optional","title":":optional"},{"location":"selectors/pseudo-classes/#:out-of-range","text":"Selects all < input > elements whose values are out of range according to their type , min , and max attributes. Syntax : out-of-range Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <input id=\"0\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1999-05\"> ... <input id=\"7\" type=\"month\" min=\"1980-02\" max=\"2004-08\" value=\"1979-02\"> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':out-of-range' )) [<input id=\"7\" max=\"2004-08\" min=\"1980-02\" type=\"month\" value=\"1979-02\"/>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:out-of-range","title":":out-of-range"},{"location":"selectors/pseudo-classes/#:placeholder-shown","text":"Selects any < input > or < textarea > element that is currently displaying placeholder text via the placeholder attribute. Syntax : placeholder-shown Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <input id=\"0\" placeholder=\"This is some text\"> ... <textarea id=\"1\" placeholder=\"This is some text\"></textarea> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':placeholder-shown' )) [<input id=\"0\" placeholder=\"This is some text\"/>, <textarea id=\"1\" placeholder=\"This is some text\"></textarea>] Parser Differences In general, when an input has a placeholder, but the element also has valid content, the placeholder is not shown. For instance, when a textarea has actual text associated with the element, the placeholder is overridden with the actual content. A textarea is allowed no more than a single newline to be considered as having no content (carriage returns don't count). html5lib will strip out carriage returns, but lxml and html.parser will not. This will cause a difference between the parsers when dealing with Windows style line endings and textareas . html5lib seems to follow closest to what real browsers do. Soup Sieve is simply following the specification as best it can. Unfortunately, it can't account for the quirks of the parsers in this case without introducing other issues. Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:placeholder-shown","title":":placeholder-shown"},{"location":"selectors/pseudo-classes/#:read-only","text":"Selects elements (such as < input > or < textarea > ) that are not editable by the user. This does not just apply to form elements with readonly set, but it applies to any element that cannot be edited by the user. Syntax : read-only Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... ... <input id=\"0\"> ... <input id=\"1\" disabled> ... <input id=\"2\" type=\"number\" readonly> ... ... <textarea id=\"3\"></textarea> ... ... <p id=\"4\">Not editable</p> ... <p id=\"5\" contenteditable=\"true\">Editable text</p> ... ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'body :read-only' )) [<input disabled=\"\" id=\"1\"/>, <input id=\"2\" readonly=\"\" type=\"number\"/>, <p id=\"4\">Not editable</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:read-only","title":":read-only"},{"location":"selectors/pseudo-classes/#:read-write","text":"Selects elements (such as < input > or < textarea > ) that are editable by the user. This does not just apply to form elements as it applies to any element that can be edited by the user, such as a < p > element with contenteditable set on it. Syntax : read-only Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... ... <input id=\"0\"> ... <input id=\"1\" disabled> ... <input id=\"2\" type=\"number\" readonly> ... ... <textarea id=\"3\"></textarea> ... ... <p id=\"4\">Not editable</p> ... <p id=\"5\" contenteditable=\"true\">Editable text</p> ... ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( 'body :read-write' )) [<input id=\"0\"/>, <textarea id=\"3\"></textarea>, <p contenteditable=\"true\" id=\"5\">Editable text</p>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:read-write","title":":read-write"},{"location":"selectors/pseudo-classes/#:required","text":"Selects any < input > , < select > , or < textarea > element that has the required attribute set on it. Syntax : required Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <form> ... <input type=\"name\" required> ... <input type=\"checkbox\" required> ... <input type=\"email\"> ... <textarea name=\"name\" cols=\"30\" rows=\"10\" required></textarea> ... <select name=\"nm\" required> ... <!-- options --> ... </select> ... </form> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':required' )) [<input required=\"\" type=\"name\"/>, <input required=\"\" type=\"checkbox\"/>, <textarea cols=\"30\" name=\"name\" required=\"\" rows=\"10\"></textarea>, <select name=\"nm\" required=\"\"> <!-- options --> </select>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:required","title":":required"},{"location":"selectors/pseudo-classes/#:root","text":"Selects the root element of a document tree. Syntax : root Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( ':root' )) [<html><head></head> <body> <div>Here is some text.</div> <div>Here is some more text.</div> </body></html>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:root","title":":root"},{"location":"selectors/pseudo-classes/#:scope","text":":scope represents the the element a match , select , or filter is being called on. If we were, for instance, using :scope on a div ( sv . select ( ':scope > p' , soup . div ) ) :scope would represent that div element, and no others. If called on the Beautiful Soup object which represents the entire document, it would simply select :root . Syntax : scope Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <div>Here is some text.</div> ... <div>Here is some more text.</div> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select_one ( 'body' ) . select ( ':scope > div' )) [<div>Here is some text.</div>, <div>Here is some more text.</div>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:scope","title":":scope"},{"location":"selectors/pseudo-classes/#:where","text":"Selects an element, but only if it matches at least one selector in the selector list. In browsers, this also has zero specificity, but this only has relevance in a browser environment where you have multiple CSS styles, and specificity is used to see which applies. Beautiful Soup and Soup Sieve don't care about specificity so :where() is essentially just an alias for :is() . While the level 4 specifications state that compound selectors are supported, some browsers (Safari) support complex selectors which are planned for level 5 CSS selectors. Soup Sieve also supports complex selectors. Syntax : where ( selector1 , selector2 ) Usage >>> from bs4 import BeautifulSoup as bs >>> html = \"\"\" ... <html> ... <head></head> ... <body> ... <p id=\"0\">Some text <span id=\"1\"> in a paragraph</span>. ... <a id=\"2\" href=\"http://google.com\">Link.</a></p> ... </body> ... </html> ... \"\"\" >>> soup = bs ( html , 'html5lib' ) >>> print ( soup . select ( '[id]:where(a, span)' )) [<span id=\"1\"> in a paragraph</span>, <a href=\"http://google.com\" id=\"2\">Link.</a>] Additional Reading https://developer.mozilla.org/en-US/docs/Web/CSS/:where html { --svg-beaker: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='beaker'%3E%3Cpath d='M3,3V5A2,2 0 0,1 5,7V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V7A2,2 0 0,1 21,5V3H3M7,9H10V10H7V9M7,11H10V12H7V11M10,16H7V15H10V16M12,14H7V13H12V14M12,8H7V7H12V8Z' /%3E%3C/svg%3E\"); --svg-html5: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath d='M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z'/%3E%3C/svg%3E\"); --svg-star: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='star'%3E%3Cpath d='M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z' /%3E%3C/svg%3E\"); } span.lab::after, span.html5::after, span.star::after { position: relative; display: inline-block; width: 1em; height: 1em; padding-right: 1em; background-size: 1em; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; content: \"\\a0\"; } span.big-icon::after { width: 3em; height: 3em; background-size: 3em; } .badge { float: right; } span.lab::after { background-color: hsl(265, 89%, 78%); -webkit-mask-image: var(--svg-beaker); mask-image: var(--svg-beaker); } span.html5::after { background-color: hsl(31, 100%, 71%); -webkit-mask-image: var(--svg-html5); mask-image: var(--svg-html5); } span.star::after { background-color: hsl(135, 94%, 65%); -webkit-mask-image: var(--svg-star); mask-image: var(--svg-star); }","title":":where()"},{"location":"selectors/unsupported/","text":"Non-Applicable Pseudo Classes Overview These pseudo classes are recognized by the parser, and have been identified as not being applicable in a Beautiful Soup environment. While the pseudo-classes will parse correctly, they will not match anything. This is because they cannot be implemented outside a live, browser environment. If at any time these are dropped from the CSS spec, they will simply be removed. :active Selects active elements. Syntax : active :current :current selects the element, or an ancestor of the element, that is currently being displayed. The functional form of :current() takes a compound selector list. Syntax : current : current ( selector1 , selector2 ) :focus Represents an an element that has received focus. Syntax : focus :focus-visible Selects an element that matches :focus and the user agent determines that the focus should be made evident on the element. Syntax : focus-visible :focus-within Selects an element that has received focus or contains an element that has received focus. Syntax : focus-within :future Selects an element that is defined to occur entirely after a :current element. Syntax : future :host :host selects the element hosting a shadow tree. While the function form of :host() takes a complex selector list and matches the shadow host only if it matches one of the selectors in the list. Syntax : host : host ( selector1 , selector2 ) :host-context() Selects the element hosting shadow tree, but only if one of the element's ancestors match a selector in the selector list. Syntax : host-context ( parent descendant ) :hover Selects an element when the user interacts with it by hovering over it with a pointing device. Syntax : hover :local-link Selects link (every < a > , < link > , and < area > element with an href attribute) elements whose absolute URL matches the element\u2019s own document URL. Syntax : local-link :past Selects an element that is defined to occur entirely prior to a :current element. Syntax : past :paused Selects an element that is capable of being played or paused (such as an audio, video, or similar resource) and is currently \"paused\". Syntax : paused :playing Selects an element that is capable of being played or paused (such as an audio, video, or similar resource) and is currently \"playing\". Syntax : playing :target Selects a unique element (the target element) with an id matching the URL's fragment. Syntax : target :target-within Selects a unique element with an id matching the URL's fragment or an element which contains the element. Syntax : target-within :user-invalid Selects an element with incorrect input, but only after the user has significantly interacted with it. Syntax : user-invalid :visited Selects links that have already been visited. Syntax : visited html { --svg-beaker: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='beaker'%3E%3Cpath d='M3,3V5A2,2 0 0,1 5,7V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V7A2,2 0 0,1 21,5V3H3M7,9H10V10H7V9M7,11H10V12H7V11M10,16H7V15H10V16M12,14H7V13H12V14M12,8H7V7H12V8Z' /%3E%3C/svg%3E\"); --svg-html5: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath d='M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z'/%3E%3C/svg%3E\"); --svg-star: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='star'%3E%3Cpath d='M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z' /%3E%3C/svg%3E\"); } span.lab::after, span.html5::after, span.star::after { position: relative; display: inline-block; width: 1em; height: 1em; padding-right: 1em; background-size: 1em; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; content: \"\\a0\"; } span.big-icon::after { width: 3em; height: 3em; background-size: 3em; } .badge { float: right; } span.lab::after { background-color: hsl(265, 89%, 78%); -webkit-mask-image: var(--svg-beaker); mask-image: var(--svg-beaker); } span.html5::after { background-color: hsl(31, 100%, 71%); -webkit-mask-image: var(--svg-html5); mask-image: var(--svg-html5); } span.star::after { background-color: hsl(135, 94%, 65%); -webkit-mask-image: var(--svg-star); mask-image: var(--svg-star); }","title":"Non-Applicable Pseudo Classes"},{"location":"selectors/unsupported/#non-applicable-pseudo-classes","text":"","title":"Non-Applicable Pseudo Classes"},{"location":"selectors/unsupported/#overview","text":"These pseudo classes are recognized by the parser, and have been identified as not being applicable in a Beautiful Soup environment. While the pseudo-classes will parse correctly, they will not match anything. This is because they cannot be implemented outside a live, browser environment. If at any time these are dropped from the CSS spec, they will simply be removed.","title":"Overview"},{"location":"selectors/unsupported/#:active","text":"Selects active elements. Syntax : active","title":":active"},{"location":"selectors/unsupported/#:current","text":":current selects the element, or an ancestor of the element, that is currently being displayed. The functional form of :current() takes a compound selector list. Syntax : current : current ( selector1 , selector2 )","title":":current"},{"location":"selectors/unsupported/#:focus","text":"Represents an an element that has received focus. Syntax : focus","title":":focus"},{"location":"selectors/unsupported/#:focus-visible","text":"Selects an element that matches :focus and the user agent determines that the focus should be made evident on the element. Syntax : focus-visible","title":":focus-visible"},{"location":"selectors/unsupported/#:focus-within","text":"Selects an element that has received focus or contains an element that has received focus. Syntax : focus-within","title":":focus-within"},{"location":"selectors/unsupported/#:future","text":"Selects an element that is defined to occur entirely after a :current element. Syntax : future","title":":future"},{"location":"selectors/unsupported/#host","text":":host selects the element hosting a shadow tree. While the function form of :host() takes a complex selector list and matches the shadow host only if it matches one of the selectors in the list. Syntax : host : host ( selector1 , selector2 )","title":":host"},{"location":"selectors/unsupported/#:host-context","text":"Selects the element hosting shadow tree, but only if one of the element's ancestors match a selector in the selector list. Syntax : host-context ( parent descendant )","title":":host-context()"},{"location":"selectors/unsupported/#:hover","text":"Selects an element when the user interacts with it by hovering over it with a pointing device. Syntax : hover","title":":hover"},{"location":"selectors/unsupported/#:local-link","text":"Selects link (every < a > , < link > , and < area > element with an href attribute) elements whose absolute URL matches the element\u2019s own document URL. Syntax : local-link","title":":local-link"},{"location":"selectors/unsupported/#:past","text":"Selects an element that is defined to occur entirely prior to a :current element. Syntax : past","title":":past"},{"location":"selectors/unsupported/#:paused","text":"Selects an element that is capable of being played or paused (such as an audio, video, or similar resource) and is currently \"paused\". Syntax : paused","title":":paused"},{"location":"selectors/unsupported/#:playing","text":"Selects an element that is capable of being played or paused (such as an audio, video, or similar resource) and is currently \"playing\". Syntax : playing","title":":playing"},{"location":"selectors/unsupported/#:target","text":"Selects a unique element (the target element) with an id matching the URL's fragment. Syntax : target","title":":target"},{"location":"selectors/unsupported/#:target-within","text":"Selects a unique element with an id matching the URL's fragment or an element which contains the element. Syntax : target-within","title":":target-within"},{"location":"selectors/unsupported/#:user-invalid","text":"Selects an element with incorrect input, but only after the user has significantly interacted with it. Syntax : user-invalid","title":":user-invalid"},{"location":"selectors/unsupported/#:visited","text":"Selects links that have already been visited. Syntax : visited html { --svg-beaker: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='beaker'%3E%3Cpath d='M3,3V5A2,2 0 0,1 5,7V19A2,2 0 0,0 7,21H17A2,2 0 0,0 19,19V7A2,2 0 0,1 21,5V3H3M7,9H10V10H7V9M7,11H10V12H7V11M10,16H7V15H10V16M12,14H7V13H12V14M12,8H7V7H12V8Z' /%3E%3C/svg%3E\"); --svg-html5: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 384 512'%3E%3Cpath d='M0 32l34.9 395.8L191.5 480l157.6-52.2L384 32H0zm308.2 127.9H124.4l4.1 49.4h175.6l-13.6 148.4-97.9 27v.3h-1.1l-98.7-27.3-6-75.8h47.7L138 320l53.5 14.5 53.7-14.5 6-62.2H84.3L71.5 112.2h241.1l-4.4 47.7z'/%3E%3C/svg%3E\"); --svg-star: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' id='star'%3E%3Cpath d='M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z' /%3E%3C/svg%3E\"); } span.lab::after, span.html5::after, span.star::after { position: relative; display: inline-block; width: 1em; height: 1em; padding-right: 1em; background-size: 1em; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; content: \"\\a0\"; } span.big-icon::after { width: 3em; height: 3em; background-size: 3em; } .badge { float: right; } span.lab::after { background-color: hsl(265, 89%, 78%); -webkit-mask-image: var(--svg-beaker); mask-image: var(--svg-beaker); } span.html5::after { background-color: hsl(31, 100%, 71%); -webkit-mask-image: var(--svg-html5); mask-image: var(--svg-html5); } span.star::after { background-color: hsl(135, 94%, 65%); -webkit-mask-image: var(--svg-star); mask-image: var(--svg-star); }","title":":visited"}]}